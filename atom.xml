<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skrupellose.github.io</id>
    <title>D.C </title>
    <updated>2019-11-24T16:08:02.625Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skrupellose.github.io"/>
    <link rel="self" href="https://skrupellose.github.io/atom.xml"/>
    <subtitle>人类世界真是太有趣了</subtitle>
    <logo>https://skrupellose.github.io/images/avatar.png</logo>
    <icon>https://skrupellose.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, D.C </rights>
    <entry>
        <title type="html"><![CDATA[有趣的axios源码（一）]]></title>
        <id>https://skrupellose.github.io/post/you-qu-de-axios-yuan-ma-yi</id>
        <link href="https://skrupellose.github.io/post/you-qu-de-axios-yuan-ma-yi">
        </link>
        <updated>2019-11-24T14:48:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-现象">一、现象：</h1>
<p>若我们添加两组请求和响应拦截器<br>
请求拦截器先添加的后执行，响应拦截器先添加的先执行。</p>
<pre><code>axios.interceptors.request.use(
  config =&gt; {
    console.log('request interceptor1 onResolved()')
      return config
  },
  error =&gt; {
    console.log('request interceptor1 onResolved()')
      return Promise.reject(error);
  }
)
axios.interceptors.request.use(
  config =&gt; {
    console.log('request interceptor2 onResolved()')
      return config
  },
  error =&gt; {
    console.log('request interceptor2 onResolved()')
      return Promise.reject(error);
  }
)
axios.interceptors.response.use(
  response =&gt; {
    console.log('response interceptor1 onResolved()')
      return response
  },
  error =&gt; {
    console.log('response interceptor1 onResolved()')
      return Promise.reject(error);
  }
)
axios.interceptors.response.use(
  response =&gt; {
    console.log('response interceptor2 onResolved()')
      return response
  },
  error =&gt; {
    console.log('response interceptor2 onResolved()')
      return Promise.reject(error);
  }
)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://skrupellose.github.io/post-images/1574609692911.png" alt=""></figure>
<h1 id="二-原因">二、原因</h1>
<p>axios基于promise进行封装<br>
这部分的源码：(axios/lib/core/Axios.js)</p>
<pre><code>
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
//后添加的请求拦截器放在数组前面
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
//每个拦截器都包含两个回调函数一个成功的回调一个失败的回调
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
//后添加的响应拦截器放在数组后面
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });
//通过promise的then()方法串连起所有的请求拦截器/请求方法/响应拦截器
  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }
//最后返回我们使用axios函数指定了onResolved和onRejectd的promise
  return promise;
};
</code></pre>
<p>通过分析我们可以看出这个流程的大概步骤：</p>
<ol>
<li>隐式创建出用来保存请求和响应拦截函数的数组 -&gt; requestInterceptor和responseInterceptor</li>
<li>chain数组保存发送请求的函数</li>
<li>chain数组通过unshift和push方法分别往里面添加请求拦截函数和响应拦截函数</li>
<li>数组左边放的是请求拦截器函数</li>
<li>数组右边放的是响应拦截器函数</li>
</ol>
<pre><code>//我们用1,2,3,4分别代表从第一个请求拦截器到第二个响应拦截
1. requestInterceptor:[{fulfilled1(){}, rejected1(){}}, {fulfilled2(){}, rejected2(){}}]
   responseInterceptor:[{fulfilled3(){}, rejected3(){}}, {fulfilled4(){}, rejected4(){}}]
2. chain:[dispatchRequest, undefined]
3. chain:[
        fulfilled2, rejected2, fulfilled1, rejected1, 
        dispatchRequest, undefined, 
        fulfilled3, rejected3, fulfilled4, rejected4
        ]
//这就是最后的chain数组的样子，我们可以看到后添加的请求拦截器在数组的首位
</code></pre>
<p>其实看到chain.unshift请求拦截函数的时候就已经能够解释为什么添加多组响应器时请求拦截器先添加的后执行，因为unshift方法就是往数组的首位去插入元素，而push是往末尾添加元素。</p>
<p>之后通过</p>
<pre><code>while (chain.length) {
    //每次取出两个元素，正好对应一个拦截器的成功回调与失败回调
    promise = promise.then(chain.shift(), chain.shift());
return promise;
</code></pre>
<p>shift()删除第一个当前数组元素并返回该数据，这也正好我们拦截器的执行顺序，从chain数组的首位开始执行。故有了我们请求拦截器先添加的后执行，响应拦截器先添加的先执行的现象<br>
我们promise链的样子就是这样的：</p>
<pre><code>config =&gt; (fulfilled2, rejected2) =&gt; (fulfilled1, rejected1) //请求拦截器处理
       =&gt; (dispatchRequest, undefined) //发请求
       =&gt; (fulfilled3, rejected3) =&gt; (fulfilled4, rejected4) //响应拦截器处理
       =&gt; (onResolved, onRejected) //我们通过axios发送请求后的处理
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue+element.ui+axios做一个简单用户管理demo]]></title>
        <id>https://skrupellose.github.io/post/vueelementuiaxios-zuo-yi-ge-jian-dan-yong-hu-guan-li-demo</id>
        <link href="https://skrupellose.github.io/post/vueelementuiaxios-zuo-yi-ge-jian-dan-yong-hu-guan-li-demo">
        </link>
        <updated>2019-11-17T14:55:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-技术栈">一、技术栈</h1>
<p>vue、element.ui、axios</p>
<h1 id="二-准备工作">二、准备工作</h1>
<p>接口：<br>
<code>http://www.liulongbin.top:3005/</code><br>
这是在b站上小伙伴留下的测试接口</p>
<p>要实现的功能：</p>
<ol>
<li>
<p>添加用户<br>
<img src="https://skrupellose.github.io/post-images/1574007328629.png" alt=""></p>
</li>
<li>
<p>搜索功能<br>
<img src="https://skrupellose.github.io/post-images/1574007313864.png" alt=""><br>
<img src="https://skrupellose.github.io/post-images/1574007386230.png" alt=""></p>
</li>
<li>
<p>删除用户<br>
<img src="https://skrupellose.github.io/post-images/1574007394205.png" alt=""></p>
</li>
</ol>
<h1 id="三-具体实现">三、具体实现</h1>
<h2 id="31-用户数据展示和删除">3.1 用户数据展示和删除</h2>
<p>我们的用户数据用table显示，新增用户用form结合dialog组件实现。</p>
<p>这里主要是讲 <code>&lt;template slot-scope=&quot;scope&quot;&gt;</code>,官方文档讲通过<code>Scoped slot</code>可以获取到<code>row</code>, <code>column</code>, <code>$index</code> 和 <code>store（table 内部的状态管理）</code>的数据。<br>
我们一般表格只是显示数据的话，那么我们只需要在<code>el-table-column</code>标签中添加prop属性，填上对应的值，那么表格就能渲染出来。如：</p>
<pre><code>        &lt;el-table :data=&quot;tableData&quot; ref=&quot;tableData&quot; border stripe&gt;
          &lt;el-table-column label=&quot;序号&quot; width=&quot;90&quot; prop=&quot;id&quot;&gt;
          &lt;/el-table-column&gt;
           &lt;el-table-column label=&quot;用户名&quot; prop=&quot;name&quot;&gt;
          &lt;/el-table-column&gt;
           &lt;el-table-column label=&quot;时间&quot; prop=&quot;ctime&quot;&gt;
          &lt;/el-table-column&gt;
        &lt;/el-table&gt;
</code></pre>
<p>但是这样我们不好监听删除事件，所以我们使用<code>&lt;template slot-scope=&quot;scope&quot;&gt;</code></p>
<pre><code>        &lt;el-table :data=&quot;tableData&quot; ref=&quot;tableData&quot; border stripe&gt;
          &lt;el-table-column label=&quot;序号&quot; width=&quot;90&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.id }}&lt;/span&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;用户名&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.name }}&lt;/span&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;时间&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.ctime }}&lt;/span&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;操作&quot; width=&quot;160&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;el-button type=&quot;primary&quot;&gt;编辑&lt;/el-button&gt;
              &lt;el-button @click.native.prevent=&quot;_del(scope.row.id)&quot; type=&quot;danger&quot;&gt;移除&lt;/el-button&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
        &lt;/el-table&gt;
</code></pre>
<p>通过<code>scope.row.id</code>我们就能得到当前点击的数据的id值，这也是它的唯一索引，我们通过向后台提交这个值来达到删除该条数据的目的。</p>
<pre><code>function del(id) {
  const url = &quot;api/delproduct/&quot;;
  return $axios.get(url + id);
</code></pre>
<pre><code>method:

   _del(id) {
      del(id).then(res =&gt; {
        const result = res.data;
        if (result.status === 0) {
          this._getlist();//删除之后获取新数据达到刷新效果
        }
        console.log(res);
      });
    },
</code></pre>
<h2 id="32-用户添加">3.2 用户添加</h2>
<p>我们获取用户列表的时候执行一次axios请求，添加之后也要执行一下这个方法达到刷新的目的，删除也是这样。</p>
<pre><code>const $axios = axios.create({
  // 设置超时时间
  timeout: 30000,
  // 基础url，会在请求url中自动添加前置链接
  baseURL: &quot;http://www.liulongbin.top:3005/&quot;
});
</code></pre>
<p>我们还是配置一下我们的axios实例，这样后面写url的时候会方便很多。<br>
获取列表的方法：</p>
<pre><code>function getlist() {
  const url = &quot;api/getprodlist&quot;;
  return $axios.get(url);
}
</code></pre>
<p>然后在method中对这个请求做一下处理：</p>
<pre><code>    _getlist() {
      getlist().then(res =&gt; {
        console.log(res);
        this.allList = res.data.message;
        this.tableData = this.allList;
      });
    },
</code></pre>
<p>之后我们在<code>create</code>的时候第一次执行<code>_getlist()</code>获取用户信息。<br>
用户添加功能我们写在<code>form</code>表单里面，然后写一个<code>dialog</code>控件把<code>form</code>嵌在<code>dialog</code>上，平时使它的值为<code>false</code>，在点击添加的时候变为<code>true</code>，这样<code>dialog</code>就会显示出来，我们就能在<code>form</code>上添加用户了。</p>
<p>这里需要注意的一点就是关于函数的this指向，我之前也是将<code>add()</code>函数封装了一下，外面又套了一个函数<code>_add()</code>对<code>add()</code>方法返回的信息进行处理，在添加用户的时候调用_add()方法，然后传值<code>this.formData.name</code>,但是这个时候this指向的不是表单，而是调用套在它外面的<code>_add()</code>函数（add方法是<code>axios</code>请求，此时在<code>add</code>方法里传<code>this.formData.name</code>的话就会去调用它的<code>_add</code>方法里去找）。</p>
<p>所以我们直接写一个addUser方法就好：</p>
<pre><code>    addUser() {
      const url = &quot;api/addproduct&quot;;
      $axios.post(url, { name: this.formData.name }).then(res =&gt; {
        const result = res.data;
        if (result.status === 0) {
          this._getlist();
        }
      });
</code></pre>
<p>在添加成功用户之后再执行一次<code>_getlist()</code>方法刷新页面。</p>
<h2 id="33-用户搜索">3.3 用户搜索</h2>
<p>我们首先新建一个数组来储存符合要求的用户，然后给input输入框设置双向绑定来获取当前里面的值，然后通过在总数据中使用forEach遍历，对每个数据的名字用IndexOf进行判断看是否是我们要找的数据，如果不为-1证明是我们要找的值，将它push到新数组，然后将数组的值传给表格进行渲染。</p>
<pre><code>    searchTab() {
      let newlist = [];
      this.allList.forEach(item =&gt; {
        if (item.name.indexOf(this.keywords) != -1) {
          newlist.push(item);
        }
      });
      this.tableData = newlist;
    },
</code></pre>
<p>一个和这个差不多的<a href="https://github.com/Skrupellose/manage-demo/blob/master/index.html">例子</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法题--数组(1)]]></title>
        <id>https://skrupellose.github.io/post/suan-fa-ti-shu-zu-1</id>
        <link href="https://skrupellose.github.io/post/suan-fa-ti-shu-zu-1">
        </link>
        <updated>2019-11-16T14:59:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="要求">要求：</h2>
<p>将上面的数组转换成下面数组的形式</p>
<pre><code>      [
        { name: &quot;a&quot;, hobby: &quot;football&quot; },
        { name: &quot;b&quot;, hobby: &quot;basketball&quot; },
        { name: &quot;a&quot;, hobby: &quot;swim&quot; },
        { naem: &quot;b&quot;, hobby: &quot;computer&quot; }
      ];

      [
        {name: 'a', hobby: 'football, swim'},
        {name: 'b', hobby: 'basketball, computer'}
      ]
</code></pre>
<h3 id="思路">思路：</h3>
<ol>
<li>新建一个空的新数组，使用<code>forEach</code>遍历原数组取得每一个对象</li>
<li>进行判断，若此时新数组为空，则将此遍历到的这个对象<code>push</code>到新数组；</li>
<li>若此时新数组不为空，则使用<code>findIndex()</code>方法，判断当前对象的名称在数组中是否已经存在，若存在则通过返回的索引将值<code>push</code>进对应的对象的<code>hobby</code>属性里，若不存在则将该对象<code>push</code>进新数组</li>
</ol>
<h3 id="知识点">知识点：</h3>
<p><strong>forEach()</strong><br>
<code>forEach()</code> 方法按升序为数组中含有效值的每一项执行一次<code>callback</code> 函数，那些已删除或者未初始化的项将被跳过</p>
<p><code>array.forEach(function(currentValue, index, arr), thisValue)</code></p>
<p>回调函数参数：</p>
<ul>
<li><code>currentValue</code>	必需。当前元素</li>
<li><code>index</code>  可选。当前元素的索引值。</li>
<li><code>arr</code>	 可选。当前元素所属的数组对象。</li>
</ul>
<p><strong>findIndex()</strong><br>
<code>findIndex()</code> 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。</p>
<p><code>findIndex()</code> 方法为数组中的每个元素都调用一次函数执行：</p>
<p>当数组中的元素在测试条件时返回 <code>true</code> 时, <code>findIndex()</code>返回符合条件的元素的索引位置，之后的值不会再调用执行函数。<br>
如果没有符合条件的元素返回 <code>-1</code></p>
<p><code>array.findIndex(function(currentValue, index, arr), thisValue)</code><br>
回调函数参数：</p>
<ul>
<li><code>currentValue</code> 	必需。当前元素</li>
<li><code>index</code>  可选。当前元素的索引值。</li>
<li><code>arr</code>	 可选。当前元素所属的数组对象。</li>
</ul>
<p><strong>hasOwnProperty()</strong><br>
<code>hasOwnProperty()</code>方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。</p>
<p><code>obj.hasOwnProperty(prop)</code></p>
<p>参数：</p>
<p><code>prop</code>：要检测的属性的<code>String</code>字符串形式表示的名称，或者<code>Symbol</code></p>
<h3 id="实现">实现：</h3>
<pre><code>      const arr = [

        { name: &quot;b&quot;, hobby: &quot;basketball&quot; },
        { name: &quot;a&quot;, hobby: &quot;swim&quot; },
        { name: &quot;b&quot;, hobby: &quot;computer&quot; },
        { name: &quot;a&quot;, hobby: &quot;football&quot; }
      ];
      let resArr = []
      arr.forEach((item, index) =&gt; {
        if (resArr.length) {
          const res = resArr.findIndex(_item =&gt; _item.name === item.name)
          if ((res === -1)) {
            resArr.push({
              name: item.name,
              hobby: [item.hobby]
            });
          } else {
            resArr[res][&quot;hobby&quot;].push(item.hobby)
          }
        } else {
          resArr.push({
            name: item.name,
            hobby: [item.hobby]
          })
        }
      })
      console.log(resArr) //[{name: &quot;a&quot; hobby:  [&quot;swim&quot;, &quot;football&quot;]}, {name: &quot;b&quot; hobby: [&quot;basketball&quot;, &quot;computer&quot;]}]
</code></pre>
<p>还有另一种写法，思路与上面的大同小异，只是通过<code>hasOwnProperty</code>来判断是否已有重复属性，然后用<code>findIndex()</code>来得到索引。</p>
<pre><code>      let obj1 = {};
      let objArr = [];
      const arr = [
        { name: &quot;a&quot;, hobby: &quot;football&quot; },
        { name: &quot;b&quot;, hobby: &quot;basketball&quot; },
        { name: &quot;a&quot;, hobby: &quot;swim&quot; },
        { name: &quot;b&quot;, hobby: &quot;computer&quot; }
      ];

      arr.forEach((item, index) =&gt; {
        if (obj1.hasOwnProperty(item.name)) {
          const index = objArr.findIndex(
            objArrItem =&gt; item.name === objArrItem.name
          );
          objArr[index].hobby.push(item.hobby);
        } else {
          objArr.push({
            name: item.name,
            hobby: [item.hobby]
          });
          obj1[item.name] = index;
        }
      });
      console.log(objArr); //[{name: &quot;a&quot; hobby:  [&quot;swim&quot;, &quot;football&quot;]}, {name: &quot;b&quot; hobby: [&quot;basketball&quot;, &quot;computer&quot;]}]
      console.log(obj1); //{a: 0, b: 1}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fetch和axios的上手使用]]></title>
        <id>https://skrupellose.github.io/post/fetch-he-axios-de-shang-shou-shi-yong</id>
        <link href="https://skrupellose.github.io/post/fetch-he-axios-de-shang-shou-shi-yong">
        </link>
        <updated>2019-11-14T15:41:05.000Z</updated>
        <content type="html"><![CDATA[<p>复(xue)习一下<code>fetch</code>和<code>axios</code>的用法</p>
<h1 id="一-fetch的用法">一、fetch的用法</h1>
<p>直接贴demo了</p>
<pre><code>      fetch(&quot;url&quot;).then(data =&gt; {
        return data.text().then(res =&gt; {
          console.log(res);
        });
      });
</code></pre>
<ul>
<li>要获取数据首先要调用<code>text()</code>方法或者<code>json()</code>方法</li>
<li><code>data.text()/data.json()</code>返回的是<code>promise</code>对象，用<code>.then()</code>处理之后得到的才是结果</li>
<li><code>text()</code>返回结果为字符串</li>
<li><code>json()</code>返回结果为json类型</li>
</ul>
<h2 id="11-fetch请求参数">1.1 fetch请求参数</h2>
<ul>
<li><code>method(String)</code>:http请求方法，默认为<code>GET(GET、POST、PUT、DELETE)</code></li>
<li><code>body(String)</code>:http的请求参数</li>
<li><code>header(Object)</code>:http的请求头，默认为{}</li>
</ul>
<h2 id="12-get请求">1.2 GET请求</h2>
<pre><code>
      // url传递参数
      fetch('url?id=123',{
        method: 'get'
      }).then(data =&gt; {
        return data.text()
        .then(res =&gt; {
          console.log(res);
        })
      })
      // Restful形式的url传递参数
      fetch('url/123',{
        method: 'get'
      }).then(data =&gt; {
        return data.text()
        .then(res =&gt; {
          console.log(res);
        })
      })
</code></pre>
<h2 id="13-delete请求">1.3 DELETE请求</h2>
<p>✊偷个懒 只需把<code>method</code>换成<code>delete</code>即可</p>
<h2 id="14-post请求">1.4 POST请求</h2>
<pre><code>  //传统参数传递
  fetch('url',{
    method: 'post',
    body: 'name=abc&amp;passwd=123',
    headers: {
      'Content-type': 'application/x-www-form-unlencoded',
    }//请求头必须设置否则body里的数据传不到后台去
  }).then(data =&gt; {
    return data.text()
    .then(res =&gt; {
      console.log(res);
    })
  })

  //json形式参数传递
  fetch('url',{
    method: 'post',
    body: JSON.stringify({
      name:&quot;abc&quot;,
      passwd:&quot;123&quot;
    }),
    headers: {
      'Content-type': 'application/json',
    }//请求头必须设置否则body里的数据传不到后台去
  }).then(data =&gt; {
    return data.text()
    .then(res =&gt; {
      console.log(res);
    })
  })
</code></pre>
<h2 id="15-put请求">1.5 PUT请求</h2>
<pre><code>      fetch('url/456',{
        method: 'put',
        body: JSON.stringify({
          name:&quot;abc&quot;,
          passwd:&quot;123&quot;
        }),
        headers: {
          'Content-type': 'application/json',
        }
      }).then(data =&gt; {
        return data.text()
        .then(res =&gt; {
          console.log(res);
        })
      })
      // 把put的值通过url的Restful形式传过去
</code></pre>
<h1 id="二-axios">二、axios</h1>
<h2 id="21-用法">2.1 用法</h2>
<pre><code>      axios.get('url')
      .then(res =&gt; {
        console.log(res.data)
        // 需要注意的是使用axios请求数据后.then()返回的对象除去我们想要的数据
        // 之外还有其他的数据，所以当我们需要拿到想要的数据的时候要使用data属性来获取
      })
</code></pre>
<h2 id="22-get请求">2.2 get请求</h2>
<pre><code>      // 1.通过url传递
      axios.get('url?id=123')
      .then(res =&gt; {
        console.log(res.data)
      })
      // 2.通过params属性传递
      axios.get('url',{
        params:{
          id: 123
        }
      })
      .then(res =&gt; {
        console.log(res.data)
      })

</code></pre>
<h2 id="23-delete请求">2.3 delete请求</h2>
<p>继续偷个懒，<code>delete</code>方式只需要把<code>ge</code>t换成<code>delete</code>即可</p>
<h2 id="24-post请求">2.4 post请求</h2>
<pre><code>  // 通过选项来传递参数默认传递的是json格式的数据
      axios.post('url',{
        name: &quot;yy&quot;,
        age: 16
      })//通过这种传到后台的数据是json格式
      .then(res =&gt;{
        console.log(res.data)
      })

      // 通过URLSearchParams传递参数
      const params = new URLSearchParams();
      params.append('name','abc');
      params.append('age','16');
      axios.post('url', params)
      .then(res =&gt; {
        console.log(res.data)
      })
</code></pre>
<h2 id="25-put请求">2.5 put请求</h2>
<pre><code>      axios.post('url/123',{
        name: &quot;yy&quot;,
        age: 16
      })//通过这种传到后台的数据是json格式
      .then(res =&gt;{
        console.log(res.data)
      })
</code></pre>
<h2 id="26-请求和响应拦截">2.6 请求和响应拦截</h2>
<pre><code>      // 请求拦截 发出请求数据之前进行一些配置和处理
      axios.interceptors.request.use(config =&gt;{
        ... //一些操作代码
        return config;
      })

      // 响应拦截 获取数据之前对数据进行一些处理
      axios.interceptors.response.use(res =&gt;{
        ... //一些操作代码
        return res;
      })

</code></pre>
<h2 id="27-axios响应结果">2.7 axios响应结果</h2>
<p>响应结果被包装成一个对象<br>
里面的主要属性：<br>
-<code>data</code>：实际响应回的数据<br>
-<code>headers</code>： 响应头信息</p>
<ul>
<li><code>status</code>：响应状态码</li>
<li><code>statusText</code>：响应状态信息</li>
</ul>
<h2 id="28-axios和asyncawait的联用">2.8 axios和async/await的联用</h2>
<pre><code>      async function get_(){
        let res = await axios.get('url');
        console.log(res.data)
      }
      get_() //data

      axios.get('url')
      .then(res =&gt; {
        console.log(res.data)
      })
</code></pre>
<p><code>then()</code>方法参数中的函数返回值:</p>
<ol>
<li>返回<code>promise</code>对象 返回的对象会调用下一个<code>then</code></li>
<li>返回普通值，会被直接传递给下一个<code>then()</code>的函数中充当参数</li>
</ol>
<p>或是：后面的请求需要前一个请求返回的结果作为参数，可以这么写提高代码可读性</p>
<pre><code>        async function test(){
          let res1 = await axios.get('url1')
          let res2 = await axios.get('url2?info=' + res1.data)
          return rest2
        }
        test().then(res =&gt; {
          console.log(res);
        })
</code></pre>
<p>补充：我们还可以新建一个<code>axios</code>实例对象来进行一些配置</p>
<pre><code>const $axios = axios.create({
  // 设置超时时间
  timeout: 30000,
  // 基础url，会在请求url中自动添加前置链接
  baseURL: &quot;url&quot;
});
</code></pre>
<p>这样我们在后面使用<code>axios</code>发送请求的时候就不用写那么长的url了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深浅拷贝小总结]]></title>
        <id>https://skrupellose.github.io/post/shen-qian-kao-bei-xiao-zong-jie</id>
        <link href="https://skrupellose.github.io/post/shen-qian-kao-bei-xiao-zong-jie">
        </link>
        <updated>2019-11-12T14:28:29.000Z</updated>
        <content type="html"><![CDATA[<p>👻 拷贝就是复制一份一样的东西出来，浅拷贝简单理解就是通过复制之后，和原件还有关系，彼此的改变会影响到彼此，而深拷贝复制出来后与原件互不相干涉。</p>
<h1 id="一-数据类型介绍">一、数据类型介绍</h1>
<p><code>JavaScript</code>的数据类型分为基本数据类型和引用数据类型。基本数据类型有：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Undefined</li>
<li>Null</li>
<li>Symbol</li>
</ul>
<p>它们都储存在栈内存中<br>
然后是引用数据类型：</p>
<ul>
<li>Array</li>
<li>Object</li>
</ul>
<p>这两个保存在堆内存中，但是在栈内存中保留了引用</p>
<h1 id="二-关于基本数据类型的拷贝">二、关于基本数据类型的拷贝</h1>
<p>基本数据类型的拷贝直接新建一个变量赋值就完事，它只有深拷贝，不那么让人困惑：</p>
<pre><code>let a = 1;
let b = a;
a = 2 ;
console.log(b)  // 1
</code></pre>
<p>b是从a拷贝来的，但是a的重新赋值并没有影响到b，所以是深拷贝。</p>
<h1 id="三-关于引用数据类型的拷贝">三、关于引用数据类型的拷贝</h1>
<h2 id="31-引用数据类型的浅拷贝">3.1 引用数据类型的浅拷贝</h2>
<pre><code>const oriArray = [1,2,3];
const oriObj = {a:'a',b:'b',c:[1,2,3],d:{d:'d'}};

const cloneArray = oriArray;
const cloneObj = oriObj;

console.log(oriArray) //[1,2,3]
console.log(oriObj) //{a:'a',b:'b',c:[1,2,3],d:{d:'d'}}

cloneArray.push(4);
cloneObj.a = 'A';

console.log(oriArray) //[1,2,3,4]
console.log(oriObj) //{a:'A',b:'b',c:[1,2,3],d:{d:'d'}}
</code></pre>
<p>通过赋值方式拷贝引用数据类型的时候，发现操作克隆值会影响到原来的值，这就是浅拷贝</p>
<h2 id="32-引用数据类型的深拷贝">3.2 引用数据类型的深拷贝</h2>
<p>目前实现深拷贝的方法不多，主要是两种：</p>
<ol>
<li>利用 <code>JSON</code>对象中的<code>parse</code> 和 <code>stringify</code></li>
<li>利用递归来实现每一层都重新创建对象并赋值</li>
</ol>
<p>首先是第一种：</p>
<ul>
<li><code>JSON.stringify</code> 是将一个<code>JavaScript</code> 值转成一个 <code>JSON</code>字符串。</li>
<li><code>JSON.parse</code> 是将一个<code>JSON</code>字符串转成一个 <code>JavaScript</code> 值或对象。</li>
</ul>
<pre><code>const oriArray = [1,2,3];
const cloneArray = JSON.parse(JSON.stringify(oriArray));
console.log(cloneArray) //[1,2,3]
console.log(cloneObj === originObj); // false 只是看起来一样
cloneArray.push(4)
console.log(cloneArray) //[1,2,3,4]
console.log(oriArray) //[1,2,3]
</code></pre>
<pre><code>const oriObj = {a:'a',b:[1,2,3],c:{c:'c'}};
const cloneObj = JSON.parse(JSON.stringify(oriObj));
console.log(cloneObj); //{a:'a',b:[1,2,3],c:{c:'c'}}
console.log(cloneObj === oriObj) //fasle 
cloneObj.b.push(4); 
console.log(cloneObj); //{a:'a',b:[1,2,3,4],c:{c:'c'}}
console.log(oriObj) //{a:'a',b:[1,2,3],c:{c:'c'}}
</code></pre>
<p>我们发现的确是深拷贝，没有彼此影响<br>
但是这种方法有个弊端，那就是当引用数据类型内部有<code>undefined</code>、<code>function</code>、<code>symbol</code>它们会在转换过程中被忽略。</p>
<pre><code>const oriObj = {
  name:'学习',
  fn:function(){
    console.log('Hello World');
  },
  a:undefined,
  b:Symbol
}
console.log(oriObj); //{name: &quot;学习&quot;, a: undefined, fn: ƒ(), b: ƒ Symbol()}
const cloneObj = JSON.parse(JSON.stringify(oriObj));
console.log(cloneObj); //{name: &quot;学习&quot;}
</code></pre>
<p>是的，转换完就只剩学习了👏。<br>
我的心里只有一件事那就是学习！！!<br>
所以这种方法有一定的局限，但还是很好用的!</p>
<p>第二种：递归</p>
<p>递归的思想就很简单了，就是对每一层的数据都实现一次 <code>创建对象-&gt;对象赋值</code> 的操作</p>
<pre><code>function deepClone(source){
  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象
  for(let keys in source){ // 遍历目标
    if(source.hasOwnProperty(keys)){
      if(source[keys] &amp;&amp; typeof source[keys] === 'object'){ // 如果值是对象，就递归一下
        targetObj[keys] = source[keys].constructor === Array ? [] : {};
        targetObj[keys] = deepClone(source[keys]);
      }else{ // 如果不是，就直接赋值
        targetObj[keys] = source[keys];
      }
    } 
  }
  return targetObj;
}
</code></pre>
<p>我们实验一下：</p>
<pre><code>const oriObj = {
  name:'学习',
  study: {emm:'emmm'},
  fn:function(){
    console.log('Hello World');
  },
  a:undefined,
  b:Symbol
}
let res = deepClone(oriObj)

console.log(oriObj); //{name: &quot;学习&quot;, study: {emm:'emmm'}, a: undefined, fn: ƒ, b: ƒ}
console.log(res) //{name: &quot;学习&quot;, study: {emm:'emmm'}, a: undefined, fn: ƒ, b: ƒ}
console.log(oriObj === res) //false
</code></pre>
<p>不但解决了拷贝问题，还解决了第一种方法的小瑕疵。👍</p>
<h1 id="四-首层深拷贝的几个方法">四、首层深拷贝的几个方法</h1>
<p><strong>首层深拷贝</strong>是指对于多层嵌套的引用类型数据只对深拷贝首层数据,更深层的数据还是浅拷贝</p>
<p><strong>数组</strong><br>
<code>concat</code> 和 <code>slice</code> 是可以实现对原数组的拷贝的，这两个方法都不会修改原数组，而是返回一个修改后的新数组</p>
<pre><code>const originArray = [1,2,3];
const cloneArray = originArray.concat();

console.log(cloneArray === originArray); // false
cloneArray.push(4); // [1,2,3]
console.log(originArray); //[1,2,3];
</code></pre>
<pre><code>const originArray = [1,2,3];
const cloneArray = originArray.slice(0);

console.log(cloneArray === originArray); // false
cloneArray.push(4); // [1,2,3]
console.log(originArray); //[1,2,3];
</code></pre>
<p>以及我们的展开运算符：<code>...</code></p>
<pre><code>const originArray = [1,2,3];
const cloneArray = [...originArray];

console.log(cloneArray === originArray); // false
cloneArray.push(4); // [1,2,3]
console.log(originArray); //[1,2,3];
</code></pre>
<p><strong>对象</strong><br>
<code>Object.assign()</code>方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。</p>
<pre><code>let obj1 = { a: 0 , b: { c: 0}}
let obj2 = Object.assign({}, obj1)
console.log(JSON.stringify(obj2))
// {&quot;a&quot;:0,&quot;b&quot;:{&quot;c&quot;:0}}
obj1.a = 1
console.log(JSON.stringify(obj1))
// {&quot;a&quot;:1,&quot;b&quot;:{&quot;c&quot;:0}}
console.log(JSON.stringify(obj2))
// {&quot;a&quot;:0,&quot;b&quot;:{&quot;c&quot;:0}}
</code></pre>
<p>这些都只能实现首层深拷贝的方法，虽然功能有限但在合适的场合用起来会事半功倍。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优雅的使用async和await]]></title>
        <id>https://skrupellose.github.io/post/you-ya-de-shi-yong-async-he-await</id>
        <link href="https://skrupellose.github.io/post/you-ya-de-shi-yong-async-he-await">
        </link>
        <updated>2019-11-11T15:09:55.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="简单介绍一下两个语法的使用">😏简单介绍一下两个语法的使用</h2>
]]></summary>
        <content type="html"><![CDATA[<h2 id="简单介绍一下两个语法的使用">😏简单介绍一下两个语法的使用</h2>
<!-- more -->
<h1 id="一-优雅的介绍一下async和await">一、优雅的介绍一下async和await</h1>
<p><code>async</code> 函数是什么？一句话，它就是 <code>Generator</code> 函数的语法糖。<br>
<code>async</code>函数就是将 <code>Generator</code> 函数的星号<code>（*）</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>
<pre><code>                                                                    ————阮一峰
</code></pre>
<p>阮大佬的入门教程如是说道，那么我们就大概知道了<code>async/await</code>也是用来实现异步编程的方式。</p>
<h1 id="二-上demo冲">二、上demo，冲！</h1>
<p>在 <code>function</code> 前面加 <code>async</code> 用来说明这个函数是一个异步函数<br>
不多说代码安排上：</p>
<pre><code>      let sayHi = async () =&gt; {
        console.log('hello,飞飞鱼');
      }
      sayHi();
      console.log('hello,丁丁车');
</code></pre>
<p>看下控制台的打印：</p>
<figure data-type="image" tabindex="1"><img src="https://skrupellose.github.io/post-images/1573486162022.png" alt=""></figure>
<p>emm？👀这不还是同步吗？<br>
再去看看，<code>async</code>函数返回的是一个<code>promise</code> 对象，喔，懂了！</p>
<pre><code>      let sayHi = async () =&gt; {
        return 'hello,飞飞鱼';
      }
      sayHi()
      console.log('hello,丁丁车');
</code></pre>
<p>打开命运石之门：</p>
<p><img src="https://skrupellose.github.io/post-images/1573486464645.png" alt=""><br>
这一切都是命运石之门的选择。</p>
<p>好吧，为什么没有打印出来呢？我们把函数<code>sayHi</code>执行结果打印一下：</p>
<pre><code>      let sayHi = async () =&gt; {
        return 'hello,飞飞鱼';
      }
      console.log(sayHi());
      console.log('hello,丁丁车');
</code></pre>
<p><img src="https://skrupellose.github.io/post-images/1573486614613.png" alt=""><br>
额， 忘了返回的是<code>promise对象</code>，那我们直接<code>.then()</code>取值。</p>
<pre><code>      let sayHi = async () =&gt; {
       return 'hello,飞飞鱼';
      }
      sayHi().then(res =&gt; console.log(res));
      console.log('hello,丁丁车');
</code></pre>
<p><img src="https://skrupellose.github.io/post-images/1573486806717.png" alt=""><br>
秒啊！我们发现了的确先打印的<code>hello,丁丁车</code>,然后打印的<code>hello,飞飞鱼</code>，证明sayHi的确是异步函数。</p>
<h1 id="三-await和async">三、await和async</h1>
<p><code>await</code>后面可以放任何表达式，不过我们更多的是放一个返回<code>promise</code>对象的表达式。注意<code>await</code> 关键字只能放到<code>async</code>函数里面</p>
<pre><code>      let delay = word =&gt; {
        return new Promise((resolve, reject) =&gt; {
          setTimeout(() =&gt; {
            resolve(word)
          },2000);
        })
      }
</code></pre>
<p>先写个2s后执行的<code>delay</code>函数返回一个<code>promise</code>对象，然后再写一个异步函数来调用它</p>
<pre><code>      let show = async () =&gt; {
        let res1 = await delay('I');
        console.log(res1);
      }
      show()
</code></pre>
<p>然后我们发现2s后的确打印了：<br>
<img src="https://skrupellose.github.io/post-images/1573487475797.png" alt=""><br>
那么我们继续添加，尝试用优雅的写法</p>
<pre><code>      let show = async () =&gt; {
        let res1 = await delay(&quot;I&quot;);
        let res2 = await delay(&quot;love&quot;);
        let res3 = await delay(&quot;YOU&quot;);
        console.log(res1 + &quot; &quot; + res2 + &quot; &quot; + res3);
      };
      show();
</code></pre>
<p>然后6s后，打印出了：<br>
<img src="https://skrupellose.github.io/post-images/1573487604909.png" alt=""></p>
<p>秒啊，用优雅的同步写法完成了异步操作。<br>
这里运行的步骤是<code>show</code>函数执行，然后发现了<code>await</code>，它等待第一次<code>promise</code>对象执行完毕，拿到<code>promise resolve</code>的值并进行返回,然后继续向下执行，又发现<code>await</code>，又开始等待，然后重复，最后在6s之后成功完成打印。</p>
<p>2019-11-14 补充：</p>
<pre><code>async function f() {
return await 123;
}

f().then(v =&gt; console.log(v))
// 123
</code></pre>
<p>这里打印123的原因：<br>
1.因为f函数return了一个由await生成的Promise对象，这个对象取代了f函数自己形成的Promise，所以最后通过then()方法返回的是123而不是Promise对象（await参数为123，它被转成Promise对象，它被立即resolve）</p>
<p>正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[v-bind的两三事]]></title>
        <id>https://skrupellose.github.io/post/v-bind-de-liang-san-shi</id>
        <link href="https://skrupellose.github.io/post/v-bind-de-liang-san-shi">
        </link>
        <updated>2019-11-09T06:53:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于-v-bind-的两三事">关于 v-bind 的两三事</h1>
<h2 id="一-前言">一、前言</h2>
<p>在之前学习前端的过程中经常是碎片式的学习，没有形成一个知识系统，正好在实习中再次接触到<code>vue.js</code>，结合之前的学习和工作中的使用做一个总结，巩固一下知识点。</p>
<h2 id="二-关于-v-bind">二、关于 v-bind</h2>
<p>在 vue.js 官方教程中介绍<code>v-bind</code>指令可以绑定元素特性</p>
<p>我们上个例子：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;span v-bind:title=&quot;message&quot;&gt;
    鼠标放到这里哟~
  &lt;/span&gt;
&lt;/div&gt;

...

var vm = new Vue({
  el: &quot;#app&quot;,
  data: {
     message: &quot;鼠标移到我身上你就可以看到我&quot;
  }
});
</code></pre>
<p>打开浏览器我们发现：<br>
<img src="https://skrupellose.github.io/post-images/1573283056492.png" alt=""></p>
<p><code>&lt;span&gt;</code>标签的<code>title</code>属性有了<code>message值</code></p>
<p>这个 <code>title</code>属性规定关于元素的额外信息。</p>
<p>这些信息通常会在鼠标移到元素上时显示一段工具提示文本,如上面的例子。</p>
<p>打开控制台：<br>
<img src="https://skrupellose.github.io/post-images/1573283243201.png" alt=""><br>
我们发现的确如此。</p>
<h2 id="三-指令预期值">三、指令预期值</h2>
<p>初步了解了<code>v-bind</code>之后，我们继续来看关于指令，vue官方将</p>
<p><code>v-bind:title=&quot;message&quot;</code></p>
<p>分为三部分：</p>
<ol>
<li><code>v-bind</code> 这个称之为指令</li>
<li><code>：</code>后面的<code>title</code> 这个被称为属性</li>
<li><code>message</code> 则被成为‘预期值’</li>
</ol>
<p><code>title</code>除了跟上面例子一样是字符串类型变量外，也可以是一个<code>单一js表达式</code></p>
<p>故属性可以有以下操作：</p>
<p>(1)执行运算</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=&quot;m1 + ' ' + m2&quot;&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;
    ...
    var vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          m1: 'hello',
          m2: 'vue.js'
        }
      });

</code></pre>
<p>查看效果：<br>
<img src="https://skrupellose.github.io/post-images/1573283256464.png" alt=""></p>
<p>(2)执行函数</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=&quot;show()&quot;&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;
    ...
    var vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          show(){
            return 'hello fn'
          }
        }
      });
</code></pre>
<p><img src="https://skrupellose.github.io/post-images/1573283285683.png" alt=""><br>
同样的也成功了</p>
<h2 id="四-预期值支持的数据类型">四、预期值支持的数据类型</h2>
<p>我们发现刚才我们预期值传入的都是字符串类型的数据，那么如果传入其他数据类型的会怎么样呢？</p>
<p>那么我们来尝试一下：</p>
<p>(1) 对象</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=obj&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;
......
    var obj = {};
    var vm = new Vue({
      el: '#app',
      data: {
        obj: obj
      }
    });
</code></pre>
<p>打开控制台：<br>
<img src="https://skrupellose.github.io/post-images/1573283298341.png" alt=""><br>
我们发现了<code>title=&quot;[object Object]&quot;</code>,这个熟悉的字符串让人想起了对象的 <code>toString</code> 方法的返回值。那么我们继续测试：</p>
<p>因为我们创建的对象还没有<code>toString()</code>方法，所以我们给它添加一个，这样它就不用顺着原型链去找了</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=&quot;obj&quot;&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;

    ...
    
      var obj = {};
      obj.toString = function() {
        return &quot;调用了toString()!&quot;;
      };
      var vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          obj: obj
        }
      });
</code></pre>
<p><img src="https://skrupellose.github.io/post-images/1573283314809.png" alt=""><br>
果然如此，调用了<code>toString()</code>方法。</p>
<p>(2) 数组<br>
接着我们测试数组<br>
数组类型的 <code>toString</code>方法和对象类型的有所不同，它将执行并返回给我们 <code>arr.join(',')</code> 相同的结果。如 <code>[1, 2, 3].toString()</code> 将返回 <code>'1,2,3'</code>。下面进行测试：</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=&quot;arr&quot;&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;
   ...
      var arr= [1, 2, 3];
      var vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          arr: arr
        }
      });
</code></pre>
<p>结果如下：<br>
<img src="https://skrupellose.github.io/post-images/1573283327009.png" alt=""><br>
和我们的最初设想一致</p>
<p>(3)其余类型</p>
<ul>
<li>number 类型，正常执行 toString，包括数字0，结果都正常渲染成对应的字符串；</li>
<li>boolean 类型，true 正常渲染成字符串 &quot;true&quot;，但 false 虽然执行 toString 方法将返回 &quot;false&quot; 字符串，但是却没有渲染出来；</li>
<li>null / undefined 类型，二者没有 toString 方法，也没有渲染出来。<br>
显然，在执行 toString 方法之前，vue 内部应该先做了类型校验，满足条件才输出。而且这里不是简单的真 / 假值校验，因为 0 虽为假值，但最终却像真值一样渲染了出来。</li>
</ul>
<h2 id="五-其他操作">五、其他操作</h2>
<p>之前我们发现了预期值传入的是其他数据类型时会执行<code>toString</code>方法,那么当我们想给属性来添加多个值的时候就可以通过对象或者数组来传值了。<br>
比如我们给<code>P标签</code>来增添<code>多个css</code>样式，就可以这么来添加。</p>
<p>说到这里不得不提一下<code>vue</code>对<code>style</code>以及<code>class</code>属性的增强，比如如果我们给p标签的title属性绑定obj，那么最后会执行toString方法返回一个<code>&quot;[object Object]&quot;</code>，但是当绑定的是<code>style</code>以及<code>class</code>的时候，它会自动进行解析。</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p v-bind:title=&quot;obj&quot;&gt;content&lt;/p&gt;
&lt;/div&gt;
...
var obj = {
    color: 'red',
    fontSize: '20px',
};

渲染后的结果为：
&lt;div id=&quot;app&quot;&gt;
    &lt;p title=&quot;[object Object]&quot;&gt;content&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>但是如果是style属性：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p v-bind:style=&quot;obj&quot;&gt;content&lt;/p&gt;
&lt;/div&gt;
...
var obj = {
    color: 'red',
    fontSize: '20px',
};

渲染后的结果为：
&lt;div id=&quot;app&quot;&gt;
    &lt;p style=&quot;color: red; font-size: 20px;&quot;&gt;content&lt;/p&gt;
&lt;/div&gt;

</code></pre>
<p>这是因为vue内部对这两个属性进行了处理：<br>
只论最后结果的话，下面这种方法可以实现将对象转换成行内css样式所需要的格式<br>
具体实现后面还是要看源码。</p>
<pre><code>obj.toString = function () {
    var str = '';
    for(var i in this) {
        if(this[i]) {
            str += i + ':' + this[i] + ';';
        }
    }

    return str;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript之函数预编译]]></title>
        <id>https://skrupellose.github.io/post/javascript-zhi-han-shu-yu-bian-yi</id>
        <link href="https://skrupellose.github.io/post/javascript-zhi-han-shu-yu-bian-yi">
        </link>
        <updated>2019-11-09T04:25:45.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="js执行三部曲语法分析-预编译-解释执行">JS执行三部曲：<strong>语法分析</strong> <strong>预编译</strong> <strong>解释执行</strong></h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="js执行三部曲语法分析-预编译-解释执行">JS执行三部曲：<strong>语法分析</strong> <strong>预编译</strong> <strong>解释执行</strong></h1>
<!-- more -->
<p><strong>语法分析</strong>：简单来说就是浏览器先不运行代码，而是检查你代码是否有语法错误比如少加了符号啊，写入了中文字符等等操作。类似于老师检查你的作文，先不看你的内容怎么样，而是看有没有错别字。(啊哈哈，只是类比一下，好像有点不恰当，老师一般是直接一遍看过去)<br>
<strong>预编译</strong>：<br>
预编译有两个抽象出来的知识点：</p>
<ul>
<li>函数声明整体提升</li>
<li>变量 声明提升</li>
</ul>
<p><strong>函数声明整体提升</strong>指的是当你使用了函数声明，那么函数声明默认会提升至script顶部</p>
<pre><code>	function up(){
          console.log(&quot;hello,world&quot;);
        }
       up();
       //打印hello,world

       up();
       //也能打印出hello,world
	 	function up(){
          console.log(&quot;hello,world&quot;);
        }
    
</code></pre>
<p>这就是说<code>function up(){ console.log(&quot;hello,world&quot;); }</code>这个函数被默认提升到顶部，所以第二种方法执行函数的时候没有报错并且成功了。</p>
<p><strong>变量 声明提升</strong>指的是变量在声明的时候，也会被提升至逻辑的顶端。</p>
<pre><code>var a;
//这个叫做变量声明
var a = 1;
//这个叫做变量初始化 它相当于变量声明加变量赋值的双重操作
//即var a; a = 1;
</code></pre>
<p>我们需要注意的是提升的只有变量声明，也就是说：</p>
<pre><code>console.log(a);
var a = 123;
//这里打印的是undefined而不是123
</code></pre>
<p>上面的操作拆解一下应该是这样：</p>
<pre><code>var a；
console.log(a);
 a = 123;
//这里相当于只声明了变量a但是没有进行赋值，所以打印的是undefined
</code></pre>
<p>但是我们遇到声明的变量为a，声明的函数名也为a，那我们打印的a的时候打印的是哪一个呢？因为两者都有提升，哪一个更加优先呢？</p>
<pre><code>	console.log(a);
		//a(){}
        function a(){
        }
        var a;
</code></pre>
<p>我们发现打印的是函数体a，但是这有可能是因为函数声明写在变量声明之前，那么我们颠倒一下顺序试一试：</p>
<pre><code> 	console.log(a);
 		//a(){}
        var a = 123;
        function a(){
        }
</code></pre>
<p>我们发现结果没有变，还是打印的函数a，那么这个原理是什么呢？我们需要更深的去了解JS预编译的过程。</p>
<p>这里我们先了解两个知识点：</p>
<ol>
<li>imply global 暗示全局变量：即任何变量未经声明就赋值，那么这个变量就为全局对象所有。全局变量指的是window</li>
</ol>
<pre><code>	 a = 123;
        console.log(a);
        //123
        console.log(window.a);
        //123

</code></pre>
<pre><code>	var a = b = 123;
        console.log(window.a);
        //123
        console.log(window.b);
        //123
</code></pre>
<p>这里b变量未经声明就赋值所以变成了window的属性，但是a声明了为什么也变成了window的属性呢？这是因为下面一条规则<br>
2. 一切声明的全局变量全部变为window的属性<br>
上面代码的a是全局声明的，所以它也变成了window的属性。</p>
<pre><code>      
&lt;!-- more --&gt;
 function go(){
         var a = b =123;
       }
       go();
       console.log(window.a);
       //undefined
       console.log(window.b);
       //123


</code></pre>
<p>而当我们在<strong>函数内部</strong>声明变量的时候 它就<strong>不是</strong>全局变量了，它变成了<strong>局部变量</strong>，就不满足第二条规则了，所以打印window.a的时候，结果显示的是undefined，而b还是未声明就赋值，所以它还是一个全局变量，因此打印了出来。</p>
<p>我们继续讲回预编译：<br>
<strong>预编译，它发生在函数执行的前一刻</strong>，它有以下几个环节：</p>
<ol>
<li>创建AO对象 Activation Object（执行期上下文）</li>
<li>找形参和变量声明，将变量和形参名作为AO对象的属性名，值为undefined</li>
<li>将实参形参相统一</li>
<li>在函数体里找到函数声明，把函数声明当做值赋予函数体<br>
让我们根据一个例子操作一下：</li>
</ol>
<pre><code>     function test(a) {
        console.log(a);
        console.log(b); 
        var b = 234;
        console.log(b); 
        a = 123;
        console.log(a);
        function a() {};
        var a;
        b = 234;
        var b = function() {};
        console.log(a); 
        console.log(b); 
        function d() {};
      }
      test(1);
</code></pre>
<ol>
<li>创建AO对象</li>
</ol>
<pre><code>AO{
}
</code></pre>
<ol start="2">
<li>找形参和变量声明，将变量和形参名作为AO对象的属性名，值为undefined</li>
</ol>
<p>我们首先寻找形参，发现函数的形参有a同时变量名它也有a我们只需要保留一个就行了,然后赋值undefined。</p>
<pre><code>AO{
	a : undefined,
	b : undefined,
}
</code></pre>
<ol start="3">
<li>将实参形参相统一<br>
test(1)传的值是1</li>
</ol>
<pre><code>AO{
	a : 1,
	b : undefined,
}
</code></pre>
<p>4.在函数体里找到函数声明，把函数声明当做值赋予函数体。关于函数体，比如:</p>
<pre><code>  function test() {
        console.log(&quot;hello&quot;);
      }
      test();
      console.log(test);
      // function test() {
        console.log(&quot;hello&quot;);
      }
</code></pre>
<p>这里我们打印test，输出的是test这整个函数，test就指代着函数体。<br>
这里我们还需要注意的是 <code>function fn(){}</code>这种形式才叫做<strong>函数声明</strong>，而<code>var fn = function(){}</code>j叫做<strong>函数表达式</strong></p>
<pre><code>AO{
	a : function a (){},
	b : undefined,
	d : function d (){},
}
</code></pre>
<p>然后我们就得到了该函数完整的执行期上下文，然后以此为基础我们开始重新赋值</p>
<pre><code>    function test(a) {
        console.log(a); 1
        console.log(b); 2
        var b = 234;
        console.log(b);  3
        a = 123;
        console.log(a);  4
        function a() {};
        var a;
        b = 234;
        var b = function() {};
        console.log(a);  5
        console.log(b);  6
        function d() {};
      }
      test(1);
</code></pre>
<ol>
<li>第一个打印的a根据AO对象我们知道应该是<code>function a (){}</code></li>
<li>第一个打印的b我们根据AO对象知道应该是<code>undefined</code></li>
<li>第二个打印的b我们这里要注意一下，因为上面有一句赋值语句：<code>var b = 234;</code>，所以这个时候打印的b变成了<code>234</code></li>
<li>同理，第二个打印的a因为上面又进行了赋值，所以变成了<code>123</code></li>
<li>第三个打印的a并没有重新赋值，所以还是<code>123</code></li>
<li>第三个打印的b因为上面将函数体赋给了它，所以它变成了<code>function (){}</code></li>
</ol>
<p>好的，完成了！<br>
那么接下来我们解决刚才的那个问题</p>
<pre><code>	console.log(a);
		//a(){}
        function a(){
        }
        var a;
</code></pre>
<p>按照步骤首先创建AO对象</p>
<pre><code>AO{
}
</code></pre>
<p>然后寻找形参和变量声明并赋值undefined</p>
<pre><code>AO{
a : undefined
}
</code></pre>
<p>接着将实参形参相统一</p>
<p>最后在函数体里找到函数声明，把函数声明当做值赋予函数体</p>
<pre><code>AO{
a : function a (){}
}
</code></pre>
<p>然后打印a，所以最后的结果是 <code>function a (){}</code><br>
这个其实应该用全局的预编译，具体环节和函数预编译差不多，只是我们发现好像第三步形参实参相统一多余了，所以我们<strong>全局预编译</strong>只有三步：</p>
<ol>
<li>创建我们全局的执行上下文叫GO对象即（Global Object）</li>
<li>找变量声明，将变量名作为GO对象的属性名，值为undefined</li>
<li>最后在函数体里找到函数声明，把函数声明当做值赋予函数体<br>
<strong>我们的GO先于AO生成，并且首先元素查找AO，若AO没有则去GO查找</strong><br>
用上面一个例子</li>
</ol>
<pre><code>function go(){
         var a = b =123;
       }
       go();
       console.log(window.a);
       //undefined
       console.log(window.b);
       //123
</code></pre>
<p>首先 ，我们应该先创建GO对象，由于b是一个全局变量所以创建GO对象的时候我们对其进行了初始化的操作最后等于123，因此我们在AO找不到b的时候去GO中寻找，最终打印出了结果。而a在AO对象中，且被赋值为undefined，所以最终输出也为undefined。<br>
<strong>解释执行</strong>：预编译结束之后，就是我们浏览器的解释执行了。</p>
]]></content>
    </entry>
</feed>