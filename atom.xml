<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skrupellose.github.io</id>
    <title>D.C </title>
    <updated>2020-04-10T14:16:09.241Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skrupellose.github.io"/>
    <link rel="self" href="https://skrupellose.github.io/atom.xml"/>
    <subtitle>人类世界真是太有趣了</subtitle>
    <logo>https://skrupellose.github.io/images/avatar.png</logo>
    <icon>https://skrupellose.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, D.C </rights>
    <entry>
        <title type="html"><![CDATA[http]]></title>
        <id>https://skrupellose.github.io/post/http/</id>
        <link href="https://skrupellose.github.io/post/http/">
        </link>
        <updated>2020-04-01T11:28:39.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React学习笔记]]></title>
        <id>https://skrupellose.github.io/post/react-xue-xi-bi-ji/</id>
        <link href="https://skrupellose.github.io/post/react-xue-xi-bi-ji/">
        </link>
        <updated>2020-03-09T02:30:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="yi">yi</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB笔记]]></title>
        <id>https://skrupellose.github.io/post/mongodb-bi-ji/</id>
        <link href="https://skrupellose.github.io/post/mongodb-bi-ji/">
        </link>
        <updated>2020-03-04T09:54:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-关于mongodb">一、 关于MongoDB</h1>
<p>MongoDB是一个面向文档的数据库管理系统，用C++语言编写。</p>
<h1 id="二-简单上手使用">二、简单上手使用</h1>
<h2 id="21-下载安装">2.1 下载安装</h2>
<p><a href="https://www.mongodb.com/">官网</a><br>
然后正常安装</p>
<h2 id="22-软件使用">2.2 软件使用</h2>
<ol>
<li>
<p>选一个磁盘来存储数据<br>
比如想在D盘存储数据，那么我们就需要在D盘下新建一个<code>data</code>文件夹，再在其中新建<code>db</code>文件夹，这样我们后面数据库的数据就会被保存在<code>db</code>文件夹</p>
</li>
<li>
<p>启动MongoDB<br>
打开CMD，切换到D盘，执行<code>mongod</code>启动命令，然后最小化。</p>
</li>
<li>
<p>操作数据库<br>
输入<code>mongo</code>就可以进行数据库的相关操作</p>
<h2 id="23-一些基本命令">2.3 一些基本命令</h2>
<ol>
<li>切换/创建数据库<br>
<code>use DBname</code></li>
<li>删除当前数据库<br>
<code>db.dropDatabase()</code></li>
<li>查询数据库<br>
<code>show dbs</code></li>
<li>得到当前数据库所有集合<br>
<code>db.getCollectionNames();</code></li>
<li>集合查询所有记录<br>
<code>db.collectionname.find()</code></li>
</ol>
</li>
</ol>
<h2 id="24-node操作mongodb">2.4 Node操作MongoDB</h2>
<pre><code>var mongoose = require ('mongoose')
var Schema = mongoose.Schema

mongoose.connect('mongodb://localhost/dbName',{ useNewUrlParser: true })

var userSchema = new Schema({
  username: {
    type: String,
    required: true
  },
  password: {
    type: String,
    required: true
  }
})

var User = mongoose.model('User', userSchema)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise与相关题型]]></title>
        <id>https://skrupellose.github.io/post/promise/</id>
        <link href="https://skrupellose.github.io/post/promise/">
        </link>
        <updated>2020-03-04T03:31:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-promise">一、Promise</h1>
<h2 id="11-promise概念">1.1 Promise概念</h2>
<h3 id="111-关于promise">1.1.1 关于Promise</h3>
<p>Promise是es6新增的一个API，它本身不是异步的，但是它内部进行封装的往往是异步任务。</p>
<p>Promise容器最开始的状态是<code>Pending</code>，它最后会根据内部任务的成功与否改为<code>Resolved</code>（成功）和<code>Rejected</code>（失败），且不会再次改变状态</p>
<p><strong>Promise容器一旦创建，就开始执行里面的代码</strong></p>
<pre><code>var fs = require('fs')
new Promise(function () {
  fs.readFile('./a.txt','utf8',function(err, data){
    if(err) {
      console.log(err)
    }
    console.log(data)
  })
})
// 就会立马打印出a.txt的内容出来
</code></pre>
<h3 id="112-promise基础语法">1.1.2 Promise基础语法</h3>
<pre><code>var p1 = new Promise(function(resolve, reject) {
  fs.readFile('./a.txt','utf8',function(err, data) {
    if(err) {
      reject(err)
    }
    resolve(data)
  })
})
p1.then(function(data){
  console.log(data)
},function(err){
  console.log(err)
})
</code></pre>
<p>还是刚才的例子我们通过<code>Promise</code>构造函数构造了一个名为p1的<code>Promise</code>实例：<br>
然后在<code>Promise</code>构造函数中传了两个函数作为参数，一个是<code>resolve</code>；一个是<code>reject</code>。<br>
之后在fs.readFile执行后，根据执行结果分别执行<code>reject</code>和<code>resolve</code>方法。<br>
我们想要拿到结果就需要通过构造出的<code>Promise</code>实例的<code>then</code>方法。<br>
<code>then</code>方法也是接受两个函数作为形参，第一个是对应成功时执行；第二个是对应失败后执行。两个方法分别对应上面的<code>resolve</code>和<code>reject</code>。</p>
<p>关于then方法的链式调用需要介绍：<br>
当then方法执行完之后return一个对象，我们就可以对这个对象进行处理，当我们面对回调嵌套的时候就可以使用Promise。</p>
<pre><code>p1.then(function(data){
  console.log(data)
  return p2
}).then(function(data) {
  console.log(data)
  return p3
}).then(function(data){
  console.log(data)
})
</code></pre>
<p>then方法的第一个形参就是调用then方法的实例的resolve方法。<br>
如果return的是一个简单数据类型，那么充当then方法的形参的那个方法就能获取的这个值。</p>
<h1 id="二-promise基础题型">二、promise基础题型</h1>
<h2 id="21-题目1">2.1 题目1</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  console.log(2);
});
promise.then(() =&gt; {
  console.log(3);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li>结果并不是<code>1 2 4 3</code></li>
<li>虽然promise.then属于微任务，但是前面新建的promise对象过程中并没有改变状态。因此promise.then并不会执行</li>
<li>所以执行结果为<code>1 2 4</code></li>
</ul>
<h2 id="22-题目2">2.2 题目2</h2>
<pre><code>const promise1 = newPromise((resolve, reject) =&gt; {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res =&gt; {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);
</code></pre>
<p>tips：</p>
<ul>
<li>第一轮宏任务首先执行<code>promise1</code></li>
<li>然后将<code>promise1</code>的状态修改为<code>resolved</code>，然后保存结果</li>
<li>把<code>promise2</code>放入微任务队列，等待执行</li>
<li>接着执行同步代码1，结果为<code>resolved</code></li>
<li>然后执行同步代码2，结果为<code>pending</code>，因为此时<code>promise2</code>被放入微任务队列还没执行，promise状态为<code>pending</code><br>
所以结果为:</li>
</ul>
<pre><code>'promise1'
'1' Promise{&lt;resolved&gt;: 'resolve1'}
'2' Promise{&lt;pending&gt;}
'resolve1'
</code></pre>
<h2 id="23-题目3">2.3 题目3</h2>
<pre><code>const fn = () =&gt;(new Promise((resolve, reject) =&gt; {
  console.log(1);
  resolve('success')
}))
fn().then(res =&gt; {
  console.log(res)
})
console.log('start')
</code></pre>
<p>tips：</p>
<ul>
<li>首先执行<code>fn</code>函数，它返回一个promise对象，并且将状态修改为<code>resolved</code>，因此首先打印1</li>
<li>然后将<code>.then()</code>放入微任务队列</li>
<li>接着执行同步任务打印<code>start</code></li>
<li>之后执行任务.then()，打印<code>success</code><br>
所以结果为：</li>
</ul>
<pre><code>1
start
success
</code></pre>
<h1 id="三-promise结合定时器">三、promise结合定时器</h1>
<h2 id="31-题目1">3.1 题目1</h2>
<pre><code>console.log('start')
setTimeout(() =&gt; {
  console.log('time')
})
Promise.resolve().then(() =&gt; {
  console.log('resolve')
})
console.log('end')
</code></pre>
<p>tip:</p>
<ul>
<li>首先按照执行顺序，打印<code>start</code></li>
<li>然后遇到定时器将其放入下一个宏任务队列</li>
<li>将<code>promise.then()</code>也放入微任务队列</li>
<li>打印<code>end</code></li>
<li>执行<code>promise.then</code>打印resolve</li>
<li>执行定时器打印<code>time</code></li>
<li>这里还需要注意的是<code>Promise.resolve()</code>相当于定义一个状态为<code>fullfilled</code>的<code>promise</code>，只有<code>fullfilled</code>状态的<code>promise</code>才能执行<code>.then()</code><br>
执行结果：</li>
</ul>
<pre><code>start
end
resolve
time
</code></pre>
<h2 id="32-题目2">3.2 题目2</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  setTimeout(() =&gt; {
    console.log(&quot;timerStart&quot;);
    resolve(&quot;success&quot;);
    console.log(&quot;timerEnd&quot;);
  }, 0);
  console.log(2);
});
promise.then((res) =&gt; {
  console.log(res);
});
console.log(4);
</code></pre>
<p>tip:</p>
<ul>
<li>首先打印<code>1</code></li>
<li>然后将定时器加入下次宏任务队列</li>
<li>打印<code>2</code></li>
<li>将<code>promise.then</code>加入微任务队列</li>
<li>打印<code>4</code></li>
<li>暂不执行<code>promise.then()</code>，虽然此时应该执行微任务中的<code>.then()</code>,但此时<code>promise</code>状态还为<code>pending</code>，所以不执行</li>
<li>最后开始执行宏任务里的定时器打印出timerstart，修改promise状态为<code>resolved</code>，打印<code>timerend</code></li>
<li>此时promise状态已为<code>resolved</code>，开始执行微任务中的<code>.then()</code>，打印出<code>success</code><br>
执行结果：</li>
</ul>
<pre><code>1
2
4
timerstart
timerend
success
</code></pre>
<h2 id="33-题目3">3.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  console.log('promise1');
  const timer2 = setTimeout(() =&gt; {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() =&gt; {
  console.log('timer1')
  Promise.resolve().then(() =&gt; {
    console.log('promise2')
  })
}, 0)
console.log('start');
</code></pre>
<p>tips:</p>
<ul>
<li>首先把<code>promise.then()</code>放入微任务队列</li>
<li>将<code>timer1</code>放入宏任务队列</li>
<li>打印<code>start</code></li>
<li>执行微任务中的<code>promise.then()</code></li>
<li>打印<code>promise1</code></li>
<li>将<code>timer2</code>放入宏任务队列</li>
<li>执行<code>timer1</code>，打印<code>timer1</code>，将第二个<code>promise.then()</code>放入微任务队列</li>
<li>执行第二个<code>promise.then()</code>，打印<code>promise2</code></li>
<li>执行<code>timer2</code>，打印<code>timer2</code></li>
</ul>
<p>执行结果</p>
<pre><code>start
promise1
timer1
promise2
timer2
</code></pre>
<h2 id="34-题目4">3.4 题目4</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() =&gt; {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() =&gt; {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)
</code></pre>
<p>tips:</p>
<ul>
<li>首先执行<code>promise1</code>，将定时器放入宏任务队列</li>
<li>把<code>promise2</code>放入微任务队列</li>
<li>执行同步代码，打印<code>promise1</code>，此时<code>promise1</code>还未改变状态，所以为<code>pending</code></li>
<li>执行同步代码，打印<code>promise2</code>，由于<code>promise1.then()</code>返回的还是一个<code>promise</code>对象，所以为<code>pending</code></li>
<li>将定时器放入宏任务队列</li>
<li><code>promise2</code>暂不执行，因为<code>p1</code>的状态还未修改</li>
<li>执行第一个定时器，将<code>promise1</code>状态修改为<code>resolved</code></li>
<li>执行<code>p2</code>，<code>throw</code>一个错误<code>error</code></li>
<li>执行第二个定时器，打印<code>resolved和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<h2 id="35-题目5">3.5 题目5</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;success&quot;);
    console.log(&quot;timer1&quot;);
  }, 1000);
  console.log(&quot;promise1里的内容&quot;);
});
const promise2 = promise1.then(() =&gt; {
  throw new Error(&quot;error!!!&quot;);
});
console.log(&quot;promise1&quot;, promise1);
console.log(&quot;promise2&quot;, promise2);
setTimeout(() =&gt; {
  console.log(&quot;timer2&quot;);
  console.log(&quot;promise1&quot;, promise1);
  console.log(&quot;promise2&quot;, promise2);
}, 2000);
</code></pre>
<p>tips：</p>
<ul>
<li>执行<code>p1</code>，将第一个定时器放入宏任务队列，并打印<code>p1</code>里的内容</li>
<li>把<code>p2</code>放入微任务队列</li>
<li>执行同步代码，打印两个<code>pending</code></li>
<li>把第二个定时器加入宏任务队列</li>
<li>p1状态未修改暂不执行p2</li>
<li>执行第一个定时器修改p1的状态并打印<code>timer1</code></li>
<li>执行微任务throw一个错误修改p2状态为<code>rejected</code></li>
<li>执行第二个定时器，打印<code>timer2</code>后分别打印<code>resolved:success和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1里的内容'
'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
'timer1'
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'timer2'
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<p>#四、promise进阶</p>
<h2 id="41-题目1">4.1 题目1</h2>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
  reject(&quot;error&quot;);
  resolve(&quot;success2&quot;);
});
promise
.then(res =&gt; {
    console.log(&quot;then1: &quot;, res);
  }).then(res =&gt; {
    console.log(&quot;then2: &quot;, res);
  }).catch(err =&gt; {
    console.log(&quot;catch: &quot;, err);
  }).then(res =&gt; {
    console.log(&quot;then3: &quot;, res);
  })
</code></pre>
<p>tips：</p>
<ul>
<li>promise状态一经改变便不会再次改变，所以promise状态为<code>rejected</code></li>
<li>之后将<code>promise.then()</code>加入微任务队列</li>
<li>直到被<code>catch</code>捕获错误，<code>catch</code>不论连接在哪里都可以捕获到上级错误</li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;catch: &quot; &quot;error&quot;
&quot;then3: &quot; undefined
</code></pre>
<h2 id="42-题目2">4.2 题目2</h2>
<pre><code>Promise.resolve(1)
  .then(res =&gt; {
    console.log(res);
    return2;
  })
  .catch(err =&gt; {
    return3;
  })
  .then(res =&gt; {
    console.log(res);
  });
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve(1)</code>内部返回的结果是1，打印得到1</li>
<li><code>return2</code>被包装成为<code>resolve(2)</code>，所以该<code>promise</code>对象返回值为2</li>
<li><code>resolve</code>下不走<code>catch</code>，<code>.then</code>打印得到<code>2</code></li>
</ul>
<h2 id="43-题目3">4.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  return new Error('error!!!')
}).then(res =&gt; {
  console.log(&quot;then: &quot;, res)
}).catch(err =&gt; {
  console.log(&quot;catch: &quot;, err)
})
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve().then()</code>return一个错误,当promise对象返回的不是一个promise对象的话就会被包装成一个promise对象，<code>return new Error('error!!!')</code>会被包装成<code>return Promise.resolve(new Error('error!!!'))</code></li>
<li>因此走的是.then()而不是.catch()</li>
<li>若想抛出错误，可以<code>return Promise.reject(newError('error!!!'));</code>或者<code>throw newError('error!!!')</code></li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;then: &quot; &quot;Error: error!!!&quot;
</code></pre>
<h2 id="44-题目4">4.4 题目4</h2>
<pre><code>const promise = Promise.resolve().then(() =&gt; {
  return promise;
})
promise.catch(console.err)
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>或者<code>.catch()</code>不能返回promise自身</li>
<li>所以会报错</li>
</ul>
<p>执行结果：</p>
<pre><code>Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
</code></pre>
<h2 id="45-题目5">4.5 题目5</h2>
<pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre>
<p>tips：</p>
<ul>
<li><code>promise.then()</code>和<code>.catch()</code>的期望值是函数</li>
<li>传入非函数就会发生值传透</li>
<li>第一个<code>then</code>传的是数字</li>
<li>第二个<code>then</code>传的是对象</li>
<li>所以第三个<code>then</code>获取的值是<code>1</code></li>
</ul>
<p>执行结果：</p>
<pre><code>1
</code></pre>
<h2 id="46-题目6">4.6 题目6</h2>
<pre><code>Promise.reject('err!!!')
  .then((res) =&gt; {
    console.log('success', res)
  }, (err) =&gt; {
    console.log('error', err)
  }).catch(err =&gt; {
    console.log('catch', err)
  })
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>有两个参数，一个是用来处理<code>promise</code>成功的函数，另一个是处理失败的函数</li>
<li>当有处理失败函数的时候，错误会走失败的函数而不会走.catch()</li>
</ul>
<p>执行结果：</p>
<pre><code>'error' 'error!!!'
</code></pre>
<ul>
<li>若不写第二个函数，则会走<code>.catch()</code>函数</li>
<li>若在执行成功的函数中抛出一个错误，则该错误只能在<code>.catch()</code>中捕获到，不能在第二个处理错误的函数中被捕获</li>
</ul>
<h2 id="47-题目7">4.7 题目7</h2>
<pre><code>Promise.resolve('1')
  .then(res =&gt; {
    console.log(res)
  })
  .finally(() =&gt; {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() =&gt; {
    console.log('finally2')
  	return'我是finally2返回的值'
  })
  .then(res =&gt; {
    console.log('finally2后面的then函数', res)
  })
</code></pre>
<p>tips:</p>
<ul>
<li>第一个<code>promise</code>修改状态为<code>resolved</code>并得到返回值<code>1</code></li>
<li>将<code>.then()</code>移入微任务队列</li>
<li>因为<code>.then()</code>和<code>.finally()</code>是链式调用，<code>.then()</code>不执行，<code>.finally()</code>也不会执行，所以这里会跳出第一个promise函数</li>
<li>第二个promise修改状态为<code>resolved</code>并得到返回值<code>2</code></li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>将第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.then()</code>移入微任务队列</li>
<li>开始执行第一个<code>.then()</code>,得到1</li>
<li>执行第二个<code>.finally()</code>,打印<code>finally2</code>，且返回一个新的值</li>
<li>执行第一个<code>.finally()</code>,打印<code>finally</code></li>
<li>执行第二个<code>.then()</code>,打印结果2，因为<code>.finally()</code>默认返回的都是原来的<code>promise</code>对象的值，只有当抛出的是一个错误，才会返回这个错误*</li>
</ul>
<p>执行结果：</p>
<pre><code>1
finally2
finally
finally2后面的then函数 2
</code></pre>
<p>*:</p>
<pre><code>Promise.resolve('1')
  .finally(() =&gt; {
    console.log('finally1')
    throw new Error('我是finally中抛出的异常')
  })
  .then(res =&gt; {
    console.log('finally后面的then函数', res)
  })
  .catch(err =&gt; {
    console.log('捕获错误', err)
  })
</code></pre>
<pre><code>'finally1'
'捕获错误' Error: 我是finally中抛出的异常
</code></pre>
<h2 id="48-题目8">4.8 题目8</h2>
<pre><code>function promise1 () {
  let p = new Promise((resolve) =&gt; {
    console.log('promise1');
    resolve('1')
  })
  return p;
}
function promise2 () {
  return new Promise((resolve, reject) =&gt; {
    reject('error')
  })
}
promise1()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally1'))

promise2()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally2'))
</code></pre>
<p>tips:</p>
<ul>
<li><code>p1</code>执行，打印<code>promise1</code>，并且修改<code>promise1</code>状态值为<code>resolved</code>，返回<code>1</code></li>
<li>把第一个<code>.then()</code>移入微任务队列</li>
<li>执行<code>p2</code>，返回一个<code>rejected</code>状态的<code>promise</code>对象，返回值为<code>error</code></li>
<li>因为<code>p2</code>状态为<code>rejected</code>，所以第二个<code>.then()</code>不会执行将第二个<code>.catch</code>移入微任务队列</li>
<li>执行第一个<code>.then()</code>，打印<code>1</code></li>
<li>执行第二个<code>.catch()</code>, 打印<code>error</code></li>
<li>之后把第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>执行第一个<code>.finally()</code>，打印<code>finally1</code></li>
<li>执行第二个<code>.finally()</code>，打印<code>finally2</code></li>
</ul>
<p>执行结果：</p>
<pre><code>promise1
1
error
finally1
finally2
</code></pre>
<h2 id="49-题目9">4.9 题目9</h2>
<pre><code>function runAsync (x) {
	const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
	return p
}
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt;console.log(res))
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.all(</code>)并行执行多个异步操作，并在一个回调中处理所有的数据</li>
</ul>
<p>执行结果：</p>
<pre><code>1
2
3
[1, 2, 3]
</code></pre>
<h2 id="410-题目10">4.10 题目10</h2>
<pre><code>function runAsync (x) {
  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
  return p
}
function runReject (x) {
  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
</code></pre>
<p>tips:</p>
<ul>
<li>
<p><code>promise.all()</code>中参数的顺序就是加入任务队列的顺序，但是定时器执行先后由时间长短排序</p>
</li>
<li>
<p>所以执行顺序为<code>runAsync(1)</code>、 <code>runAsync(3)</code>、 <code>runReject(2)</code>、<code>runReject(4)</code></p>
</li>
<li>
<p>又因为<code>runReject</code>函数抛出错误，所以<code>promise.all().then()</code>不会执行，而<code>.catch()</code>会捕获<code>.all()</code>之中最先的异常</p>
<p>执行结果：</p>
<pre><code></code></pre>
</li>
</ul>
<p>1<br>
3<br>
// 2s后输出<br>
2<br>
Error: 2<br>
// 4s后输出<br>
4</p>
<pre><code>
## 4.11 题目11
</code></pre>
<p>function runAsync (x) {<br>
const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))<br>
return p<br>
}<br>
Promise.race([runAsync(1), runAsync(2), runAsync(3)])<br>
.then(res =&gt;console.log('result: ', res))<br>
.catch(err =&gt;console.log(err))</p>
<pre><code>tips：
- `.race()`只会获取最先执行完的结果

执行结果：
</code></pre>
<p>1<br>
'result: ' 1<br>
2<br>
3</p>
<pre><code>
#五、async和await
## 5.1 题目1
</code></pre>
<p>async function async1() {<br>
console.log(&quot;async1 start&quot;);<br>
await async2();<br>
console.log(&quot;async1 end&quot;);<br>
}<br>
async function async2() {<br>
console.log(&quot;async2&quot;);<br>
}<br>
async1();<br>
console.log('start')</p>
<pre><code>tips：
- `async1`函数执行，打印`async1 start`
- 执行`async2`函数，打印`async2`
- 跳出`async1`，打印`start`
- 再打印`async1 end`
- `await`后面的内容将放到下一次执行，类似于`promise.then()`

执行结果：
</code></pre>
<p>'async start'<br>
'promise'<br>
'async1 end'<br>
'start'</p>
<pre><code>
## 5.2 题目2
</code></pre>
<p>async function async1() {<br>
console.log(&quot;async1 start&quot;);<br>
await async2();<br>
console.log(&quot;async1 end&quot;);<br>
}<br>
async function async2() {<br>
setTimeout(() =&gt; {<br>
console.log('timer')<br>
}, 0)<br>
console.log(&quot;async2&quot;);<br>
}<br>
async1();<br>
console.log(&quot;start&quot;)</p>
<pre><code>tips:
- 与上一道题不同的是async2函数内多了一个定时器，定时器会被放到下一次宏任务中执行

执行结果：
</code></pre>
<p>async1 start<br>
async2<br>
start<br>
async1 end<br>
timer</p>
<pre><code>
## 5.3 题目3
</code></pre>
<p>async function async1() {<br>
console.log(&quot;async1 start&quot;);<br>
await async2();<br>
console.log(&quot;async1 end&quot;);<br>
setTimeout(() =&gt; {<br>
console.log('timer1')<br>
}, 0)<br>
}<br>
async function async2() {<br>
setTimeout(() =&gt; {<br>
console.log('timer2')<br>
}, 0)<br>
console.log(&quot;async2&quot;);<br>
}<br>
async1();<br>
setTimeout(() =&gt; {<br>
console.log('timer3')<br>
}, 0)<br>
console.log(&quot;start&quot;)</p>
<pre><code>tips：
- `async1`函数执行，打印`async1 start`
- `async2`函数执行，将`timer2`移入宏任务队列，然后打印`async2`
- 将`timer3`移入宏任务队列
- 打印`start`
- 打印`async1 end`并且将`timer1`移入宏任务队列
- 执行第一个宏任务，打印`timer2`，微任务队列没有任务，将剩下的两个宏任务依次执行打印`timer3`和`timer1`

执行结果：
</code></pre>
<p>async1 start<br>
async2<br>
start<br>
async1 end<br>
timer2<br>
timer3<br>
timer1</p>
<pre><code>
## 5.4 题目4
</code></pre>
<p>async function async1 () {<br>
console.log('async1 start');<br>
await new Promise(resolve =&gt; {<br>
console.log('promise1')<br>
})<br>
console.log('async1 success');<br>
return 'async1 end'<br>
}<br>
console.log('script start')<br>
async1().then(res =&gt;console.log(res))<br>
console.log('script end')</p>
<pre><code>tips:
- 打印`script start`
- `async1`执行
- 打印`async1 start`
- 新创建一个`promise`对象，打印`promise1`
- 将`.then()`加入微任务队列
- 打印`script end`
- 由于新创建的`promise`对象并没有改变状态，所以`.then()`不会执行，`await`后面的内容也不会执行

执行结果：
</code></pre>
<p>'script start'<br>
'async1 start'<br>
'promise1'<br>
'script end'</p>
<pre><code>## 5.5 题目5
</code></pre>
<p>async function async1 () {<br>
console.log('async1 start');<br>
await new Promise(resolve =&gt; {<br>
console.log('promise1')<br>
resolve('promise1 resolve')<br>
}).then(res =&gt;console.log(res))<br>
console.log('async1 success');<br>
return 'async1 end'<br>
}<br>
console.log('script start')<br>
async1().then(res =&gt;console.log(res))<br>
console.log('script end')</p>
<pre><code>
tips:
- 打印`script start`
- `async1`执行，打印`async1 start`
- 新建一个`promise`对象，打印`promise1`，修改状态为`resolved`，返回值为`promise1 resolve`
- 打印`script end`
- 执行`.then()`
- 打印`async1 success`
- 修改`promise`返回值为`async1 end`
- 执行第二个`.then()`，打印`async1 end`

执行结果：
</code></pre>
<p>'script start'<br>
'async1 start'<br>
'promise1'<br>
'script end'<br>
'promise1 resolve'<br>
'async1 success'<br>
'async1 end'</p>
<pre><code>## 5.6 题目6
</code></pre>
<p>async function testSometing() {<br>
console.log(&quot;执行testSometing&quot;);<br>
return&quot;testSometing&quot;;<br>
}</p>
<p>async function testAsync() {<br>
console.log(&quot;执行testAsync&quot;);<br>
return Promise.resolve(&quot;hello async&quot;);<br>
}</p>
<p>async function test() {<br>
console.log(&quot;test start...&quot;);<br>
const v1 = await testSometing();<br>
console.log(v1);<br>
const v2 = await testAsync();<br>
console.log(v2);<br>
console.log(v1, v2);<br>
}</p>
<p>test();</p>
<p>var promise = newPromise(resolve =&gt; {<br>
console.log(&quot;promise start...&quot;);<br>
resolve(&quot;promise&quot;);<br>
});<br>
promise.then(val =&gt;console.log(val));</p>
<p>console.log(&quot;test end...&quot;);</p>
<pre><code>tips:
- 执行`test`函数，打印`test start`
- 执行`testSomething`函数，打印`执行testSomething`
- 跳出`test`函数，打印`promise start`并且修改promise的值和状态
- 将`.then()`加入微任务队列
- 打印`test end`
- 打印`v1`的值 `testSomething`
- 执行`testAsync`函数，打印`执行testAsync`
- 跳出`tes`t函数，执行微任务的`.then()`,打印`promise`
- 打印`v2`的值` hello async`
- 打印`v1`、`v2`的值

</code></pre>
<p>'test start...'<br>
'执行testSometing'<br>
'promise start...'<br>
'test end...'<br>
'testSometing'<br>
'执行testAsync'<br>
'promise'<br>
'hello async'<br>
'testSometing' 'hello async'</p>
<pre><code>
## 5.7 题目7
</code></pre>
<p>async function async1 () {<br>
await async2();<br>
console.log('async1');<br>
return 'async1 success'<br>
}<br>
async function async2 () {<br>
return new Promise((resolve, reject) =&gt; {<br>
console.log('async2')<br>
reject('error')<br>
})<br>
}<br>
async1().then(res =&gt;console.log(res))</p>
<pre><code>
tips:
- `async`函数中抛出了错误，则不会往下继续执行
- `throw new Error`是一样的效果

执行结果：
</code></pre>
<p>'async2'<br>
Uncaught (in promise) error</p>
<pre><code>## 5.8 题目8
</code></pre>
<p>async function async1 () {<br>
try {<br>
await Promise.reject('error!!!')<br>
} catch(e) {<br>
console.log(e)<br>
}<br>
console.log('async1');<br>
return Promise.resolve('async1 success')<br>
}<br>
async1().then(res =&gt;console.log(res))<br>
console.log('script start')</p>
<pre><code>
tips:
- 若不想错误影响函数后面的执行则可以使用`try catch `

执行结果：
</code></pre>
<p>'script start'<br>
'error!!!'<br>
'async1'<br>
'async1 success'</p>
<pre><code>或者在`Promise.reject`后面跟着一个`catch()`方法
</code></pre>
<p>async function async1 () {<br>
await Promise.reject('error!!!')<br>
.catch(e =&gt;console.log(e))<br>
console.log('async1');<br>
return Promise.resolve('async1 success')<br>
}<br>
async1().then(res =&gt;console.log(res))<br>
console.log('script start')</p>
<pre><code>#六、综合题
## 6.1 题目1
</code></pre>
<p>const first = () =&gt;(new Promise((resolve, reject) =&gt; {<br>
console.log(3);<br>
let p = new Promise((resolve, reject) =&gt; {<br>
console.log(7);<br>
setTimeout(() =&gt; {<br>
console.log(5);<br>
resolve(6);<br>
console.log(p)<br>
}, 0)<br>
resolve(1);<br>
});<br>
resolve(2);<br>
p.then((arg) =&gt; {<br>
console.log(arg);<br>
});</p>
<p>}));</p>
<p>first().then((arg) =&gt; {<br>
console.log(arg);<br>
});<br>
console.log(4);</p>
<pre><code>tips:
- `first`函数执行，打印`3`
- 新建第二个`promise`对象，打印`7`，将定时器移入宏任务队列，并且修改值和状态为`1`和`resolved`
- 将第一个`promise`对象的值和状态修改为`2`和`resolved`
- 将`p.then()`移入微任务队列
- 将`first.then()`移入微任务队列
- 打印`4`
- 执行`p.then()`打印`1`
- 执行`first.then()`打印`2`
- 最后执行宏任务里的定时器
- 打印`5`，修改`p`的状态和返回值，但是`p`的状态已经改变过了，所以不会再改变，打印`Promise{&lt;resolved&gt;: 1}`

执行结果：
</code></pre>
<p>3<br>
7<br>
4<br>
1<br>
2<br>
5<br>
Promise{<resolved>: 1}</p>
<pre><code>
## 6.2 题目2
</code></pre>
<p>const async1 = async () =&gt; {<br>
console.log('async1');<br>
setTimeout(() =&gt; {<br>
console.log('timer1')<br>
}, 2000)<br>
await new Promise(resolve =&gt; {<br>
console.log('promise1')<br>
resolve(2)<br>
})<br>
console.log('async1 end')<br>
return 'async1 success'<br>
}<br>
console.log('script start');<br>
async1().then(res =&gt;console.log(res));<br>
console.log('script end');<br>
Promise.resolve(1)<br>
.then(2)<br>
.then(Promise.resolve(3))<br>
.catch(4)<br>
.then(res =&gt;console.log(res))<br>
setTimeout(() =&gt; {<br>
console.log('timer2')<br>
}, 1000)</p>
<pre><code>tips:
- 打印`script start`
- 执行`async1`函数，打印`async1`，将`timer1`移入宏任务队列
- 新创建一个`promise`对象，打印`promise1`
- 跳出`async1`，打印`script end`
- 获得一个状态为`resolved`且值为`1`的`promise`对象，由于发生值穿透，直接将最后一个`.then()`加入微任务队列
- 将`timer2`移入宏任务队列
- new 的promise对象没有修改状态，所以下面的程序不会执行
- 把`async1().then()`加入微任务队列，依次执行两个微任务,又因为`async1`函数中的`promise`对象状态还是`pending`，所以`async1().then()`不执行
- 两个定时器按照时间执行

执行结果:
</code></pre>
<p>'script start'<br>
'async1'<br>
'promise1'<br>
'script end'<br>
1<br>
'timer2'<br>
'timer1'</p>
<pre><code>若new的promise对象修改了状态，则执行结果就是：
</code></pre>
<p>'script start'<br>
'async1'<br>
'promise1'<br>
'script end'<br>
'async1 end'<br>
'async1 success'<br>
1<br>
'timer2'<br>
'timer1'</p>
<pre><code>
## 6.3 题目3
</code></pre>
<p>const p1 = new Promise((resolve) =&gt; {<br>
setTimeout(() =&gt; {<br>
resolve('resolve3');<br>
console.log('timer1')<br>
}, 0)<br>
resolve('resovle1');<br>
resolve('resolve2');<br>
}).then(res =&gt; {<br>
console.log(res)<br>
setTimeout(() =&gt; {<br>
console.log(p1)<br>
}, 1000)<br>
}).finally(res =&gt; {<br>
console.log('finally', res)<br>
})</p>
<pre><code>tips:
- 将timer1移入宏任务
- 修改promise状态为resolved，值修改为resolve1
- 将.then()移入微任务队列
- 将第二个定时器移入宏任务队列
- 将.finally()移入微任务队列
- 执行.then()，打印resolve1
- 执行.finally()，由于.finally()的回调函数不接受参数，所以为undefined
- 执行定时器1，打印timer1
- 执行定时器2，此时通过链式调用，返回值已经变成undefined

执行结果：
</code></pre>
<p>'resolve1'<br>
'finally' undefined<br>
'timer1'<br>
Promise{<resolved>: undefined}</p>
<pre><code></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[flex布局的使用]]></title>
        <id>https://skrupellose.github.io/post/flex-bu-ju-de-shi-yong/</id>
        <link href="https://skrupellose.github.io/post/flex-bu-ju-de-shi-yong/">
        </link>
        <updated>2020-01-07T05:10:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-认识flex布局">一、认识flex布局</h1>
<p>flex布局已经成为了web开发中使用最多的布局方案</p>
<h2 id="11-两个概念">1.1 两个概念</h2>
<ul>
<li>开启了flex布局的元素叫<code>flex container</code></li>
<li><code>flex container</code>里面的直接子元素叫做<code>flex items</code></li>
</ul>
<h2 id="12-如何开启flex布局">1.2 如何开启flex布局</h2>
<p>设置display属性为flex或者inline-flex可以成为flex container</p>
<ul>
<li>flex：flex container以block-level形式存在</li>
<li>inline-flex：flex container以inline-level形式存在</li>
</ul>
<h1 id="二-flex布局模型">二、flex布局模型</h1>
<figure data-type="image" tabindex="1"><img src="https://skrupellose.github.io/post-images/1578374921989.png" alt="" loading="lazy"></figure>
<h2 id="2flex相关属性">2.flex相关属性</h2>
<h3 id="21-应用在flex-container上的css属性">2.1 应用在flex container上的css属性</h3>
<ul>
<li>flex-flow</li>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<p><code>flex items</code>默认都是沿着<code>main axis</code>(主轴)从<code>main start</code>开始往<code>main end</code>方向排布</p>
<h3 id="211-flex-direction决定了main-axis的方向有四个取值row默认-row-reverse-column-column-reverse">2.1.1 <code>flex-direction</code>决定了<code>main axis</code>的方向，有四个取值：<code>row</code>(默认)、<code>row-reverse</code>、<code>column</code>、<code>column-reverse</code></h3>
<h3 id="212-justify-content决定flex-items的主轴mian-axis对齐方式取值">2.1.2 <code>justify-content</code>决定<code>flex items</code>的主轴(mian axis)对齐方式，取值：</h3>
<ul>
<li>flex-start：与main start对齐</li>
<li>flex-end：与 main end对齐</li>
<li>center：居中对齐</li>
<li>space-between：flex items之间距离相等且与main start、main end两端对齐</li>
<li>space-evenly：flex items之间距离相等且与main start、main end等距</li>
<li>space-around：flex items与main start、main end之间的距离是flex items之间距离的一半</li>
</ul>
<p>若<code>flex items</code>不设置高度，那么默认情况下它的高度就是<code>cross size</code></p>
<h3 id="213-align-items决定了flex-items的交叉轴cross-axis上的对齐方式取值">2.1.3 <code>align-items</code>决定了<code>flex items</code>的交叉轴(cross axis)上的对齐方式,取值：</h3>
<ul>
<li>normal：弹性布局中，效果与stretch一样</li>
<li>stretch：当flex items在cross axis方向的size为auto时，会自动拉伸至填充flex container</li>
<li>flex-start：在交叉轴的起点对齐</li>
<li>flex-end：在交叉轴的终点对齐</li>
<li>center：在交叉轴的中点对齐</li>
<li>baseline：基准线对齐</li>
</ul>
<p>默认情况下所有的flex items会在同一行显示，放不下的会进行收缩然后在同行显示</p>
<h3 id="214-flex-wrap决定了flex-container是单行还是多行用于控制换行取值">2.1.4 <code>flex-wrap</code>决定了flex container是单行还是多行用于控制换行，取值：</h3>
<ul>
<li>normal：默认（单行）</li>
<li>wrap：多行</li>
<li>warp-reverse：多行（对比wrap，cross start和cross end相反）</li>
</ul>
<h3 id="215-flex-flow是flex-directionflex-wrap的简写">2.1.5 <code>flex-flow</code>是flex-direction||flex-wrap的简写</h3>
<ul>
<li>可以省略，顺序随意</li>
</ul>
<h3 id="216-align-content决定了多行flex-items在交叉轴上的对齐方式用法与just-content类似取值">2.1.6 <code>align-content</code>决定了多行flex items在交叉轴上的对齐方式，用法与<code>just-content</code>类似，取值：</h3>
<ul>
<li>flex-start：与cross start对齐</li>
<li>flex-end：与cross end对齐</li>
<li>center：居中对齐</li>
<li>space-between：flex items之间距离相等且与cross start、cross end两端对齐</li>
<li>space-evenly：flex items之间距离相等且与cross start、cross end等距</li>
<li>space-around：flex items与cross start、cross end之间的距离是flex items之间距离的一半</li>
</ul>
<h3 id="22-应用在flex-items上的css属性">2.2 应用在flex items上的css属性</h3>
<ul>
<li>flex</li>
<li>flex-grow</li>
<li>flex-basis</li>
<li>flex-shrink</li>
<li>order</li>
<li>align-self</li>
</ul>
<h3 id="221-order决定了flex-items的排布顺序">2.2.1 <code>order</code>决定了flex items的排布顺序</h3>
<ul>
<li>可以设置成任意整数，数值越小越靠前</li>
<li>默认值是0</li>
</ul>
<h3 id="222-align-self单独决定flex-item的排布顺序通过覆盖flex-container设置的align-items">2.2.2 <code>align-self</code>单独决定flex item的排布顺序（通过覆盖flex container设置的align-items）</h3>
<ul>
<li>auto（默认值）：遵从flex container的align-items设置</li>
<li>stretch、flex-start、flex-end、center、baseline，效果与align-items一致</li>
</ul>
<h3 id="223-flex-grow决定了flex-items如何扩展">2.2.3 <code>flex-grow</code>决定了flex items如何扩展</h3>
<ul>
<li>可以设置成任意非负数字（正小数、正整数、0），默认是0</li>
<li>当flex container在主轴方向有剩余的size的时候，flex-grow属性才会生效</li>
<li>如果所有flex items的flex-grow总和sum超过1，每个flex item扩展的size为：flex container剩余的size * flex-grow / sum</li>
<li>如果所有的flex items的flex-grow总和sum没有超过1，每个flex item扩展的size为：flex container的剩余size * flex-grow</li>
<li>flex items扩展后的最终size不能超过max-width/max-height</li>
</ul>
<h3 id="224-flex-shrink决定了flex-items如何收缩">2.2.4 <code>flex-shrink</code>决定了flex items如何收缩</h3>
<ul>
<li>可以设置成任意非负数字（正小数、正整数、0），默认是1</li>
<li>当flex items在主轴方向上的size超过了flex container的size，flex-shrink超会生效</li>
<li>如果所有的flex items的flex-shrink总和超过1，每个flex items的收缩的size为：flex items超出的flex items超出flex container的size * 收缩比例 / 所有flex items收缩比例之和</li>
<li>如果所有的flex items的flex-shrink总和不超过1，每个flex items收缩的size为：flex items超出的flex container的size * flex-shrink值</li>
<li>flex items收缩之和最终size不能小于min-width/min-height</li>
</ul>
<h3 id="225-flex-basis设置flex-items在主轴方向上的base-size">2.2.5 <code>flex-basis</code>设置flex items在主轴方向上的base size</h3>
<ul>
<li>auto 默认值、具体的宽度数值</li>
<li>决定flex items最终base size的因素，从优先级高到低：<br>
1.max-width/max-height/min-width/min-height<br>
2.flex-basis<br>
3.width/height<br>
4.内容本身的size</li>
</ul>
<h3 id="226-flex是flex-growflex-shrinkflex-basic的缩写属性可以指定1-3个值">2.2.6 <code>flex</code>是flex-grow||flex-shrink||flex-basic的缩写属性，可以指定1-3个值。</h3>
<ul>
<li>
<p>单值语法：值必须为以下值之一：</p>
<ul>
<li>一个无单位数 它会被当作flex-grow的值</li>
<li>一个有效宽度值 它会被当做flex-basis的值</li>
<li>关键字none、auto或者initial</li>
</ul>
</li>
<li>
<p>双值语法：第一个值必须为一个无单位数，它会被当做flex-grow的值</p>
<ul>
<li>第二个值必须为以下之一：
<ul>
<li>一个无单位数，被当做flex-shrink值</li>
<li>一个有效宽度值，被当做flex-basis值</li>
</ul>
</li>
</ul>
</li>
<li>
<p>三值语法：</p>
<ul>
<li>第一个值必须为一个无单位数，被当做flex-grow的值</li>
<li>第二个值必须为一个无单位数，被当做flex-shrink的值</li>
<li>第三个值必须为一个有效宽度值，被当做flex-basis的值</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有趣的axios源码（一）]]></title>
        <id>https://skrupellose.github.io/post/you-qu-de-axios-yuan-ma-yi/</id>
        <link href="https://skrupellose.github.io/post/you-qu-de-axios-yuan-ma-yi/">
        </link>
        <updated>2019-11-24T14:48:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-现象">一、现象：</h1>
<p>若我们添加两组请求和响应拦截器<br>
请求拦截器先添加的后执行，响应拦截器先添加的先执行。</p>
<pre><code>axios.interceptors.request.use(
  config =&gt; {
    console.log('request interceptor1 onResolved()')
      return config
  },
  error =&gt; {
    console.log('request interceptor1 onResolved()')
      return Promise.reject(error);
  }
)
axios.interceptors.request.use(
  config =&gt; {
    console.log('request interceptor2 onResolved()')
      return config
  },
  error =&gt; {
    console.log('request interceptor2 onResolved()')
      return Promise.reject(error);
  }
)
axios.interceptors.response.use(
  response =&gt; {
    console.log('response interceptor1 onResolved()')
      return response
  },
  error =&gt; {
    console.log('response interceptor1 onResolved()')
      return Promise.reject(error);
  }
)
axios.interceptors.response.use(
  response =&gt; {
    console.log('response interceptor2 onResolved()')
      return response
  },
  error =&gt; {
    console.log('response interceptor2 onResolved()')
      return Promise.reject(error);
  }
)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://skrupellose.github.io/post-images/1574609692911.png" alt="" loading="lazy"></figure>
<h1 id="二-原因">二、原因</h1>
<p>axios基于promise进行封装<br>
这部分的源码：(axios/lib/core/Axios.js)</p>
<pre><code>
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
//后添加的请求拦截器放在数组前面
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
//每个拦截器都包含两个回调函数一个成功的回调一个失败的回调
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
//后添加的响应拦截器放在数组后面
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });
//通过promise的then()方法串连起所有的请求拦截器/请求方法/响应拦截器
  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }
//最后返回我们使用axios函数指定了onResolved和onRejectd的promise
  return promise;
};
</code></pre>
<p>通过分析我们可以看出这个流程的大概步骤：</p>
<ol>
<li>隐式创建出用来保存请求和响应拦截函数的数组 -&gt; requestInterceptor和responseInterceptor</li>
<li>chain数组保存发送请求的函数</li>
<li>chain数组通过unshift和push方法分别往里面添加请求拦截函数和响应拦截函数</li>
<li>数组左边放的是请求拦截器函数</li>
<li>数组右边放的是响应拦截器函数</li>
</ol>
<pre><code>//我们用1,2,3,4分别代表从第一个请求拦截器到第二个响应拦截
1. requestInterceptor:[{fulfilled1(){}, rejected1(){}}, {fulfilled2(){}, rejected2(){}}]
   responseInterceptor:[{fulfilled3(){}, rejected3(){}}, {fulfilled4(){}, rejected4(){}}]
2. chain:[dispatchRequest, undefined]
3. chain:[
        fulfilled2, rejected2, fulfilled1, rejected1, 
        dispatchRequest, undefined, 
        fulfilled3, rejected3, fulfilled4, rejected4
        ]
//这就是最后的chain数组的样子，我们可以看到后添加的请求拦截器在数组的首位
</code></pre>
<p>其实看到chain.unshift请求拦截函数的时候就已经能够解释为什么添加多组响应器时请求拦截器先添加的后执行，因为unshift方法就是往数组的首位去插入元素，而push是往末尾添加元素。</p>
<p>之后通过</p>
<pre><code>while (chain.length) {
    //每次取出两个元素，正好对应一个拦截器的成功回调与失败回调
    promise = promise.then(chain.shift(), chain.shift());
return promise;
</code></pre>
<p>shift()删除第一个当前数组元素并返回该数据，这也正好我们拦截器的执行顺序，从chain数组的首位开始执行。故有了我们请求拦截器先添加的后执行，响应拦截器先添加的先执行的现象<br>
我们promise链的样子就是这样的：</p>
<pre><code>config =&gt; (fulfilled2, rejected2) =&gt; (fulfilled1, rejected1) //请求拦截器处理
       =&gt; (dispatchRequest, undefined) //发请求
       =&gt; (fulfilled3, rejected3) =&gt; (fulfilled4, rejected4) //响应拦截器处理
       =&gt; (onResolved, onRejected) //我们通过axios发送请求后的处理
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue+element.ui+axios做一个简单用户管理demo]]></title>
        <id>https://skrupellose.github.io/post/vueelementuiaxios-zuo-yi-ge-jian-dan-yong-hu-guan-li-demo/</id>
        <link href="https://skrupellose.github.io/post/vueelementuiaxios-zuo-yi-ge-jian-dan-yong-hu-guan-li-demo/">
        </link>
        <updated>2019-11-17T14:55:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-技术栈">一、技术栈</h1>
<p>vue、element.ui、axios</p>
<h1 id="二-准备工作">二、准备工作</h1>
<p>接口：<br>
<code>http://www.liulongbin.top:3005/</code><br>
这是在b站上小伙伴留下的测试接口</p>
<p>要实现的功能：</p>
<ol>
<li>
<p>添加用户<br>
<img src="https://skrupellose.github.io/post-images/1574007328629.png" alt="" loading="lazy"></p>
</li>
<li>
<p>搜索功能<br>
<img src="https://skrupellose.github.io/post-images/1574007313864.png" alt="" loading="lazy"><br>
<img src="https://skrupellose.github.io/post-images/1574007386230.png" alt="" loading="lazy"></p>
</li>
<li>
<p>删除用户<br>
<img src="https://skrupellose.github.io/post-images/1574007394205.png" alt="" loading="lazy"></p>
</li>
</ol>
<h1 id="三-具体实现">三、具体实现</h1>
<h2 id="31-用户数据展示和删除">3.1 用户数据展示和删除</h2>
<p>我们的用户数据用table显示，新增用户用form结合dialog组件实现。</p>
<p>这里主要是讲 <code>&lt;template slot-scope=&quot;scope&quot;&gt;</code>,官方文档讲通过<code>Scoped slot</code>可以获取到<code>row</code>, <code>column</code>, <code>$index</code> 和 <code>store（table 内部的状态管理）</code>的数据。<br>
我们一般表格只是显示数据的话，那么我们只需要在<code>el-table-column</code>标签中添加prop属性，填上对应的值，那么表格就能渲染出来。如：</p>
<pre><code>        &lt;el-table :data=&quot;tableData&quot; ref=&quot;tableData&quot; border stripe&gt;
          &lt;el-table-column label=&quot;序号&quot; width=&quot;90&quot; prop=&quot;id&quot;&gt;
          &lt;/el-table-column&gt;
           &lt;el-table-column label=&quot;用户名&quot; prop=&quot;name&quot;&gt;
          &lt;/el-table-column&gt;
           &lt;el-table-column label=&quot;时间&quot; prop=&quot;ctime&quot;&gt;
          &lt;/el-table-column&gt;
        &lt;/el-table&gt;
</code></pre>
<p>但是这样我们不好监听删除事件，所以我们使用<code>&lt;template slot-scope=&quot;scope&quot;&gt;</code></p>
<pre><code>        &lt;el-table :data=&quot;tableData&quot; ref=&quot;tableData&quot; border stripe&gt;
          &lt;el-table-column label=&quot;序号&quot; width=&quot;90&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.id }}&lt;/span&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;用户名&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.name }}&lt;/span&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;时间&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.ctime }}&lt;/span&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;操作&quot; width=&quot;160&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;el-button type=&quot;primary&quot;&gt;编辑&lt;/el-button&gt;
              &lt;el-button @click.native.prevent=&quot;_del(scope.row.id)&quot; type=&quot;danger&quot;&gt;移除&lt;/el-button&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
        &lt;/el-table&gt;
</code></pre>
<p>通过<code>scope.row.id</code>我们就能得到当前点击的数据的id值，这也是它的唯一索引，我们通过向后台提交这个值来达到删除该条数据的目的。</p>
<pre><code>function del(id) {
  const url = &quot;api/delproduct/&quot;;
  return $axios.get(url + id);
</code></pre>
<pre><code>method:

   _del(id) {
      del(id).then(res =&gt; {
        const result = res.data;
        if (result.status === 0) {
          this._getlist();//删除之后获取新数据达到刷新效果
        }
        console.log(res);
      });
    },
</code></pre>
<h2 id="32-用户添加">3.2 用户添加</h2>
<p>我们获取用户列表的时候执行一次axios请求，添加之后也要执行一下这个方法达到刷新的目的，删除也是这样。</p>
<pre><code>const $axios = axios.create({
  // 设置超时时间
  timeout: 30000,
  // 基础url，会在请求url中自动添加前置链接
  baseURL: &quot;http://www.liulongbin.top:3005/&quot;
});
</code></pre>
<p>我们还是配置一下我们的axios实例，这样后面写url的时候会方便很多。<br>
获取列表的方法：</p>
<pre><code>function getlist() {
  const url = &quot;api/getprodlist&quot;;
  return $axios.get(url);
}
</code></pre>
<p>然后在method中对这个请求做一下处理：</p>
<pre><code>    _getlist() {
      getlist().then(res =&gt; {
        console.log(res);
        this.allList = res.data.message;
        this.tableData = this.allList;
      });
    },
</code></pre>
<p>之后我们在<code>create</code>的时候第一次执行<code>_getlist()</code>获取用户信息。<br>
用户添加功能我们写在<code>form</code>表单里面，然后写一个<code>dialog</code>控件把<code>form</code>嵌在<code>dialog</code>上，平时使它的值为<code>false</code>，在点击添加的时候变为<code>true</code>，这样<code>dialog</code>就会显示出来，我们就能在<code>form</code>上添加用户了。</p>
<p>这里需要注意的一点就是关于函数的this指向，我之前也是将<code>add()</code>函数封装了一下，外面又套了一个函数<code>_add()</code>对<code>add()</code>方法返回的信息进行处理，在添加用户的时候调用_add()方法，然后传值<code>this.formData.name</code>,但是这个时候this指向的不是表单，而是调用套在它外面的<code>_add()</code>函数（add方法是<code>axios</code>请求，此时在<code>add</code>方法里传<code>this.formData.name</code>的话就会去调用它的<code>_add</code>方法里去找）。</p>
<p>所以我们直接写一个addUser方法就好：</p>
<pre><code>    addUser() {
      const url = &quot;api/addproduct&quot;;
      $axios.post(url, { name: this.formData.name }).then(res =&gt; {
        const result = res.data;
        if (result.status === 0) {
          this._getlist();
        }
      });
</code></pre>
<p>在添加成功用户之后再执行一次<code>_getlist()</code>方法刷新页面。</p>
<h2 id="33-用户搜索">3.3 用户搜索</h2>
<p>我们首先新建一个数组来储存符合要求的用户，然后给input输入框设置双向绑定来获取当前里面的值，然后通过在总数据中使用forEach遍历，对每个数据的名字用IndexOf进行判断看是否是我们要找的数据，如果不为-1证明是我们要找的值，将它push到新数组，然后将数组的值传给表格进行渲染。</p>
<pre><code>    searchTab() {
      let newlist = [];
      this.allList.forEach(item =&gt; {
        if (item.name.indexOf(this.keywords) != -1) {
          newlist.push(item);
        }
      });
      this.tableData = newlist;
    },
</code></pre>
<p>一个和这个差不多的<a href="https://github.com/Skrupellose/manage-demo/blob/master/index.html">例子</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法题--数组(1)]]></title>
        <id>https://skrupellose.github.io/post/suan-fa-ti-shu-zu-1/</id>
        <link href="https://skrupellose.github.io/post/suan-fa-ti-shu-zu-1/">
        </link>
        <updated>2019-11-16T14:59:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="要求">要求：</h2>
<p>将上面的数组转换成下面数组的形式</p>
<pre><code>      [
        { name: &quot;a&quot;, hobby: &quot;football&quot; },
        { name: &quot;b&quot;, hobby: &quot;basketball&quot; },
        { name: &quot;a&quot;, hobby: &quot;swim&quot; },
        { naem: &quot;b&quot;, hobby: &quot;computer&quot; }
      ];

      [
        {name: 'a', hobby: 'football, swim'},
        {name: 'b', hobby: 'basketball, computer'}
      ]
</code></pre>
<h3 id="思路">思路：</h3>
<ol>
<li>新建一个空的新数组，使用<code>forEach</code>遍历原数组取得每一个对象</li>
<li>进行判断，若此时新数组为空，则将此遍历到的这个对象<code>push</code>到新数组；</li>
<li>若此时新数组不为空，则使用<code>findIndex()</code>方法，判断当前对象的名称在数组中是否已经存在，若存在则通过返回的索引将值<code>push</code>进对应的对象的<code>hobby</code>属性里，若不存在则将该对象<code>push</code>进新数组</li>
</ol>
<h3 id="知识点">知识点：</h3>
<p><strong>forEach()</strong><br>
<code>forEach()</code> 方法按升序为数组中含有效值的每一项执行一次<code>callback</code> 函数，那些已删除或者未初始化的项将被跳过</p>
<p><code>array.forEach(function(currentValue, index, arr), thisValue)</code></p>
<p>回调函数参数：</p>
<ul>
<li><code>currentValue</code>	必需。当前元素</li>
<li><code>index</code>  可选。当前元素的索引值。</li>
<li><code>arr</code>	 可选。当前元素所属的数组对象。</li>
</ul>
<p><strong>findIndex()</strong><br>
<code>findIndex()</code> 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。</p>
<p><code>findIndex()</code> 方法为数组中的每个元素都调用一次函数执行：</p>
<p>当数组中的元素在测试条件时返回 <code>true</code> 时, <code>findIndex()</code>返回符合条件的元素的索引位置，之后的值不会再调用执行函数。<br>
如果没有符合条件的元素返回 <code>-1</code></p>
<p><code>array.findIndex(function(currentValue, index, arr), thisValue)</code><br>
回调函数参数：</p>
<ul>
<li><code>currentValue</code> 	必需。当前元素</li>
<li><code>index</code>  可选。当前元素的索引值。</li>
<li><code>arr</code>	 可选。当前元素所属的数组对象。</li>
</ul>
<p><strong>hasOwnProperty()</strong><br>
<code>hasOwnProperty()</code>方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。</p>
<p><code>obj.hasOwnProperty(prop)</code></p>
<p>参数：</p>
<p><code>prop</code>：要检测的属性的<code>String</code>字符串形式表示的名称，或者<code>Symbol</code></p>
<h3 id="实现">实现：</h3>
<pre><code>      const arr = [

        { name: &quot;b&quot;, hobby: &quot;basketball&quot; },
        { name: &quot;a&quot;, hobby: &quot;swim&quot; },
        { name: &quot;b&quot;, hobby: &quot;computer&quot; },
        { name: &quot;a&quot;, hobby: &quot;football&quot; }
      ];
      let resArr = []
      arr.forEach((item, index) =&gt; {
        if (resArr.length) {
          const res = resArr.findIndex(_item =&gt; _item.name === item.name)
          if ((res === -1)) {
            resArr.push({
              name: item.name,
              hobby: [item.hobby]
            });
          } else {
            resArr[res][&quot;hobby&quot;].push(item.hobby)
          }
        } else {
          resArr.push({
            name: item.name,
            hobby: [item.hobby]
          })
        }
      })
      console.log(resArr) //[{name: &quot;a&quot; hobby:  [&quot;swim&quot;, &quot;football&quot;]}, {name: &quot;b&quot; hobby: [&quot;basketball&quot;, &quot;computer&quot;]}]
</code></pre>
<p>还有另一种写法，思路与上面的大同小异，只是通过<code>hasOwnProperty</code>来判断是否已有重复属性，然后用<code>findIndex()</code>来得到索引。</p>
<pre><code>      let obj1 = {};
      let objArr = [];
      const arr = [
        { name: &quot;a&quot;, hobby: &quot;football&quot; },
        { name: &quot;b&quot;, hobby: &quot;basketball&quot; },
        { name: &quot;a&quot;, hobby: &quot;swim&quot; },
        { name: &quot;b&quot;, hobby: &quot;computer&quot; }
      ];

      arr.forEach((item, index) =&gt; {
        if (obj1.hasOwnProperty(item.name)) {
          const index = objArr.findIndex(
            objArrItem =&gt; item.name === objArrItem.name
          );
          objArr[index].hobby.push(item.hobby);
        } else {
          objArr.push({
            name: item.name,
            hobby: [item.hobby]
          });
          obj1[item.name] = index;
        }
      });
      console.log(objArr); //[{name: &quot;a&quot; hobby:  [&quot;swim&quot;, &quot;football&quot;]}, {name: &quot;b&quot; hobby: [&quot;basketball&quot;, &quot;computer&quot;]}]
      console.log(obj1); //{a: 0, b: 1}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fetch和axios的上手使用]]></title>
        <id>https://skrupellose.github.io/post/fetch-he-axios-de-shang-shou-shi-yong/</id>
        <link href="https://skrupellose.github.io/post/fetch-he-axios-de-shang-shou-shi-yong/">
        </link>
        <updated>2019-11-14T15:41:05.000Z</updated>
        <content type="html"><![CDATA[<p>复(xue)习一下<code>fetch</code>和<code>axios</code>的用法</p>
<h1 id="一-fetch的用法">一、fetch的用法</h1>
<p>直接贴demo了</p>
<pre><code>      fetch(&quot;url&quot;).then(data =&gt; {
        return data.text().then(res =&gt; {
          console.log(res);
        });
      });
</code></pre>
<ul>
<li>要获取数据首先要调用<code>text()</code>方法或者<code>json()</code>方法</li>
<li><code>data.text()/data.json()</code>返回的是<code>promise</code>对象，用<code>.then()</code>处理之后得到的才是结果</li>
<li><code>text()</code>返回结果为字符串</li>
<li><code>json()</code>返回结果为json类型</li>
</ul>
<h2 id="11-fetch请求参数">1.1 fetch请求参数</h2>
<ul>
<li><code>method(String)</code>:http请求方法，默认为<code>GET(GET、POST、PUT、DELETE)</code></li>
<li><code>body(String)</code>:http的请求参数</li>
<li><code>header(Object)</code>:http的请求头，默认为{}</li>
</ul>
<h2 id="12-get请求">1.2 GET请求</h2>
<pre><code>
      // url传递参数
      fetch('url?id=123',{
        method: 'get'
      }).then(data =&gt; {
        return data.text()
        .then(res =&gt; {
          console.log(res);
        })
      })
      // Restful形式的url传递参数
      fetch('url/123',{
        method: 'get'
      }).then(data =&gt; {
        return data.text()
        .then(res =&gt; {
          console.log(res);
        })
      })
</code></pre>
<h2 id="13-delete请求">1.3 DELETE请求</h2>
<p>✊偷个懒 只需把<code>method</code>换成<code>delete</code>即可</p>
<h2 id="14-post请求">1.4 POST请求</h2>
<pre><code>  //传统参数传递
  fetch('url',{
    method: 'post',
    body: 'name=abc&amp;passwd=123',
    headers: {
      'Content-type': 'application/x-www-form-unlencoded',
    }//请求头必须设置否则body里的数据传不到后台去
  }).then(data =&gt; {
    return data.text()
    .then(res =&gt; {
      console.log(res);
    })
  })

  //json形式参数传递
  fetch('url',{
    method: 'post',
    body: JSON.stringify({
      name:&quot;abc&quot;,
      passwd:&quot;123&quot;
    }),
    headers: {
      'Content-type': 'application/json',
    }//请求头必须设置否则body里的数据传不到后台去
  }).then(data =&gt; {
    return data.text()
    .then(res =&gt; {
      console.log(res);
    })
  })
</code></pre>
<h2 id="15-put请求">1.5 PUT请求</h2>
<pre><code>      fetch('url/456',{
        method: 'put',
        body: JSON.stringify({
          name:&quot;abc&quot;,
          passwd:&quot;123&quot;
        }),
        headers: {
          'Content-type': 'application/json',
        }
      }).then(data =&gt; {
        return data.text()
        .then(res =&gt; {
          console.log(res);
        })
      })
      // 把put的值通过url的Restful形式传过去
</code></pre>
<h1 id="二-axios">二、axios</h1>
<h2 id="21-用法">2.1 用法</h2>
<pre><code>      axios.get('url')
      .then(res =&gt; {
        console.log(res.data)
        // 需要注意的是使用axios请求数据后.then()返回的对象除去我们想要的数据
        // 之外还有其他的数据，所以当我们需要拿到想要的数据的时候要使用data属性来获取
      })
</code></pre>
<h2 id="22-get请求">2.2 get请求</h2>
<pre><code>      // 1.通过url传递
      axios.get('url?id=123')
      .then(res =&gt; {
        console.log(res.data)
      })
      // 2.通过params属性传递
      axios.get('url',{
        params:{
          id: 123
        }
      })
      .then(res =&gt; {
        console.log(res.data)
      })

</code></pre>
<h2 id="23-delete请求">2.3 delete请求</h2>
<p>继续偷个懒，<code>delete</code>方式只需要把<code>ge</code>t换成<code>delete</code>即可</p>
<h2 id="24-post请求">2.4 post请求</h2>
<pre><code>  // 通过选项来传递参数默认传递的是json格式的数据
      axios.post('url',{
        name: &quot;yy&quot;,
        age: 16
      })//通过这种传到后台的数据是json格式
      .then(res =&gt;{
        console.log(res.data)
      })

      // 通过URLSearchParams传递参数
      const params = new URLSearchParams();
      params.append('name','abc');
      params.append('age','16');
      axios.post('url', params)
      .then(res =&gt; {
        console.log(res.data)
      })
</code></pre>
<h2 id="25-put请求">2.5 put请求</h2>
<pre><code>      axios.post('url/123',{
        name: &quot;yy&quot;,
        age: 16
      })//通过这种传到后台的数据是json格式
      .then(res =&gt;{
        console.log(res.data)
      })
</code></pre>
<h2 id="26-请求和响应拦截">2.6 请求和响应拦截</h2>
<pre><code>      // 请求拦截 发出请求数据之前进行一些配置和处理
      axios.interceptors.request.use(config =&gt;{
        ... //一些操作代码
        return config;
      })

      // 响应拦截 获取数据之前对数据进行一些处理
      axios.interceptors.response.use(res =&gt;{
        ... //一些操作代码
        return res;
      })

</code></pre>
<h2 id="27-axios响应结果">2.7 axios响应结果</h2>
<p>响应结果被包装成一个对象<br>
里面的主要属性：<br>
-<code>data</code>：实际响应回的数据<br>
-<code>headers</code>： 响应头信息</p>
<ul>
<li><code>status</code>：响应状态码</li>
<li><code>statusText</code>：响应状态信息</li>
</ul>
<h2 id="28-axios和asyncawait的联用">2.8 axios和async/await的联用</h2>
<pre><code>      async function get_(){
        let res = await axios.get('url');
        console.log(res.data)
      }
      get_() //data

      axios.get('url')
      .then(res =&gt; {
        console.log(res.data)
      })
</code></pre>
<p><code>then()</code>方法参数中的函数返回值:</p>
<ol>
<li>返回<code>promise</code>对象 返回的对象会调用下一个<code>then</code></li>
<li>返回普通值，会被直接传递给下一个<code>then()</code>的函数中充当参数</li>
</ol>
<p>或是：后面的请求需要前一个请求返回的结果作为参数，可以这么写提高代码可读性</p>
<pre><code>        async function test(){
          let res1 = await axios.get('url1')
          let res2 = await axios.get('url2?info=' + res1.data)
          return rest2
        }
        test().then(res =&gt; {
          console.log(res);
        })
</code></pre>
<p>补充：我们还可以新建一个<code>axios</code>实例对象来进行一些配置</p>
<pre><code>const $axios = axios.create({
  // 设置超时时间
  timeout: 30000,
  // 基础url，会在请求url中自动添加前置链接
  baseURL: &quot;url&quot;
});
</code></pre>
<p>这样我们在后面使用<code>axios</code>发送请求的时候就不用写那么长的url了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深浅拷贝小总结]]></title>
        <id>https://skrupellose.github.io/post/shen-qian-kao-bei-xiao-zong-jie/</id>
        <link href="https://skrupellose.github.io/post/shen-qian-kao-bei-xiao-zong-jie/">
        </link>
        <updated>2019-11-12T14:28:29.000Z</updated>
        <content type="html"><![CDATA[<p>👻 拷贝就是复制一份一样的东西出来，浅拷贝简单理解就是通过复制之后，和原件还有关系，彼此的改变会影响到彼此，而深拷贝复制出来后与原件互不相干涉。</p>
<h1 id="一-数据类型介绍">一、数据类型介绍</h1>
<p><code>JavaScript</code>的数据类型分为基本数据类型和引用数据类型。基本数据类型有：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Undefined</li>
<li>Null</li>
<li>Symbol</li>
</ul>
<p>它们都储存在栈内存中<br>
然后是引用数据类型：</p>
<ul>
<li>Array</li>
<li>Object</li>
</ul>
<p>这两个保存在堆内存中，但是在栈内存中保留了引用</p>
<h1 id="二-关于基本数据类型的拷贝">二、关于基本数据类型的拷贝</h1>
<p>基本数据类型的拷贝直接新建一个变量赋值就完事，它只有深拷贝，不那么让人困惑：</p>
<pre><code>let a = 1;
let b = a;
a = 2 ;
console.log(b)  // 1
</code></pre>
<p>b是从a拷贝来的，但是a的重新赋值并没有影响到b，所以是深拷贝。</p>
<h1 id="三-关于引用数据类型的拷贝">三、关于引用数据类型的拷贝</h1>
<h2 id="31-引用数据类型的浅拷贝">3.1 引用数据类型的浅拷贝</h2>
<pre><code>const oriArray = [1,2,3];
const oriObj = {a:'a',b:'b',c:[1,2,3],d:{d:'d'}};

const cloneArray = oriArray;
const cloneObj = oriObj;

console.log(oriArray) //[1,2,3]
console.log(oriObj) //{a:'a',b:'b',c:[1,2,3],d:{d:'d'}}

cloneArray.push(4);
cloneObj.a = 'A';

console.log(oriArray) //[1,2,3,4]
console.log(oriObj) //{a:'A',b:'b',c:[1,2,3],d:{d:'d'}}
</code></pre>
<p>通过赋值方式拷贝引用数据类型的时候，发现操作克隆值会影响到原来的值，这就是浅拷贝</p>
<h2 id="32-引用数据类型的深拷贝">3.2 引用数据类型的深拷贝</h2>
<p>目前实现深拷贝的方法不多，主要是两种：</p>
<ol>
<li>利用 <code>JSON</code>对象中的<code>parse</code> 和 <code>stringify</code></li>
<li>利用递归来实现每一层都重新创建对象并赋值</li>
</ol>
<p>首先是第一种：</p>
<ul>
<li><code>JSON.stringify</code> 是将一个<code>JavaScript</code> 值转成一个 <code>JSON</code>字符串。</li>
<li><code>JSON.parse</code> 是将一个<code>JSON</code>字符串转成一个 <code>JavaScript</code> 值或对象。</li>
</ul>
<pre><code>const oriArray = [1,2,3];
const cloneArray = JSON.parse(JSON.stringify(oriArray));
console.log(cloneArray) //[1,2,3]
console.log(cloneObj === originObj); // false 只是看起来一样
cloneArray.push(4)
console.log(cloneArray) //[1,2,3,4]
console.log(oriArray) //[1,2,3]
</code></pre>
<pre><code>const oriObj = {a:'a',b:[1,2,3],c:{c:'c'}};
const cloneObj = JSON.parse(JSON.stringify(oriObj));
console.log(cloneObj); //{a:'a',b:[1,2,3],c:{c:'c'}}
console.log(cloneObj === oriObj) //fasle 
cloneObj.b.push(4); 
console.log(cloneObj); //{a:'a',b:[1,2,3,4],c:{c:'c'}}
console.log(oriObj) //{a:'a',b:[1,2,3],c:{c:'c'}}
</code></pre>
<p>我们发现的确是深拷贝，没有彼此影响<br>
但是这种方法有个弊端，那就是当引用数据类型内部有<code>undefined</code>、<code>function</code>、<code>symbol</code>它们会在转换过程中被忽略。</p>
<pre><code>const oriObj = {
  name:'学习',
  fn:function(){
    console.log('Hello World');
  },
  a:undefined,
  b:Symbol
}
console.log(oriObj); //{name: &quot;学习&quot;, a: undefined, fn: ƒ(), b: ƒ Symbol()}
const cloneObj = JSON.parse(JSON.stringify(oriObj));
console.log(cloneObj); //{name: &quot;学习&quot;}
</code></pre>
<p>是的，转换完就只剩学习了👏。<br>
我的心里只有一件事那就是学习！！!<br>
所以这种方法有一定的局限，但还是很好用的!</p>
<p>第二种：递归</p>
<p>递归的思想就很简单了，就是对每一层的数据都实现一次 <code>创建对象-&gt;对象赋值</code> 的操作</p>
<pre><code>function deepClone(source){
  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象
  for(let keys in source){ // 遍历目标
    if(source.hasOwnProperty(keys)){
      if(source[keys] &amp;&amp; typeof source[keys] === 'object'){ // 如果值是对象，就递归一下
        targetObj[keys] = source[keys].constructor === Array ? [] : {};
        targetObj[keys] = deepClone(source[keys]);
      }else{ // 如果不是，就直接赋值
        targetObj[keys] = source[keys];
      }
    } 
  }
  return targetObj;
}
</code></pre>
<p>我们实验一下：</p>
<pre><code>const oriObj = {
  name:'学习',
  study: {emm:'emmm'},
  fn:function(){
    console.log('Hello World');
  },
  a:undefined,
  b:Symbol
}
let res = deepClone(oriObj)

console.log(oriObj); //{name: &quot;学习&quot;, study: {emm:'emmm'}, a: undefined, fn: ƒ, b: ƒ}
console.log(res) //{name: &quot;学习&quot;, study: {emm:'emmm'}, a: undefined, fn: ƒ, b: ƒ}
console.log(oriObj === res) //false
</code></pre>
<p>不但解决了拷贝问题，还解决了第一种方法的小瑕疵。👍</p>
<h1 id="四-首层深拷贝的几个方法">四、首层深拷贝的几个方法</h1>
<p><strong>首层深拷贝</strong>是指对于多层嵌套的引用类型数据只对深拷贝首层数据,更深层的数据还是浅拷贝</p>
<p><strong>数组</strong><br>
<code>concat</code> 和 <code>slice</code> 是可以实现对原数组的拷贝的，这两个方法都不会修改原数组，而是返回一个修改后的新数组</p>
<pre><code>const originArray = [1,2,3];
const cloneArray = originArray.concat();

console.log(cloneArray === originArray); // false
cloneArray.push(4); // [1,2,3]
console.log(originArray); //[1,2,3];
</code></pre>
<pre><code>const originArray = [1,2,3];
const cloneArray = originArray.slice(0);

console.log(cloneArray === originArray); // false
cloneArray.push(4); // [1,2,3]
console.log(originArray); //[1,2,3];
</code></pre>
<p>以及我们的展开运算符：<code>...</code></p>
<pre><code>const originArray = [1,2,3];
const cloneArray = [...originArray];

console.log(cloneArray === originArray); // false
cloneArray.push(4); // [1,2,3]
console.log(originArray); //[1,2,3];
</code></pre>
<p><strong>对象</strong><br>
<code>Object.assign()</code>方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象，它将返回目标对象。</p>
<pre><code>let obj1 = { a: 0 , b: { c: 0}}
let obj2 = Object.assign({}, obj1)
console.log(JSON.stringify(obj2))
// {&quot;a&quot;:0,&quot;b&quot;:{&quot;c&quot;:0}}
obj1.a = 1
console.log(JSON.stringify(obj1))
// {&quot;a&quot;:1,&quot;b&quot;:{&quot;c&quot;:0}}
console.log(JSON.stringify(obj2))
// {&quot;a&quot;:0,&quot;b&quot;:{&quot;c&quot;:0}}
</code></pre>
<p>这些都只能实现首层深拷贝的方法，虽然功能有限但在合适的场合用起来会事半功倍。</p>
]]></content>
    </entry>
</feed>