<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skrupellose.github.io</id>
    <title>D.C </title>
    <updated>2020-06-08T16:21:20.500Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skrupellose.github.io"/>
    <link rel="self" href="https://skrupellose.github.io/atom.xml"/>
    <subtitle>人类世界真是太有趣了</subtitle>
    <logo>https://skrupellose.github.io/images/avatar.png</logo>
    <icon>https://skrupellose.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, D.C </rights>
    <entry>
        <title type="html"><![CDATA[Scss基础]]></title>
        <id>https://skrupellose.github.io/post/scss-chu-bu-shi-yong/</id>
        <link href="https://skrupellose.github.io/post/scss-chu-bu-shi-yong/">
        </link>
        <updated>2020-06-04T16:11:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-scss介绍">一、Scss介绍</h1>
<p>Sass 是一种 CSS 的预编译语言。它提供了 <code>变量（variables）</code>、<code>嵌套（nested rules）</code>、<code>混合（mixins）</code>、 <code>函数（functions）</code>等功能，并且完全兼容 CSS 语法。Scss 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。</p>
<p>我们在写传统css的时候，经常会写一些重复度较高的代码。这是因为传统css文件缺少变量、函数等概念，但是现在使用Scss之后就可以通过新增的这些概念来达到提高效率的目的</p>
<h1 id="二-基本使用">二、基本使用</h1>
<h2 id="21-嵌套语法">2.1 嵌套语法</h2>
<p>在scss中，我们首先可以使用嵌套语法来写css了，这样可以极大提高文件的可读性，更加直观明了<br>
eg：<br>
css</p>
<pre><code>.box {
   display: float;
}
.box ul {
    list-style: none;
}

</code></pre>
<p>Scss</p>
<pre><code>.box {
    display: float;
    ul {
        list-style: none;
    }
}
</code></pre>
<h2 id="22-父级选择器">2.2 父级选择器</h2>
<p>scss提供了一个父选择器<code>&amp;</code>，用于表示当前元素的父元素<br>
eg:<br>
css</p>
<pre><code>.btn {
    background-color: #fff;
}
.btn  .active {
    background-color: #f00;
}
</code></pre>
<p>Scss</p>
<pre><code>.bth {
    background-color: #fff;
    &amp;.active {
        background-color: #f00;
    }
}
</code></pre>
<p>需要注意的是要在嵌套内部使用父级选择器，不然找不到父级元素会报错</p>
<h2 id="23-嵌套属性规则">2.3 嵌套属性规则</h2>
<p>eg：<br>
css</p>
<pre><code>.box {
    font-family: fantasy;
    font-size: 1.2em;
    font-line-hight: 1.4;
    border-radius: 20px;
    border-color: blue;
}
</code></pre>
<p>Scss</p>
<pre><code>.box {
    font: {
        family: fantasy;
        size: 1.2em;
        line-hight: 1.4;
    }
    border: {
        radius: 20px;
        color: blue;
    }
}
</code></pre>
<h1 id="进阶使用">进阶使用</h1>
<h2 id="31-变量">3.1 变量</h2>
<p>scss中我们可以使用<code>$</code>声明变量</p>
<pre><code>$width ：50px
.box {
    width: $width;
}
</code></pre>
<h2 id="32-数学运算">3.2 数学运算</h2>
<pre><code>.box {
    width: (100+20)*3px;
}
</code></pre>
<h2 id="33-插值">3.3 插值</h2>
<p>我们可以使用插值<code>#{}</code>把变量包裹起来</p>
<pre><code>$sizeKey ： 1
  .font-#{$sizeKey} {
    font-size: 12px
  }

p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};
    // font: 12px/30px;
}
</code></pre>
<h2 id="34-导入文件">3.4 导入文件</h2>
<p>需要使用<code>@import</code></p>
<p><code>@import 'style.scss';</code></p>
<h2 id="35-媒体查询">3.5 媒体查询</h2>
<pre><code>// scss
$media: screen;
$feature: -webkit-min-device-pixel-ratio;
$value: 1.5;
.box{
    @media #{$media} and ($feature: $value) {
      height: 300px;
      width: 900px;
    }
}
</code></pre>
<h2 id="36-继承">3.6 继承</h2>
<p>通过关键字<code>@extend</code>即可完成继承。</p>
<pre><code>.box {
    height: 300px;
    width: 900px;
}
.smallBox {
    @extend .box;
    background: red;
}
// 效果为

.smallBox {
    background: red;
}
.box, .smallBox {
    height: 300px;
    width: 900px;
}
</code></pre>
<h2 id="37-mixin和函数">3.7 mixin和函数</h2>
<p>使用@mixin指令声明一个函数，函数作用域内的属性都是return的值，使用@include使用函数</p>
<pre><code>@mixin border-radius {
    -moz-border-radius: 5px;
    -webkit-border-radius: 5px;
    border-radius: 5px;
}
.box {
    @include border-radius；
}
// 无参数函数使用有点像继承
</code></pre>
<p>函数传参的时候我们还可以设置默认值</p>
<pre><code>@mixin get-border-radius($border-radius: 5px){
    -moz-border-radius: $border-radius;
    -webkit-border-radius: $border-radius;
    border-radius: $border-radius;
}
.box1 {
    @include get-border-radius; 
    //不传参则默认为5px
}
.box2 {
    @include get-border-radius($border-radius:10px); 
    //结果为10px
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http与https]]></title>
        <id>https://skrupellose.github.io/post/http/</id>
        <link href="https://skrupellose.github.io/post/http/">
        </link>
        <updated>2020-04-01T11:28:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-http和https发展历史">一、http和https发展历史</h1>
<p><strong>什么是http？</strong><br>
超文本传输协议，是一种基于请求与响应、无状态的、应用层的协议，长基于tcp/ip协议，互联网上应用最为广泛的一种协议，所有的www文件都必须遵守这个标准。设计http的初衷是为了提供一种发布和接受HTML页面的方法。<br>
<strong>发展历史</strong></p>
<table>
<thead>
<tr>
<th>版本</th>
<th>产生时间</th>
<th>内容</th>
<th>发展现状</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP/0.9</td>
<td>1991年</td>
<td>不涉及数据包的传输，规定客户端和服务器之间通信格式只能GET请求</td>
<td>没有能作为正式的标准</td>
</tr>
<tr>
<td>HTTP/1.0</td>
<td>1996年</td>
<td>传输内容格式不限定，增加了PUT、PATCH、HEAD、OPTIONS、DELETE命令</td>
<td>正式作为标准</td>
</tr>
<tr>
<td>HTTP/1.1</td>
<td>1997年</td>
<td>持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码</td>
<td>2015年前使用最为广泛</td>
</tr>
<tr>
<td>HTTP/2</td>
<td>2015年</td>
<td>多路复用、服务器推送、头信息压缩、二进制协议</td>
<td>逐渐的覆盖市场</td>
</tr>
</tbody>
</table>
<p><strong>多路复用</strong><br>
通过单一的HTTP/2连接请求发起多重请求-响应消息，多个请求流共享一个tcp连接，实现多流并行而不是依赖建立多个tcp连接，大大提高工作效率<br>
<strong>http报文格式</strong></p>
<ul>
<li>请求报文由请求行与首部行组成。请求行内容为<code>请求方法 - URL - 版本</code>组成、首部行是由一个个首部字段名与其对应的值组成的集合以及实体主体信息（GET通常不用）组成的</li>
<li>响应报文由状态行与首部行组成。状态行内容为<code>版本-状态码-短语</code>组成、首部行内容与请求报文相同</li>
</ul>
<p><strong>什么是https？</strong><br>
https是身披SSL外壳的http。https是一种通过计算机网络进行安全通信的传输协议，经由http协议进行通信，利用SSL/TLS建立全信道，加密数据包。https使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私和完整性。<br>
ps：TLS是传输层加密协议，前身是SSL协议，由网景公司于1995年发布。</p>
<h1 id="二-http-vs-https">二、http VS https</h1>
<h1 id="21-http特点">2.1 http特点</h1>
<ol>
<li>无状态：协议对客户端没有状态存储，对事物处理没有记忆能力，比如访问一个网站需要反复进行登录操作</li>
<li>无状态：HTTP/1.1 之前由于无状态的特点，每次请求都需要通过三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次都需要重新响应请求，需要耗费不必要的时间和流量</li>
<li>基于请求和响应：客户端发起请求，服务器响应请求</li>
<li>简单快速、灵活</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li>
</ol>
<h1 id="22-https特点">2.2 https特点</h1>
<p>基于http协议，通过SSL或者TLS提供加密处理数据、验证对方身份以及数据完整性保护</p>
<ol>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li>
<li>验证身份：通过证书验证客户端访问的是自己的服务器</li>
<li>保护数据完整性：防止传输的内容被中间人冒充和修改</li>
<li>接收方能够证实发送方的真实身份</li>
<li>发送方事后不能否认自己发送过的报文</li>
<li>接收方和第三者不能伪造、篡改报文</li>
</ol>
<p><strong>混合加密</strong>：结合对称加密和非对称加密技术，客户端使用对称加密生成密钥对传输的数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，使用网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘钥，即使被截取没有私钥也无法对内容进行解密，无法获取明文数据<br>
<strong>数字摘要</strong>：通过单向的hash函数对原文进行哈希处理，将需要加密的明文”摘要“成一串固定长度的密文，不同明文摘要其密文结果不同，同样的明文其摘要必定一致，并且通过密文不能反推出明文<br>
<strong>数字签名技术</strong>：数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用，它把公钥加密和数字摘要结合起来，形成实用的数字签名技术。</p>
<h1 id="三-http通信传输">三、http通信传输</h1>
<p>客户端通过输入URL回车，DNS解析域名得到服务器的IP地址，服务器在80端口监听客户端的请求，端口通过tcp/ip协议建立连接，http属于tcp/ip模型中的应用层协议，属于通信的过程其实是对应数据的入栈和出栈。<br>
<strong>传输步骤</strong>：</p>
<ol>
<li>三次握手建立tcp连接</li>
<li>浏览器向服务器发送请求命令</li>
<li>浏览器向服务器发送请求头信息，如：user-agent，host之类关于自身的信息，最后发送一个空请求头表示请求头信息发送完毕，如果是post提交，会继续提交请求体</li>
<li>服务器应答，应答的第一部分是版本号与状态码</li>
<li>服务器向客户端发送应答头信息，关于它自己的信息以及客户端之前请求的文档，最后也发送一个空白行表示头信息发送完毕</li>
<li>服务器向客户端发送数据，以Content-Type应答头信息所描述的格式发送用户所请求的数据</li>
<li>四次挥手关闭tcp连接</li>
</ol>
<h1 id="四-https工作流程">四、https工作流程</h1>
<ol>
<li>首先浏览器发送请求访问一个网址，发送的信息主要是随机值1和自己支持的加密算法</li>
<li>服务器收到消息后返回随机值2和一个为浏览器发送过来的所支持加密算法的一个算法子集，之后发送第二个响应报文：CA签字认证并进行加密后的证书，里面包括服务器的公钥和数字签名，数字签名通过CA公钥解密后可以得到证书的信息摘要</li>
<li>浏览器信任CA颁发的证书并且知晓CA的公钥 ，然后去解析验证服务器返回的那个证书，这部分由TLS完成，看公钥是否有效等。浏览器用CA公钥解密证书中的数字签名后得到一个证书的信息摘要，然后再通过CA证书签名的方法对这个摘要进行处理，与接收的签名进行比对，若不同则检验出不匹配。若有异常情况浏览器进行弹窗提醒，若正常就会生成一个随机值3</li>
<li>验证成功之后，浏览器会创建一个通过随机值1、2、3组装成的会话秘钥并且使用服务器返回的公钥进行非对称加密</li>
<li>服务器收到这个加密后的秘钥通过自己的私钥进行解密得到随机值1、2、3，然后组装成会话秘钥之后双方就使用这个会话秘钥对通信进行对称加密</li>
<li>客户端会通过这个会话秘钥加密一条消息发送给服务器，来验证服务器是否可以正常接收客户端的加密消息</li>
<li>服务器也会通过会话秘钥加密一条消息回传给客户端，若客户端也能正常接受就证明SSL层连接建立完成</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React学习笔记]]></title>
        <id>https://skrupellose.github.io/post/react-xue-xi-bi-ji/</id>
        <link href="https://skrupellose.github.io/post/react-xue-xi-bi-ji/">
        </link>
        <updated>2020-03-09T02:30:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="yi">yi</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB笔记]]></title>
        <id>https://skrupellose.github.io/post/mongodb-bi-ji/</id>
        <link href="https://skrupellose.github.io/post/mongodb-bi-ji/">
        </link>
        <updated>2020-03-04T09:54:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-关于mongodb">一、 关于MongoDB</h1>
<p>MongoDB是一个面向文档的数据库管理系统，用C++语言编写。</p>
<h1 id="二-简单上手使用">二、简单上手使用</h1>
<h2 id="21-下载安装">2.1 下载安装</h2>
<p><a href="https://www.mongodb.com/">官网</a><br>
然后正常安装</p>
<h2 id="22-软件使用">2.2 软件使用</h2>
<ol>
<li>
<p>选一个磁盘来存储数据<br>
比如想在D盘存储数据，那么我们就需要在D盘下新建一个<code>data</code>文件夹，再在其中新建<code>db</code>文件夹，这样我们后面数据库的数据就会被保存在<code>db</code>文件夹</p>
</li>
<li>
<p>启动MongoDB<br>
打开CMD，切换到D盘，执行<code>mongod</code>启动命令，然后最小化。</p>
</li>
<li>
<p>操作数据库<br>
输入<code>mongo</code>就可以进行数据库的相关操作</p>
<h2 id="23-一些基本命令">2.3 一些基本命令</h2>
<ol>
<li>切换/创建数据库<br>
<code>use DBname</code></li>
<li>删除当前数据库<br>
<code>db.dropDatabase()</code></li>
<li>查询数据库<br>
<code>show dbs</code></li>
<li>得到当前数据库所有集合<br>
<code>db.getCollectionNames();</code></li>
<li>集合查询所有记录<br>
<code>db.collectionname.find()</code></li>
</ol>
</li>
</ol>
<h2 id="24-node操作mongodb">2.4 Node操作MongoDB</h2>
<pre><code>var mongoose = require ('mongoose')
var Schema = mongoose.Schema

mongoose.connect('mongodb://localhost/dbName',{ useNewUrlParser: true })

var userSchema = new Schema({
  username: {
    type: String,
    required: true
  },
  password: {
    type: String,
    required: true
  }
})

var User = mongoose.model('User', userSchema)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise与相关题型]]></title>
        <id>https://skrupellose.github.io/post/promise/</id>
        <link href="https://skrupellose.github.io/post/promise/">
        </link>
        <updated>2020-03-04T03:31:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-promise">一、Promise</h1>
<h2 id="11-promise概念">1.1 Promise概念</h2>
<h3 id="111-关于promise">1.1.1 关于Promise</h3>
<p>Promise是es6新增的一个API，它本身不是异步的，但是它内部进行封装的往往是异步任务。</p>
<p>Promise容器最开始的状态是<code>Pending</code>，它最后会根据内部任务的成功与否改为<code>Resolved</code>（成功）和<code>Rejected</code>（失败），且不会再次改变状态</p>
<p><strong>Promise容器一旦创建，就开始执行里面的代码</strong></p>
<pre><code>var fs = require('fs')
new Promise(function () {
  fs.readFile('./a.txt','utf8',function(err, data){
    if(err) {
      console.log(err)
    }
    console.log(data)
  })
})
// 就会立马打印出a.txt的内容出来
</code></pre>
<h3 id="112-promise基础语法">1.1.2 Promise基础语法</h3>
<pre><code>var p1 = new Promise(function(resolve, reject) {
  fs.readFile('./a.txt','utf8',function(err, data) {
    if(err) {
      reject(err)
    }
    resolve(data)
  })
})
p1.then(function(data){
  console.log(data)
},function(err){
  console.log(err)
})
</code></pre>
<p>还是刚才的例子我们通过<code>Promise</code>构造函数构造了一个名为p1的<code>Promise</code>实例：<br>
然后在<code>Promise</code>构造函数中传了两个函数作为参数，一个是<code>resolve</code>；一个是<code>reject</code>。<br>
之后在fs.readFile执行后，根据执行结果分别执行<code>reject</code>和<code>resolve</code>方法。<br>
我们想要拿到结果就需要通过构造出的<code>Promise</code>实例的<code>then</code>方法。<br>
<code>then</code>方法也是接受两个函数作为形参，第一个是对应成功时执行；第二个是对应失败后执行。两个方法分别对应上面的<code>resolve</code>和<code>reject</code>。</p>
<p>关于then方法的链式调用需要介绍：<br>
当then方法执行完之后return一个对象，我们就可以对这个对象进行处理，当我们面对回调嵌套的时候就可以使用Promise。</p>
<pre><code>p1.then(function(data){
  console.log(data)
  return p2
}).then(function(data) {
  console.log(data)
  return p3
}).then(function(data){
  console.log(data)
})
</code></pre>
<p>then方法的第一个形参就是调用then方法的实例的resolve方法。<br>
如果return的是一个简单数据类型，那么充当then方法的形参的那个方法就能获取的这个值。</p>
<h1 id="二-promise基础题型">二、promise基础题型</h1>
<h2 id="21-题目1">2.1 题目1</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  console.log(2);
});
promise.then(() =&gt; {
  console.log(3);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li>结果并不是<code>1 2 4 3</code></li>
<li>虽然promise.then属于微任务，但是前面新建的promise对象过程中并没有改变状态。因此promise.then并不会执行</li>
<li>所以执行结果为<code>1 2 4</code></li>
</ul>
<h2 id="22-题目2">2.2 题目2</h2>
<pre><code>const promise1 = newPromise((resolve, reject) =&gt; {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res =&gt; {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);
</code></pre>
<p>tips：</p>
<ul>
<li>第一轮宏任务首先执行<code>promise1</code></li>
<li>然后将<code>promise1</code>的状态修改为<code>resolved</code>，然后保存结果</li>
<li>把<code>promise2</code>放入微任务队列，等待执行</li>
<li>接着执行同步代码1，结果为<code>resolved</code></li>
<li>然后执行同步代码2，结果为<code>pending</code>，因为此时<code>promise2</code>被放入微任务队列还没执行，promise状态为<code>pending</code><br>
所以结果为:</li>
</ul>
<pre><code>'promise1'
'1' Promise{&lt;resolved&gt;: 'resolve1'}
'2' Promise{&lt;pending&gt;}
'resolve1'
</code></pre>
<h2 id="23-题目3">2.3 题目3</h2>
<pre><code>const fn = () =&gt;(new Promise((resolve, reject) =&gt; {
  console.log(1);
  resolve('success')
}))
fn().then(res =&gt; {
  console.log(res)
})
console.log('start')
</code></pre>
<p>tips：</p>
<ul>
<li>首先执行<code>fn</code>函数，它返回一个promise对象，并且将状态修改为<code>resolved</code>，因此首先打印1</li>
<li>然后将<code>.then()</code>放入微任务队列</li>
<li>接着执行同步任务打印<code>start</code></li>
<li>之后执行任务.then()，打印<code>success</code><br>
所以结果为：</li>
</ul>
<pre><code>1
start
success
</code></pre>
<h1 id="三-promise结合定时器">三、promise结合定时器</h1>
<h2 id="31-题目1">3.1 题目1</h2>
<pre><code>console.log('start')
setTimeout(() =&gt; {
  console.log('time')
})
Promise.resolve().then(() =&gt; {
  console.log('resolve')
})
console.log('end')
</code></pre>
<p>tips:</p>
<ul>
<li>首先按照执行顺序，打印<code>start</code></li>
<li>然后遇到定时器将其放入下一个宏任务队列</li>
<li>将<code>promise.then()</code>也放入微任务队列</li>
<li>打印<code>end</code></li>
<li>执行<code>promise.then</code>打印resolve</li>
<li>执行定时器打印<code>time</code></li>
<li>这里还需要注意的是<code>Promise.resolve()</code>相当于定义一个状态为<code>fullfilled</code>的<code>promise</code>，只有<code>fullfilled</code>状态的<code>promise</code>才能执行<code>.then()</code><br>
执行结果：</li>
</ul>
<pre><code>start
end
resolve
time
</code></pre>
<h2 id="32-题目2">3.2 题目2</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  setTimeout(() =&gt; {
    console.log(&quot;timerStart&quot;);
    resolve(&quot;success&quot;);
    console.log(&quot;timerEnd&quot;);
  }, 0);
  console.log(2);
});
promise.then((res) =&gt; {
  console.log(res);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li>首先打印<code>1</code></li>
<li>然后将定时器加入下次宏任务队列</li>
<li>打印<code>2</code></li>
<li>将<code>promise.then</code>加入微任务队列</li>
<li>打印<code>4</code></li>
<li>暂不执行<code>promise.then()</code>，虽然此时应该执行微任务中的<code>.then()</code>,但此时<code>promise</code>状态还为<code>pending</code>，所以不执行</li>
<li>最后开始执行宏任务里的定时器打印出timerstart，修改promise状态为<code>resolved</code>，打印<code>timerend</code></li>
<li>此时promise状态已为<code>resolved</code>，开始执行微任务中的<code>.then()</code>，打印出<code>success</code><br>
执行结果：</li>
</ul>
<pre><code>1
2
4
timerstart
timerend
success
</code></pre>
<h2 id="33-题目3">3.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  console.log('promise1');
  const timer2 = setTimeout(() =&gt; {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() =&gt; {
  console.log('timer1')
  Promise.resolve().then(() =&gt; {
    console.log('promise2')
  })
}, 0)
console.log('start');
</code></pre>
<p>tips:</p>
<ul>
<li>首先把<code>promise.then()</code>放入微任务队列</li>
<li>将<code>timer1</code>放入宏任务队列</li>
<li>打印<code>start</code></li>
<li>执行微任务中的<code>promise.then()</code></li>
<li>打印<code>promise1</code></li>
<li>将<code>timer2</code>放入宏任务队列</li>
<li>执行<code>timer1</code>，打印<code>timer1</code>，将第二个<code>promise.then()</code>放入微任务队列</li>
<li>执行第二个<code>promise.then()</code>，打印<code>promise2</code></li>
<li>执行<code>timer2</code>，打印<code>timer2</code></li>
</ul>
<p>执行结果</p>
<pre><code>start
promise1
timer1
promise2
timer2
</code></pre>
<h2 id="34-题目4">3.4 题目4</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() =&gt; {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() =&gt; {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)
</code></pre>
<p>tips:</p>
<ul>
<li>首先执行<code>promise1</code>，将定时器放入宏任务队列</li>
<li>把<code>promise2</code>放入微任务队列</li>
<li>执行同步代码，打印<code>promise1</code>，此时<code>promise1</code>还未改变状态，所以为<code>pending</code></li>
<li>执行同步代码，打印<code>promise2</code>，由于<code>promise1.then()</code>返回的还是一个<code>promise</code>对象，所以为<code>pending</code></li>
<li>将定时器放入宏任务队列</li>
<li><code>promise2</code>暂不执行，因为<code>p1</code>的状态还未修改</li>
<li>执行第一个定时器，将<code>promise1</code>状态修改为<code>resolved</code></li>
<li>执行<code>p2</code>，<code>throw</code>一个错误<code>error</code></li>
<li>执行第二个定时器，打印<code>resolved和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<h2 id="35-题目5">3.5 题目5</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;success&quot;);
    console.log(&quot;timer1&quot;);
  }, 1000);
  console.log(&quot;promise1里的内容&quot;);
});
const promise2 = promise1.then(() =&gt; {
  throw new Error(&quot;error!!!&quot;);
});
console.log(&quot;promise1&quot;, promise1);
console.log(&quot;promise2&quot;, promise2);
setTimeout(() =&gt; {
  console.log(&quot;timer2&quot;);
  console.log(&quot;promise1&quot;, promise1);
  console.log(&quot;promise2&quot;, promise2);
}, 2000);
</code></pre>
<p>tips：</p>
<ul>
<li>执行<code>p1</code>，将第一个定时器放入宏任务队列，并打印<code>p1</code>里的内容</li>
<li>把<code>p2</code>放入微任务队列</li>
<li>执行同步代码，打印两个<code>pending</code></li>
<li>把第二个定时器加入宏任务队列</li>
<li>p1状态未修改暂不执行p2</li>
<li>执行第一个定时器修改p1的状态并打印<code>timer1</code></li>
<li>执行微任务throw一个错误修改p2状态为<code>rejected</code></li>
<li>执行第二个定时器，打印<code>timer2</code>后分别打印<code>resolved:success和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1里的内容'
'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
'timer1'
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'timer2'
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<h1 id="四-promise进阶">四、promise进阶</h1>
<h2 id="41-题目1">4.1 题目1</h2>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
  reject(&quot;error&quot;);
  resolve(&quot;success2&quot;);
});
promise
.then(res =&gt; {
    console.log(&quot;then1: &quot;, res);
  }).then(res =&gt; {
    console.log(&quot;then2: &quot;, res);
  }).catch(err =&gt; {
    console.log(&quot;catch: &quot;, err);
  }).then(res =&gt; {
    console.log(&quot;then3: &quot;, res);
  })
</code></pre>
<p>tips：</p>
<ul>
<li>promise状态一经改变便不会再次改变，所以promise状态为<code>rejected</code></li>
<li>之后将<code>promise.then()</code>加入微任务队列</li>
<li>直到被<code>catch</code>捕获错误，<code>catch</code>不论连接在哪里都可以捕获到上级错误</li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;catch: &quot; &quot;error&quot;
&quot;then3: &quot; undefined
</code></pre>
<h2 id="42-题目2">4.2 题目2</h2>
<pre><code>Promise.resolve(1)
  .then(res =&gt; {
    console.log(res);
    return2;
  })
  .catch(err =&gt; {
    return3;
  })
  .then(res =&gt; {
    console.log(res);
  });
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve(1)</code>内部返回的结果是1，打印得到1</li>
<li><code>return2</code>被包装成为<code>resolve(2)</code>，所以该<code>promise</code>对象返回值为2</li>
<li><code>resolve</code>下不走<code>catch</code>，<code>.then</code>打印得到<code>2</code></li>
</ul>
<h2 id="43-题目3">4.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  return new Error('error!!!')
}).then(res =&gt; {
  console.log(&quot;then: &quot;, res)
}).catch(err =&gt; {
  console.log(&quot;catch: &quot;, err)
})
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve().then()</code>return一个错误,当promise对象返回的不是一个promise对象的话就会被包装成一个promise对象，<code>return new Error('error!!!')</code>会被包装成<code>return Promise.resolve(new Error('error!!!'))</code></li>
<li>因此走的是.then()而不是.catch()</li>
<li>若想抛出错误，可以<code>return Promise.reject(newError('error!!!'));</code>或者<code>throw newError('error!!!')</code></li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;then: &quot; &quot;Error: error!!!&quot;
</code></pre>
<h2 id="44-题目4">4.4 题目4</h2>
<pre><code>const promise = Promise.resolve().then(() =&gt; {
  return promise;
})
promise.catch(console.err)
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>或者<code>.catch()</code>不能返回promise自身</li>
<li>所以会报错</li>
</ul>
<p>执行结果：</p>
<pre><code>Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
</code></pre>
<h2 id="45-题目5">4.5 题目5</h2>
<pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre>
<p>tips：</p>
<ul>
<li><code>promise.then()</code>和<code>.catch()</code>的期望值是函数</li>
<li>传入非函数就会发生值传透</li>
<li>第一个<code>then</code>传的是数字</li>
<li>第二个<code>then</code>传的是对象</li>
<li>所以第三个<code>then</code>获取的值是<code>1</code></li>
</ul>
<p>执行结果：</p>
<pre><code>1
</code></pre>
<h2 id="46-题目6">4.6 题目6</h2>
<pre><code>Promise.reject('err!!!')
  .then((res) =&gt; {
    console.log('success', res)
  }, (err) =&gt; {
    console.log('error', err)
  }).catch(err =&gt; {
    console.log('catch', err)
  })
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>有两个参数，一个是用来处理<code>promise</code>成功的函数，另一个是处理失败的函数</li>
<li>当有处理失败函数的时候，错误会走失败的函数而不会走.catch()</li>
</ul>
<p>执行结果：</p>
<pre><code>'error' 'error!!!'
</code></pre>
<ul>
<li>若不写第二个函数，则会走<code>.catch()</code>函数</li>
<li>若在执行成功的函数中抛出一个错误，则该错误只能在<code>.catch()</code>中捕获到，不能在第二个处理错误的函数中被捕获</li>
</ul>
<h2 id="47-题目7">4.7 题目7</h2>
<pre><code>Promise.resolve('1')
  .then(res =&gt; {
    console.log(res)
  })
  .finally(() =&gt; {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() =&gt; {
    console.log('finally2')
  	return'我是finally2返回的值'
  })
  .then(res =&gt; {
    console.log('finally2后面的then函数', res)
  })
</code></pre>
<p>tips:</p>
<ul>
<li>第一个<code>promise</code>修改状态为<code>resolved</code>并得到返回值<code>1</code></li>
<li>将<code>.then()</code>移入微任务队列</li>
<li>因为<code>.then()</code>和<code>.finally()</code>是链式调用，<code>.then()</code>不执行，<code>.finally()</code>也不会执行，所以这里会跳出第一个promise函数</li>
<li>第二个promise修改状态为<code>resolved</code>并得到返回值<code>2</code></li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>将第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.then()</code>移入微任务队列</li>
<li>开始执行第一个<code>.then()</code>,得到1</li>
<li>执行第二个<code>.finally()</code>,打印<code>finally2</code>，且返回一个新的值</li>
<li>执行第一个<code>.finally()</code>,打印<code>finally</code></li>
<li>执行第二个<code>.then()</code>,打印结果2，因为<code>.finally()</code>默认返回的都是原来的<code>promise</code>对象的值，只有当抛出的是一个错误，才会返回这个错误*</li>
</ul>
<p>执行结果：</p>
<pre><code>1
finally2
finally
finally2后面的then函数 2
</code></pre>
<p>*:</p>
<pre><code>Promise.resolve('1')
  .finally(() =&gt; {
    console.log('finally1')
    throw new Error('我是finally中抛出的异常')
  })
  .then(res =&gt; {
    console.log('finally后面的then函数', res)
  })
  .catch(err =&gt; {
    console.log('捕获错误', err)
  })
</code></pre>
<pre><code>'finally1'
'捕获错误' Error: 我是finally中抛出的异常
</code></pre>
<h2 id="48-题目8">4.8 题目8</h2>
<pre><code>function promise1 () {
  let p = new Promise((resolve) =&gt; {
    console.log('promise1');
    resolve('1')
  })
  return p;
}
function promise2 () {
  return new Promise((resolve, reject) =&gt; {
    reject('error')
  })
}
promise1()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally1'))

promise2()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally2'))
</code></pre>
<p>tips:</p>
<ul>
<li><code>p1</code>执行，打印<code>promise1</code>，并且修改<code>promise1</code>状态值为<code>resolved</code>，返回<code>1</code></li>
<li>把第一个<code>.then()</code>移入微任务队列</li>
<li>执行<code>p2</code>，返回一个<code>rejected</code>状态的<code>promise</code>对象，返回值为<code>error</code></li>
<li>因为<code>p2</code>状态为<code>rejected</code>，所以第二个<code>.then()</code>不会执行将第二个<code>.catch</code>移入微任务队列</li>
<li>执行第一个<code>.then()</code>，打印<code>1</code></li>
<li>执行第二个<code>.catch()</code>, 打印<code>error</code></li>
<li>之后把第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>执行第一个<code>.finally()</code>，打印<code>finally1</code></li>
<li>执行第二个<code>.finally()</code>，打印<code>finally2</code></li>
</ul>
<p>执行结果：</p>
<pre><code>promise1
1
error
finally1
finally2
</code></pre>
<h2 id="49-题目9">4.9 题目9</h2>
<pre><code>function runAsync (x) {
	const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
	return p
}
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt;console.log(res))
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.all(</code>)并行执行多个异步操作，并在一个回调中处理所有的数据</li>
</ul>
<p>执行结果：</p>
<pre><code>1
2
3
[1, 2, 3]
</code></pre>
<h2 id="410-题目10">4.10 题目10</h2>
<pre><code>function runAsync (x) {
  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
  return p
}
function runReject (x) {
  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.all()</code>中参数的顺序就是加入任务队列的顺序，但是定时器执行先后由时间长短排序</li>
<li>所以执行顺序为<code>runAsync(1)</code>、 <code>runAsync(3)</code>、 <code>runReject(2)</code>、<code>runReject(4)</code></li>
<li>又因为<code>runReject</code>函数抛出错误，所以<code>promise.all().then()</code>不会执行，而<code>.catch()</code>会捕获<code>.all()</code>之中最先的异常</li>
</ul>
<p>执行结果：</p>
<pre><code>1
3
// 2s后输出
2
Error: 2
// 4s后输出
4
</code></pre>
<h2 id="411-题目11">4.11 题目11</h2>
<pre><code>function runAsync (x) {
const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
return p
}
Promise.race([runAsync(1), runAsync(2), runAsync(3)])
.then(res =&gt;console.log('result: ', res))
.catch(err =&gt;console.log(err))
</code></pre>
<p>tips：</p>
<ul>
<li><code>.race()</code>只会获取最先执行完的结果</li>
</ul>
<p>执行结果：</p>
<pre><code>1
'result: ' 1
2
3
</code></pre>
<h1 id="五-async和await">五、async和await</h1>
<h2 id="51-题目1">5.1 题目1</h2>
<pre><code>async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
}
async function async2() {
  console.log(&quot;async2&quot;);
}
async1();
console.log('start')
</code></pre>
<p>tips：</p>
<ul>
<li><code>async1</code>函数执行，打印<code>async1 start</code></li>
<li>执行<code>async2</code>函数，打印<code>async2</code></li>
<li>跳出<code>async1</code>，打印<code>start</code></li>
<li>再打印<code>async1 end</code></li>
<li><code>await</code>后面的内容将放到下一次执行，类似于<code>promise.then()</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'async start'
'promise'
'async1 end'
'start'
</code></pre>
<h2 id="52-题目2">5.2 题目2</h2>
<pre><code>async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
}
async function async2() {
  setTimeout(() =&gt; {
    console.log('timer')
  }, 0)
  console.log(&quot;async2&quot;);
}
async1();
console.log(&quot;start&quot;)
</code></pre>
<p>tips:</p>
<ul>
<li>与上一道题不同的是async2函数内多了一个定时器，定时器会被放到下一次宏任务中执行</li>
</ul>
<p>执行结果：</p>
<pre><code>async1 start
async2
start
async1 end
timer
</code></pre>
<h2 id="53-题目3">5.3 题目3</h2>
<pre><code>async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
  setTimeout(() =&gt; {
    console.log('timer1')
  }, 0)
}
async function async2() {
  setTimeout(() =&gt; {
    console.log('timer2')
  }, 0)
  console.log(&quot;async2&quot;);
}
async1();
setTimeout(() =&gt; {
  console.log('timer3')
}, 0)
console.log(&quot;start&quot;)
</code></pre>
<p>tips：</p>
<ul>
<li><code>async1</code>函数执行，打印<code>async1 start</code></li>
<li><code>async2</code>函数执行，将<code>timer2</code>移入宏任务队列，然后打印<code>async2</code></li>
<li>将<code>timer3</code>移入宏任务队列</li>
<li>打印<code>start</code></li>
<li>打印<code>async1 end</code>并且将<code>timer1</code>移入宏任务队列</li>
<li>执行第一个宏任务，打印<code>timer2</code>，微任务队列没有任务，将剩下的两个宏任务依次执行打印<code>timer3</code>和<code>timer1</code></li>
</ul>
<p>执行结果：</p>
<pre><code>async1 start
async2
start
async1 end
timer2
timer3
timer1
</code></pre>
<h2 id="54-题目4">5.4 题目4</h2>
<pre><code>async function async1 () {
  console.log('async1 start');
  await new Promise(resolve =&gt; {
    console.log('promise1')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('script start')
async1().then(res =&gt;console.log(res))
console.log('script end')
</code></pre>
<p>tips:</p>
<ul>
<li>打印<code>script start</code></li>
<li><code>async1</code>执行</li>
<li>打印<code>async1 start</code></li>
<li>新创建一个<code>promise</code>对象，打印<code>promise1</code></li>
<li>将<code>.then()</code>加入微任务队列</li>
<li>打印<code>script end</code></li>
<li>由于新创建的<code>promise</code>对象并没有改变状态，所以<code>.then()</code>不会执行，<code>await</code>后面的内容也不会执行</li>
</ul>
<p>执行结果：</p>
<pre><code>'script start'
'async1 start'
'promise1'
'script end'
</code></pre>
<h2 id="55-题目5">5.5 题目5</h2>
<pre><code>async function async1 () {
  console.log('async1 start');
  await new Promise(resolve =&gt; {
    console.log('promise1')
    resolve('promise1 resolve')
  }).then(res =&gt;console.log(res))
  console.log('async1 success');
  return 'async1 end'
}
console.log('script start')
async1().then(res =&gt;console.log(res))
console.log('script end')
</code></pre>
<p>tips:</p>
<ul>
<li>打印<code>script start</code></li>
<li><code>async1</code>执行，打印<code>async1 start</code></li>
<li>新建一个<code>promise</code>对象，打印<code>promise1</code>，修改状态为<code>resolved</code>，返回值为<code>promise1 resolve</code></li>
<li>打印<code>script end</code></li>
<li>执行<code>.then()</code></li>
<li>打印<code>async1 success</code></li>
<li>修改<code>promise</code>返回值为<code>async1 end</code></li>
<li>执行第二个<code>.then()</code>，打印<code>async1 end</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'script start'
'async1 start'
'promise1'
'script end'
'promise1 resolve'
'async1 success'
'async1 end'
</code></pre>
<h2 id="56-题目6">5.6 题目6</h2>
<pre><code>async function testSometing() {
  console.log(&quot;执行testSometing&quot;);
  return&quot;testSometing&quot;;
}

async function testAsync() {
  console.log(&quot;执行testAsync&quot;);
  return Promise.resolve(&quot;hello async&quot;);
}

async function test() {
  console.log(&quot;test start...&quot;);
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
}

test();

var promise = newPromise(resolve =&gt; {
  console.log(&quot;promise start...&quot;);
  resolve(&quot;promise&quot;);
});
promise.then(val =&gt;console.log(val));

console.log(&quot;test end...&quot;);
</code></pre>
<p>tips:</p>
<ul>
<li>执行<code>test</code>函数，打印<code>test start</code></li>
<li>执行<code>testSomething</code>函数，打印<code>执行testSomething</code></li>
<li>跳出<code>test</code>函数，打印<code>promise start</code>并且修改promise的值和状态</li>
<li>将<code>.then()</code>加入微任务队列</li>
<li>打印<code>test end</code></li>
<li>打印<code>v1</code>的值 <code>testSomething</code></li>
<li>执行<code>testAsync</code>函数，打印<code>执行testAsync</code></li>
<li>跳出<code>tes</code>t函数，执行微任务的<code>.then()</code>,打印<code>promise</code></li>
<li>打印<code>v2</code>的值<code>hello async</code></li>
<li>打印<code>v1</code>、<code>v2</code>的值</li>
</ul>
<pre><code>'test start...'
'执行testSometing'
'promise start...'
'test end...'
'testSometing'
'执行testAsync'
'promise'
'hello async'
'testSometing' 'hello async'
</code></pre>
<h2 id="57-题目7">5.7 题目7</h2>
<pre><code>async function async1 () {
  await async2();
  console.log('async1');
  return 'async1 success'
}
async function async2 () {
  return new Promise((resolve, reject) =&gt; {
    console.log('async2')
    reject('error')
  })
}
async1().then(res =&gt;console.log(res))
</code></pre>
<p>tips:</p>
<ul>
<li><code>async</code>函数中抛出了错误，则不会往下继续执行</li>
<li><code>throw new Error</code>是一样的效果</li>
</ul>
<p>执行结果：</p>
<pre><code>'async2'
Uncaught (in promise) error
</code></pre>
<h2 id="58-题目8">5.8 题目8</h2>
<pre><code>async function async1 () {
  try {
    await Promise.reject('error!!!')
  } catch(e) {
    console.log(e)
  }
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res =&gt;console.log(res))
console.log('script start')
</code></pre>
<p>tips:</p>
<ul>
<li>若不想错误影响函数后面的执行则可以使用<code>try catch</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'script start'
'error!!!'
'async1'
'async1 success'
</code></pre>
<p>或者在<code>Promise.reject</code>后面跟着一个<code>catch()</code>方法</p>
<pre><code>async function async1 () {
   await Promise.reject('error!!!')
        .catch(e =&gt;console.log(e))
   console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res =&gt;console.log(res))
console.log('script start')
</code></pre>
<h1 id="六-综合题">六、综合题</h1>
<h2 id="61-题目1">6.1 题目1</h2>
<pre><code>const first = () =&gt;(new Promise((resolve, reject) =&gt; {
    console.log(3);
    let p = new Promise((resolve, reject) =&gt; {
        console.log(7);
        setTimeout(() =&gt; {
            console.log(5);
            resolve(6);
          	console.log(p)
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) =&gt; {
        console.log(arg);
    });

}));

first().then((arg) =&gt; {
    console.log(arg);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li><code>first</code>函数执行，打印<code>3</code></li>
<li>新建第二个<code>promise</code>对象，打印<code>7</code>，将定时器移入宏任务队列，并且修改值和状态为<code>1</code>和<code>resolved</code></li>
<li>将第一个<code>promise</code>对象的值和状态修改为<code>2</code>和<code>resolved</code></li>
<li>将<code>p.then()</code>移入微任务队列</li>
<li>将<code>first.then()</code>移入微任务队列</li>
<li>打印<code>4</code></li>
<li>执行<code>p.then()</code>打印<code>1</code></li>
<li>执行<code>first.then()</code>打印<code>2</code></li>
<li>最后执行宏任务里的定时器</li>
<li>打印<code>5</code>，修改<code>p</code>的状态和返回值，但是<code>p</code>的状态已经改变过了，所以不会再改变，打印<code>Promise{&lt;resolved&gt;: 1}</code></li>
</ul>
<p>执行结果：</p>
<pre><code>3
7
4
1
2
5
Promise{&lt;resolved&gt;: 1}
</code></pre>
<h2 id="62-题目2">6.2 题目2</h2>
<pre><code>const async1 = async () =&gt; {
  console.log('async1');
  setTimeout(() =&gt; {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve =&gt; {
    console.log('promise1')
    resolve(2)
  })
  console.log('async1 end')
  return 'async1 success'
}
console.log('script start');
async1().then(res =&gt;console.log(res));
console.log('script end');
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res =&gt;console.log(res))
setTimeout(() =&gt; {
  console.log('timer2')
}, 1000)
</code></pre>
<p>tips:</p>
<ul>
<li>打印<code>script start</code></li>
<li>执行<code>async1</code>函数，打印<code>async1</code>，将<code>timer1</code>移入宏任务队列</li>
<li>新创建一个<code>promise</code>对象，打印<code>promise1</code></li>
<li>跳出<code>async1</code>，打印<code>script end</code></li>
<li>获得一个状态为<code>resolved</code>且值为<code>1</code>的<code>promise</code>对象，由于发生值穿透，直接将最后一个<code>.then()</code>加入微任务队列</li>
<li>将<code>timer2</code>移入宏任务队列</li>
<li>new 的promise对象没有修改状态，所以下面的程序不会执行</li>
<li>把<code>async1().then()</code>加入微任务队列，依次执行两个微任务,又因为<code>async1</code>函数中的<code>promise</code>对象状态还是<code>pending</code>，所以<code>async1().then()</code>不执行</li>
<li>两个定时器按照时间执行</li>
</ul>
<p>执行结果:</p>
<pre><code>'script start'
'async1'
'promise1'
'script end'
1
'timer2'
'timer1'
</code></pre>
<p>若new的promise对象修改了状态，则执行结果就是：</p>
<pre><code>'script start'
'async1'
'promise1'
'script end'
'async1 end'
'async1 success'
1
'timer2'
'timer1'
</code></pre>
<h2 id="63-题目3">6.3 题目3</h2>
<pre><code>const p1 = new Promise((resolve) =&gt; {
  setTimeout(() =&gt; {
    resolve('resolve3');
    console.log('timer1')
  }, 0)
  resolve('resovle1');
  resolve('resolve2');
}).then(res =&gt; {
  console.log(res)
  setTimeout(() =&gt; {
    console.log(p1)
  }, 1000)
}).finally(res =&gt; {
  console.log('finally', res)
})
</code></pre>
<p>tips:</p>
<ul>
<li>将timer1移入宏任务</li>
<li>修改promise状态为resolved，值修改为resolve1</li>
<li>将.then()移入微任务队列</li>
<li>将第二个定时器移入宏任务队列</li>
<li>将.finally()移入微任务队列</li>
<li>执行.then()，打印resolve1</li>
<li>执行.finally()，由于.finally()的回调函数不接受参数，所以为undefined</li>
<li>执行定时器1，打印timer1</li>
<li>执行定时器2，此时通过链式调用，返回值已经变成undefined</li>
</ul>
<p>执行结果：</p>
<pre><code>'resolve1'
'finally' undefined
'timer1'
Promise{&lt;resolved&gt;: undefined}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[flex布局的使用]]></title>
        <id>https://skrupellose.github.io/post/flex-bu-ju-de-shi-yong/</id>
        <link href="https://skrupellose.github.io/post/flex-bu-ju-de-shi-yong/">
        </link>
        <updated>2020-01-07T05:10:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-认识flex布局">一、认识flex布局</h1>
<p>flex布局已经成为了web开发中使用最多的布局方案</p>
<h2 id="11-两个概念">1.1 两个概念</h2>
<ul>
<li>开启了flex布局的元素叫<code>flex container</code></li>
<li><code>flex container</code>里面的直接子元素叫做<code>flex items</code></li>
</ul>
<h2 id="12-如何开启flex布局">1.2 如何开启flex布局</h2>
<p>设置display属性为flex或者inline-flex可以成为flex container</p>
<ul>
<li>flex：flex container以block-level形式存在</li>
<li>inline-flex：flex container以inline-level形式存在</li>
</ul>
<h1 id="二-flex布局模型">二、flex布局模型</h1>
<figure data-type="image" tabindex="1"><img src="https://skrupellose.github.io/post-images/1578374921989.png" alt="" loading="lazy"></figure>
<h2 id="2flex相关属性">2.flex相关属性</h2>
<h3 id="21-应用在flex-container上的css属性">2.1 应用在flex container上的css属性</h3>
<ul>
<li>flex-flow</li>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<p><code>flex items</code>默认都是沿着<code>main axis</code>(主轴)从<code>main start</code>开始往<code>main end</code>方向排布</p>
<h3 id="211-flex-direction决定了main-axis的方向有四个取值row默认-row-reverse-column-column-reverse">2.1.1 <code>flex-direction</code>决定了<code>main axis</code>的方向，有四个取值：<code>row</code>(默认)、<code>row-reverse</code>、<code>column</code>、<code>column-reverse</code></h3>
<h3 id="212-justify-content决定flex-items的主轴mian-axis对齐方式取值">2.1.2 <code>justify-content</code>决定<code>flex items</code>的主轴(mian axis)对齐方式，取值：</h3>
<ul>
<li>flex-start：与main start对齐</li>
<li>flex-end：与 main end对齐</li>
<li>center：居中对齐</li>
<li>space-between：flex items之间距离相等且与main start、main end两端对齐</li>
<li>space-evenly：flex items之间距离相等且与main start、main end等距</li>
<li>space-around：flex items与main start、main end之间的距离是flex items之间距离的一半</li>
</ul>
<p>若<code>flex items</code>不设置高度，那么默认情况下它的高度就是<code>cross size</code></p>
<h3 id="213-align-items决定了flex-items的交叉轴cross-axis上的对齐方式取值">2.1.3 <code>align-items</code>决定了<code>flex items</code>的交叉轴(cross axis)上的对齐方式,取值：</h3>
<ul>
<li>normal：弹性布局中，效果与stretch一样</li>
<li>stretch：当flex items在cross axis方向的size为auto时，会自动拉伸至填充flex container</li>
<li>flex-start：在交叉轴的起点对齐</li>
<li>flex-end：在交叉轴的终点对齐</li>
<li>center：在交叉轴的中点对齐</li>
<li>baseline：基准线对齐</li>
</ul>
<p>默认情况下所有的flex items会在同一行显示，放不下的会进行收缩然后在同行显示</p>
<h3 id="214-flex-wrap决定了flex-container是单行还是多行用于控制换行取值">2.1.4 <code>flex-wrap</code>决定了flex container是单行还是多行用于控制换行，取值：</h3>
<ul>
<li>normal：默认（单行）</li>
<li>wrap：多行</li>
<li>warp-reverse：多行（对比wrap，cross start和cross end相反）</li>
</ul>
<h3 id="215-flex-flow是flex-directionflex-wrap的简写">2.1.5 <code>flex-flow</code>是flex-direction||flex-wrap的简写</h3>
<ul>
<li>可以省略，顺序随意</li>
</ul>
<h3 id="216-align-content决定了多行flex-items在交叉轴上的对齐方式用法与just-content类似取值">2.1.6 <code>align-content</code>决定了多行flex items在交叉轴上的对齐方式，用法与<code>just-content</code>类似，取值：</h3>
<ul>
<li>flex-start：与cross start对齐</li>
<li>flex-end：与cross end对齐</li>
<li>center：居中对齐</li>
<li>space-between：flex items之间距离相等且与cross start、cross end两端对齐</li>
<li>space-evenly：flex items之间距离相等且与cross start、cross end等距</li>
<li>space-around：flex items与cross start、cross end之间的距离是flex items之间距离的一半</li>
</ul>
<h3 id="22-应用在flex-items上的css属性">2.2 应用在flex items上的css属性</h3>
<ul>
<li>flex</li>
<li>flex-grow</li>
<li>flex-basis</li>
<li>flex-shrink</li>
<li>order</li>
<li>align-self</li>
</ul>
<h3 id="221-order决定了flex-items的排布顺序">2.2.1 <code>order</code>决定了flex items的排布顺序</h3>
<ul>
<li>可以设置成任意整数，数值越小越靠前</li>
<li>默认值是0</li>
</ul>
<h3 id="222-align-self单独决定flex-item的排布顺序通过覆盖flex-container设置的align-items">2.2.2 <code>align-self</code>单独决定flex item的排布顺序（通过覆盖flex container设置的align-items）</h3>
<ul>
<li>auto（默认值）：遵从flex container的align-items设置</li>
<li>stretch、flex-start、flex-end、center、baseline，效果与align-items一致</li>
</ul>
<h3 id="223-flex-grow决定了flex-items如何扩展">2.2.3 <code>flex-grow</code>决定了flex items如何扩展</h3>
<ul>
<li>可以设置成任意非负数字（正小数、正整数、0），默认是0</li>
<li>当flex container在主轴方向有剩余的size的时候，flex-grow属性才会生效</li>
<li>如果所有flex items的flex-grow总和sum超过1，每个flex item扩展的size为：flex container剩余的size * flex-grow / sum</li>
<li>如果所有的flex items的flex-grow总和sum没有超过1，每个flex item扩展的size为：flex container的剩余size * flex-grow</li>
<li>flex items扩展后的最终size不能超过max-width/max-height</li>
</ul>
<h3 id="224-flex-shrink决定了flex-items如何收缩">2.2.4 <code>flex-shrink</code>决定了flex items如何收缩</h3>
<ul>
<li>可以设置成任意非负数字（正小数、正整数、0），默认是1</li>
<li>当flex items在主轴方向上的size超过了flex container的size，flex-shrink超会生效</li>
<li>如果所有的flex items的flex-shrink总和超过1，每个flex items的收缩的size为：flex items超出的flex items超出flex container的size * 收缩比例 / 所有flex items收缩比例之和</li>
<li>如果所有的flex items的flex-shrink总和不超过1，每个flex items收缩的size为：flex items超出的flex container的size * flex-shrink值</li>
<li>flex items收缩之和最终size不能小于min-width/min-height</li>
</ul>
<h3 id="225-flex-basis设置flex-items在主轴方向上的base-size">2.2.5 <code>flex-basis</code>设置flex items在主轴方向上的base size</h3>
<ul>
<li>auto 默认值、具体的宽度数值</li>
<li>决定flex items最终base size的因素，从优先级高到低：<br>
1.max-width/max-height/min-width/min-height<br>
2.flex-basis<br>
3.width/height<br>
4.内容本身的size</li>
</ul>
<h3 id="226-flex是flex-growflex-shrinkflex-basic的缩写属性可以指定1-3个值">2.2.6 <code>flex</code>是flex-grow||flex-shrink||flex-basic的缩写属性，可以指定1-3个值。</h3>
<ul>
<li>
<p>单值语法：值必须为以下值之一：</p>
<ul>
<li>一个无单位数 它会被当作flex-grow的值</li>
<li>一个有效宽度值 它会被当做flex-basis的值</li>
<li>关键字none、auto或者initial</li>
</ul>
</li>
<li>
<p>双值语法：第一个值必须为一个无单位数，它会被当做flex-grow的值</p>
<ul>
<li>第二个值必须为以下之一：
<ul>
<li>一个无单位数，被当做flex-shrink值</li>
<li>一个有效宽度值，被当做flex-basis值</li>
</ul>
</li>
</ul>
</li>
<li>
<p>三值语法：</p>
<ul>
<li>第一个值必须为一个无单位数，被当做flex-grow的值</li>
<li>第二个值必须为一个无单位数，被当做flex-shrink的值</li>
<li>第三个值必须为一个有效宽度值，被当做flex-basis的值</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有趣的axios源码（一）]]></title>
        <id>https://skrupellose.github.io/post/you-qu-de-axios-yuan-ma-yi/</id>
        <link href="https://skrupellose.github.io/post/you-qu-de-axios-yuan-ma-yi/">
        </link>
        <updated>2019-11-24T14:48:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-现象">一、现象：</h1>
<p>若我们添加两组请求和响应拦截器<br>
请求拦截器先添加的后执行，响应拦截器先添加的先执行。</p>
<pre><code>axios.interceptors.request.use(
  config =&gt; {
    console.log('request interceptor1 onResolved()')
      return config
  },
  error =&gt; {
    console.log('request interceptor1 onResolved()')
      return Promise.reject(error);
  }
)
axios.interceptors.request.use(
  config =&gt; {
    console.log('request interceptor2 onResolved()')
      return config
  },
  error =&gt; {
    console.log('request interceptor2 onResolved()')
      return Promise.reject(error);
  }
)
axios.interceptors.response.use(
  response =&gt; {
    console.log('response interceptor1 onResolved()')
      return response
  },
  error =&gt; {
    console.log('response interceptor1 onResolved()')
      return Promise.reject(error);
  }
)
axios.interceptors.response.use(
  response =&gt; {
    console.log('response interceptor2 onResolved()')
      return response
  },
  error =&gt; {
    console.log('response interceptor2 onResolved()')
      return Promise.reject(error);
  }
)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://skrupellose.github.io/post-images/1574609692911.png" alt="" loading="lazy"></figure>
<h1 id="二-原因">二、原因</h1>
<p>axios基于promise进行封装<br>
这部分的源码：(axios/lib/core/Axios.js)</p>
<pre><code>
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
//后添加的请求拦截器放在数组前面
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
//每个拦截器都包含两个回调函数一个成功的回调一个失败的回调
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
//后添加的响应拦截器放在数组后面
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });
//通过promise的then()方法串连起所有的请求拦截器/请求方法/响应拦截器
  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }
//最后返回我们使用axios函数指定了onResolved和onRejectd的promise
  return promise;
};
</code></pre>
<p>通过分析我们可以看出这个流程的大概步骤：</p>
<ol>
<li>隐式创建出用来保存请求和响应拦截函数的数组 -&gt; requestInterceptor和responseInterceptor</li>
<li>chain数组保存发送请求的函数</li>
<li>chain数组通过unshift和push方法分别往里面添加请求拦截函数和响应拦截函数</li>
<li>数组左边放的是请求拦截器函数</li>
<li>数组右边放的是响应拦截器函数</li>
</ol>
<pre><code>//我们用1,2,3,4分别代表从第一个请求拦截器到第二个响应拦截
1. requestInterceptor:[{fulfilled1(){}, rejected1(){}}, {fulfilled2(){}, rejected2(){}}]
   responseInterceptor:[{fulfilled3(){}, rejected3(){}}, {fulfilled4(){}, rejected4(){}}]
2. chain:[dispatchRequest, undefined]
3. chain:[
        fulfilled2, rejected2, fulfilled1, rejected1, 
        dispatchRequest, undefined, 
        fulfilled3, rejected3, fulfilled4, rejected4
        ]
//这就是最后的chain数组的样子，我们可以看到后添加的请求拦截器在数组的首位
</code></pre>
<p>其实看到chain.unshift请求拦截函数的时候就已经能够解释为什么添加多组响应器时请求拦截器先添加的后执行，因为unshift方法就是往数组的首位去插入元素，而push是往末尾添加元素。</p>
<p>之后通过</p>
<pre><code>while (chain.length) {
    //每次取出两个元素，正好对应一个拦截器的成功回调与失败回调
    promise = promise.then(chain.shift(), chain.shift());
return promise;
</code></pre>
<p>shift()删除第一个当前数组元素并返回该数据，这也正好我们拦截器的执行顺序，从chain数组的首位开始执行。故有了我们请求拦截器先添加的后执行，响应拦截器先添加的先执行的现象<br>
我们promise链的样子就是这样的：</p>
<pre><code>config =&gt; (fulfilled2, rejected2) =&gt; (fulfilled1, rejected1) //请求拦截器处理
       =&gt; (dispatchRequest, undefined) //发请求
       =&gt; (fulfilled3, rejected3) =&gt; (fulfilled4, rejected4) //响应拦截器处理
       =&gt; (onResolved, onRejected) //我们通过axios发送请求后的处理
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue+element.ui+axios做一个简单用户管理demo]]></title>
        <id>https://skrupellose.github.io/post/vueelementuiaxios-zuo-yi-ge-jian-dan-yong-hu-guan-li-demo/</id>
        <link href="https://skrupellose.github.io/post/vueelementuiaxios-zuo-yi-ge-jian-dan-yong-hu-guan-li-demo/">
        </link>
        <updated>2019-11-17T14:55:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-技术栈">一、技术栈</h1>
<p>vue、element.ui、axios</p>
<h1 id="二-准备工作">二、准备工作</h1>
<p>接口：<br>
<code>http://www.liulongbin.top:3005/</code><br>
这是在b站上小伙伴留下的测试接口</p>
<p>要实现的功能：</p>
<ol>
<li>
<p>添加用户<br>
<img src="https://skrupellose.github.io/post-images/1574007328629.png" alt="" loading="lazy"></p>
</li>
<li>
<p>搜索功能<br>
<img src="https://skrupellose.github.io/post-images/1574007313864.png" alt="" loading="lazy"><br>
<img src="https://skrupellose.github.io/post-images/1574007386230.png" alt="" loading="lazy"></p>
</li>
<li>
<p>删除用户<br>
<img src="https://skrupellose.github.io/post-images/1574007394205.png" alt="" loading="lazy"></p>
</li>
</ol>
<h1 id="三-具体实现">三、具体实现</h1>
<h2 id="31-用户数据展示和删除">3.1 用户数据展示和删除</h2>
<p>我们的用户数据用table显示，新增用户用form结合dialog组件实现。</p>
<p>这里主要是讲 <code>&lt;template slot-scope=&quot;scope&quot;&gt;</code>,官方文档讲通过<code>Scoped slot</code>可以获取到<code>row</code>, <code>column</code>, <code>$index</code> 和 <code>store（table 内部的状态管理）</code>的数据。<br>
我们一般表格只是显示数据的话，那么我们只需要在<code>el-table-column</code>标签中添加prop属性，填上对应的值，那么表格就能渲染出来。如：</p>
<pre><code>        &lt;el-table :data=&quot;tableData&quot; ref=&quot;tableData&quot; border stripe&gt;
          &lt;el-table-column label=&quot;序号&quot; width=&quot;90&quot; prop=&quot;id&quot;&gt;
          &lt;/el-table-column&gt;
           &lt;el-table-column label=&quot;用户名&quot; prop=&quot;name&quot;&gt;
          &lt;/el-table-column&gt;
           &lt;el-table-column label=&quot;时间&quot; prop=&quot;ctime&quot;&gt;
          &lt;/el-table-column&gt;
        &lt;/el-table&gt;
</code></pre>
<p>但是这样我们不好监听删除事件，所以我们使用<code>&lt;template slot-scope=&quot;scope&quot;&gt;</code></p>
<pre><code>        &lt;el-table :data=&quot;tableData&quot; ref=&quot;tableData&quot; border stripe&gt;
          &lt;el-table-column label=&quot;序号&quot; width=&quot;90&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.id }}&lt;/span&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;用户名&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.name }}&lt;/span&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;时间&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;span style=&quot;margin-left: 10px&quot;&gt;{{ scope.row.ctime }}&lt;/span&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;操作&quot; width=&quot;160&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;el-button type=&quot;primary&quot;&gt;编辑&lt;/el-button&gt;
              &lt;el-button @click.native.prevent=&quot;_del(scope.row.id)&quot; type=&quot;danger&quot;&gt;移除&lt;/el-button&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
        &lt;/el-table&gt;
</code></pre>
<p>通过<code>scope.row.id</code>我们就能得到当前点击的数据的id值，这也是它的唯一索引，我们通过向后台提交这个值来达到删除该条数据的目的。</p>
<pre><code>function del(id) {
  const url = &quot;api/delproduct/&quot;;
  return $axios.get(url + id);
</code></pre>
<pre><code>method:

   _del(id) {
      del(id).then(res =&gt; {
        const result = res.data;
        if (result.status === 0) {
          this._getlist();//删除之后获取新数据达到刷新效果
        }
        console.log(res);
      });
    },
</code></pre>
<h2 id="32-用户添加">3.2 用户添加</h2>
<p>我们获取用户列表的时候执行一次axios请求，添加之后也要执行一下这个方法达到刷新的目的，删除也是这样。</p>
<pre><code>const $axios = axios.create({
  // 设置超时时间
  timeout: 30000,
  // 基础url，会在请求url中自动添加前置链接
  baseURL: &quot;http://www.liulongbin.top:3005/&quot;
});
</code></pre>
<p>我们还是配置一下我们的axios实例，这样后面写url的时候会方便很多。<br>
获取列表的方法：</p>
<pre><code>function getlist() {
  const url = &quot;api/getprodlist&quot;;
  return $axios.get(url);
}
</code></pre>
<p>然后在method中对这个请求做一下处理：</p>
<pre><code>    _getlist() {
      getlist().then(res =&gt; {
        console.log(res);
        this.allList = res.data.message;
        this.tableData = this.allList;
      });
    },
</code></pre>
<p>之后我们在<code>create</code>的时候第一次执行<code>_getlist()</code>获取用户信息。<br>
用户添加功能我们写在<code>form</code>表单里面，然后写一个<code>dialog</code>控件把<code>form</code>嵌在<code>dialog</code>上，平时使它的值为<code>false</code>，在点击添加的时候变为<code>true</code>，这样<code>dialog</code>就会显示出来，我们就能在<code>form</code>上添加用户了。</p>
<p>这里需要注意的一点就是关于函数的this指向，我之前也是将<code>add()</code>函数封装了一下，外面又套了一个函数<code>_add()</code>对<code>add()</code>方法返回的信息进行处理，在添加用户的时候调用_add()方法，然后传值<code>this.formData.name</code>,但是这个时候this指向的不是表单，而是调用套在它外面的<code>_add()</code>函数（add方法是<code>axios</code>请求，此时在<code>add</code>方法里传<code>this.formData.name</code>的话就会去调用它的<code>_add</code>方法里去找）。</p>
<p>所以我们直接写一个addUser方法就好：</p>
<pre><code>    addUser() {
      const url = &quot;api/addproduct&quot;;
      $axios.post(url, { name: this.formData.name }).then(res =&gt; {
        const result = res.data;
        if (result.status === 0) {
          this._getlist();
        }
      });
</code></pre>
<p>在添加成功用户之后再执行一次<code>_getlist()</code>方法刷新页面。</p>
<h2 id="33-用户搜索">3.3 用户搜索</h2>
<p>我们首先新建一个数组来储存符合要求的用户，然后给input输入框设置双向绑定来获取当前里面的值，然后通过在总数据中使用forEach遍历，对每个数据的名字用IndexOf进行判断看是否是我们要找的数据，如果不为-1证明是我们要找的值，将它push到新数组，然后将数组的值传给表格进行渲染。</p>
<pre><code>    searchTab() {
      let newlist = [];
      this.allList.forEach(item =&gt; {
        if (item.name.indexOf(this.keywords) != -1) {
          newlist.push(item);
        }
      });
      this.tableData = newlist;
    },
</code></pre>
<p>一个和这个差不多的<a href="https://github.com/Skrupellose/manage-demo/blob/master/index.html">例子</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法题--数组(1)]]></title>
        <id>https://skrupellose.github.io/post/suan-fa-ti-shu-zu-1/</id>
        <link href="https://skrupellose.github.io/post/suan-fa-ti-shu-zu-1/">
        </link>
        <updated>2019-11-16T14:59:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="要求">要求：</h2>
<p>将上面的数组转换成下面数组的形式</p>
<pre><code>      [
        { name: &quot;a&quot;, hobby: &quot;football&quot; },
        { name: &quot;b&quot;, hobby: &quot;basketball&quot; },
        { name: &quot;a&quot;, hobby: &quot;swim&quot; },
        { naem: &quot;b&quot;, hobby: &quot;computer&quot; }
      ];

      [
        {name: 'a', hobby: 'football, swim'},
        {name: 'b', hobby: 'basketball, computer'}
      ]
</code></pre>
<h3 id="思路">思路：</h3>
<ol>
<li>新建一个空的新数组，使用<code>forEach</code>遍历原数组取得每一个对象</li>
<li>进行判断，若此时新数组为空，则将此遍历到的这个对象<code>push</code>到新数组；</li>
<li>若此时新数组不为空，则使用<code>findIndex()</code>方法，判断当前对象的名称在数组中是否已经存在，若存在则通过返回的索引将值<code>push</code>进对应的对象的<code>hobby</code>属性里，若不存在则将该对象<code>push</code>进新数组</li>
</ol>
<h3 id="知识点">知识点：</h3>
<p><strong>forEach()</strong><br>
<code>forEach()</code> 方法按升序为数组中含有效值的每一项执行一次<code>callback</code> 函数，那些已删除或者未初始化的项将被跳过</p>
<p><code>array.forEach(function(currentValue, index, arr), thisValue)</code></p>
<p>回调函数参数：</p>
<ul>
<li><code>currentValue</code>	必需。当前元素</li>
<li><code>index</code>  可选。当前元素的索引值。</li>
<li><code>arr</code>	 可选。当前元素所属的数组对象。</li>
</ul>
<p><strong>findIndex()</strong><br>
<code>findIndex()</code> 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。</p>
<p><code>findIndex()</code> 方法为数组中的每个元素都调用一次函数执行：</p>
<p>当数组中的元素在测试条件时返回 <code>true</code> 时, <code>findIndex()</code>返回符合条件的元素的索引位置，之后的值不会再调用执行函数。<br>
如果没有符合条件的元素返回 <code>-1</code></p>
<p><code>array.findIndex(function(currentValue, index, arr), thisValue)</code><br>
回调函数参数：</p>
<ul>
<li><code>currentValue</code> 	必需。当前元素</li>
<li><code>index</code>  可选。当前元素的索引值。</li>
<li><code>arr</code>	 可选。当前元素所属的数组对象。</li>
</ul>
<p><strong>hasOwnProperty()</strong><br>
<code>hasOwnProperty()</code>方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。</p>
<p><code>obj.hasOwnProperty(prop)</code></p>
<p>参数：</p>
<p><code>prop</code>：要检测的属性的<code>String</code>字符串形式表示的名称，或者<code>Symbol</code></p>
<h3 id="实现">实现：</h3>
<pre><code>      const arr = [

        { name: &quot;b&quot;, hobby: &quot;basketball&quot; },
        { name: &quot;a&quot;, hobby: &quot;swim&quot; },
        { name: &quot;b&quot;, hobby: &quot;computer&quot; },
        { name: &quot;a&quot;, hobby: &quot;football&quot; }
      ];
      let resArr = []
      arr.forEach((item, index) =&gt; {
        if (resArr.length) {
          const res = resArr.findIndex(_item =&gt; _item.name === item.name)
          if ((res === -1)) {
            resArr.push({
              name: item.name,
              hobby: [item.hobby]
            });
          } else {
            resArr[res][&quot;hobby&quot;].push(item.hobby)
          }
        } else {
          resArr.push({
            name: item.name,
            hobby: [item.hobby]
          })
        }
      })
      console.log(resArr) //[{name: &quot;a&quot; hobby:  [&quot;swim&quot;, &quot;football&quot;]}, {name: &quot;b&quot; hobby: [&quot;basketball&quot;, &quot;computer&quot;]}]
</code></pre>
<p>还有另一种写法，思路与上面的大同小异，只是通过<code>hasOwnProperty</code>来判断是否已有重复属性，然后用<code>findIndex()</code>来得到索引。</p>
<pre><code>      let obj1 = {};
      let objArr = [];
      const arr = [
        { name: &quot;a&quot;, hobby: &quot;football&quot; },
        { name: &quot;b&quot;, hobby: &quot;basketball&quot; },
        { name: &quot;a&quot;, hobby: &quot;swim&quot; },
        { name: &quot;b&quot;, hobby: &quot;computer&quot; }
      ];

      arr.forEach((item, index) =&gt; {
        if (obj1.hasOwnProperty(item.name)) {
          const index = objArr.findIndex(
            objArrItem =&gt; item.name === objArrItem.name
          );
          objArr[index].hobby.push(item.hobby);
        } else {
          objArr.push({
            name: item.name,
            hobby: [item.hobby]
          });
          obj1[item.name] = index;
        }
      });
      console.log(objArr); //[{name: &quot;a&quot; hobby:  [&quot;swim&quot;, &quot;football&quot;]}, {name: &quot;b&quot; hobby: [&quot;basketball&quot;, &quot;computer&quot;]}]
      console.log(obj1); //{a: 0, b: 1}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fetch和axios的上手使用]]></title>
        <id>https://skrupellose.github.io/post/fetch-he-axios-de-shang-shou-shi-yong/</id>
        <link href="https://skrupellose.github.io/post/fetch-he-axios-de-shang-shou-shi-yong/">
        </link>
        <updated>2019-11-14T15:41:05.000Z</updated>
        <content type="html"><![CDATA[<p>复(xue)习一下<code>fetch</code>和<code>axios</code>的用法</p>
<h1 id="一-fetch的用法">一、fetch的用法</h1>
<p>直接贴demo了</p>
<pre><code>      fetch(&quot;url&quot;).then(data =&gt; {
        return data.text().then(res =&gt; {
          console.log(res);
        });
      });
</code></pre>
<ul>
<li>要获取数据首先要调用<code>text()</code>方法或者<code>json()</code>方法</li>
<li><code>data.text()/data.json()</code>返回的是<code>promise</code>对象，用<code>.then()</code>处理之后得到的才是结果</li>
<li><code>text()</code>返回结果为字符串</li>
<li><code>json()</code>返回结果为json类型</li>
</ul>
<h2 id="11-fetch请求参数">1.1 fetch请求参数</h2>
<ul>
<li><code>method(String)</code>:http请求方法，默认为<code>GET(GET、POST、PUT、DELETE)</code></li>
<li><code>body(String)</code>:http的请求参数</li>
<li><code>header(Object)</code>:http的请求头，默认为{}</li>
</ul>
<h2 id="12-get请求">1.2 GET请求</h2>
<pre><code>
      // url传递参数
      fetch('url?id=123',{
        method: 'get'
      }).then(data =&gt; {
        return data.text()
        .then(res =&gt; {
          console.log(res);
        })
      })
      // Restful形式的url传递参数
      fetch('url/123',{
        method: 'get'
      }).then(data =&gt; {
        return data.text()
        .then(res =&gt; {
          console.log(res);
        })
      })
</code></pre>
<h2 id="13-delete请求">1.3 DELETE请求</h2>
<p>✊偷个懒 只需把<code>method</code>换成<code>delete</code>即可</p>
<h2 id="14-post请求">1.4 POST请求</h2>
<pre><code>  //传统参数传递
  fetch('url',{
    method: 'post',
    body: 'name=abc&amp;passwd=123',
    headers: {
      'Content-type': 'application/x-www-form-unlencoded',
    }//请求头必须设置否则body里的数据传不到后台去
  }).then(data =&gt; {
    return data.text()
    .then(res =&gt; {
      console.log(res);
    })
  })

  //json形式参数传递
  fetch('url',{
    method: 'post',
    body: JSON.stringify({
      name:&quot;abc&quot;,
      passwd:&quot;123&quot;
    }),
    headers: {
      'Content-type': 'application/json',
    }//请求头必须设置否则body里的数据传不到后台去
  }).then(data =&gt; {
    return data.text()
    .then(res =&gt; {
      console.log(res);
    })
  })
</code></pre>
<h2 id="15-put请求">1.5 PUT请求</h2>
<pre><code>      fetch('url/456',{
        method: 'put',
        body: JSON.stringify({
          name:&quot;abc&quot;,
          passwd:&quot;123&quot;
        }),
        headers: {
          'Content-type': 'application/json',
        }
      }).then(data =&gt; {
        return data.text()
        .then(res =&gt; {
          console.log(res);
        })
      })
      // 把put的值通过url的Restful形式传过去
</code></pre>
<h1 id="二-axios">二、axios</h1>
<h2 id="21-用法">2.1 用法</h2>
<pre><code>      axios.get('url')
      .then(res =&gt; {
        console.log(res.data)
        // 需要注意的是使用axios请求数据后.then()返回的对象除去我们想要的数据
        // 之外还有其他的数据，所以当我们需要拿到想要的数据的时候要使用data属性来获取
      })
</code></pre>
<h2 id="22-get请求">2.2 get请求</h2>
<pre><code>      // 1.通过url传递
      axios.get('url?id=123')
      .then(res =&gt; {
        console.log(res.data)
      })
      // 2.通过params属性传递
      axios.get('url',{
        params:{
          id: 123
        }
      })
      .then(res =&gt; {
        console.log(res.data)
      })

</code></pre>
<h2 id="23-delete请求">2.3 delete请求</h2>
<p>继续偷个懒，<code>delete</code>方式只需要把<code>ge</code>t换成<code>delete</code>即可</p>
<h2 id="24-post请求">2.4 post请求</h2>
<pre><code>  // 通过选项来传递参数默认传递的是json格式的数据
      axios.post('url',{
        name: &quot;yy&quot;,
        age: 16
      })//通过这种传到后台的数据是json格式
      .then(res =&gt;{
        console.log(res.data)
      })

      // 通过URLSearchParams传递参数
      const params = new URLSearchParams();
      params.append('name','abc');
      params.append('age','16');
      axios.post('url', params)
      .then(res =&gt; {
        console.log(res.data)
      })
</code></pre>
<h2 id="25-put请求">2.5 put请求</h2>
<pre><code>      axios.post('url/123',{
        name: &quot;yy&quot;,
        age: 16
      })//通过这种传到后台的数据是json格式
      .then(res =&gt;{
        console.log(res.data)
      })
</code></pre>
<h2 id="26-请求和响应拦截">2.6 请求和响应拦截</h2>
<pre><code>      // 请求拦截 发出请求数据之前进行一些配置和处理
      axios.interceptors.request.use(config =&gt;{
        ... //一些操作代码
        return config;
      })

      // 响应拦截 获取数据之前对数据进行一些处理
      axios.interceptors.response.use(res =&gt;{
        ... //一些操作代码
        return res;
      })

</code></pre>
<h2 id="27-axios响应结果">2.7 axios响应结果</h2>
<p>响应结果被包装成一个对象<br>
里面的主要属性：<br>
-<code>data</code>：实际响应回的数据<br>
-<code>headers</code>： 响应头信息</p>
<ul>
<li><code>status</code>：响应状态码</li>
<li><code>statusText</code>：响应状态信息</li>
</ul>
<h2 id="28-axios和asyncawait的联用">2.8 axios和async/await的联用</h2>
<pre><code>      async function get_(){
        let res = await axios.get('url');
        console.log(res.data)
      }
      get_() //data

      axios.get('url')
      .then(res =&gt; {
        console.log(res.data)
      })
</code></pre>
<p><code>then()</code>方法参数中的函数返回值:</p>
<ol>
<li>返回<code>promise</code>对象 返回的对象会调用下一个<code>then</code></li>
<li>返回普通值，会被直接传递给下一个<code>then()</code>的函数中充当参数</li>
</ol>
<p>或是：后面的请求需要前一个请求返回的结果作为参数，可以这么写提高代码可读性</p>
<pre><code>        async function test(){
          let res1 = await axios.get('url1')
          let res2 = await axios.get('url2?info=' + res1.data)
          return rest2
        }
        test().then(res =&gt; {
          console.log(res);
        })
</code></pre>
<p>补充：我们还可以新建一个<code>axios</code>实例对象来进行一些配置</p>
<pre><code>const $axios = axios.create({
  // 设置超时时间
  timeout: 30000,
  // 基础url，会在请求url中自动添加前置链接
  baseURL: &quot;url&quot;
});
</code></pre>
<p>这样我们在后面使用<code>axios</code>发送请求的时候就不用写那么长的url了</p>
]]></content>
    </entry>
</feed>