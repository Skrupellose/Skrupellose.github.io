<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skrupellose.github.io</id>
    <title>D.C </title>
    <updated>2020-06-19T08:37:48.456Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skrupellose.github.io"/>
    <link rel="self" href="https://skrupellose.github.io/atom.xml"/>
    <subtitle>人类世界真是太有趣了</subtitle>
    <logo>https://skrupellose.github.io/images/avatar.png</logo>
    <icon>https://skrupellose.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, D.C </rights>
    <entry>
        <title type="html"><![CDATA[使用react+antd+bom实现一个TodoList]]></title>
        <id>https://skrupellose.github.io/post/shi-yong-reactantdbom-shi-xian-yi-ge-todolist/</id>
        <link href="https://skrupellose.github.io/post/shi-yong-reactantdbom-shi-xian-yi-ge-todolist/">
        </link>
        <updated>2020-06-19T05:35:16.000Z</updated>
        <content type="html"><![CDATA[<p>一、思路<br>
因为需要不借助数据库的持久化存储我想到了使用浏览器的storage来帮助存储，因此每次修改我们可以将最新的数据传入数组并且覆盖storage之前的数据，然后在请求数据的时候调用，在storage中数据也是靠键值对来存储的，也比较方便调取数据。<br>
二、实现<br>
首先是简单封装一下存储函数，这里简单的选择localstorage来作为存储手段。</p>
<pre><code>//storage.js

const funObj = {
    set(key, value) {
        localstorage.setItem(key, JSON.stringity(value));
    },
    get(key) {
        return JSON.parse(localstorage.get(key));
    }
}
export dafult fnObj;
</code></pre>
<p>然后开始写todolist组件，首先是功能，有增删改的需求，其次设计的时候决定新增和编辑共用同一个输入组件，这个时候就需要两个标识符进行判断，一个是组件是否显示，一个是组件是新增状态还是编辑状态。<br>
还有就是获取input的值，普通输入框可以使用<code>this.名称 = React.createRef();</code>，然后对<code>input</code>进行绑定<code>&lt;input ref={this.名称}&gt;</code>,取值的话使用<code>this.名称.current.prop</code>我们通过<code>current</code>来获取dom节点。但是这里用的是<code>antd</code>的组件，已经进行过封装所以我们借助中间数据来获取输入。</p>
<pre><code>class Todolist extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      todoList: [],
      finishList: [],
      inputValue: '',
      flag: false,
      edit: false,
      index: 0
    };
  }
  componentDidMount() {
    let list = storage.get(&quot;TodoList&quot;);
    if (list) {
      this.setState({
        finishList: list,
      })
    }
  }
  addList = () =&gt; {
    let title = this.state.inputValue
    let edit = this.state.edit
    let index = this.state.index
    if (edit) {
      let templist = this.state.finishList;
      templist[index].title = this.state.inputValue
      this.setState({
        todoList: templist,
        inputValue: '',
        edit: false
      });
      storage.set(&quot;TodoList&quot;, templist);
    } else {
      let tempList = this.state.finishList;
      tempList.push({
        title: title,
        finished: false
      })
      this.setState({
        todoList: tempList,
        inputValue: ''
      });
      storage.set(&quot;TodoList&quot;, tempList);
    }
    this.changeDisplay()
  }
  changeDisplay = () =&gt; {
    this.setState({
      flag: !this.state.flag,
    })
  }
  changeEdit = () =&gt; {
    let edit = this.state.edit
    if (!edit) {
      this.setState({
        flag: !this.state.flag,
        edit: !this.state.edit,
      })
    } else {
      this.changeDisplay()
    }

  }
  changeInput = (e) =&gt; {
    this.setState({
      inputValue: e.target.value,
    })
  }
  changeState = (i) =&gt; {
    let templist = this.state.finishList;
    templist[i].finished = !templist[i].finished;
    this.setState({
      todoList: templist
    });
    storage.set(&quot;TodoList&quot;, templist);
  }
  doList = (i) =&gt; {
    this.changeState(i)
  }
  deleteList = (i) =&gt; {
    let templist = this.state.finishList;
    templist.splice(i, 1);
    this.setState({
      todoList: templist
    })
    storage.set(&quot;TodoList&quot;, templist);
  }
  editList = (i) =&gt; {
    this.changeDisplay()
    this.changeEdit()
    this.setState({
      index: i
    })
  }

  render() {
    const flag = this.state.flag
    let content, button
    if (flag) {
      content = &lt;div className=&quot;menu&quot;&gt;
        &lt;Input onChange={this.changeInput} onPressEnter={this.addList} value={this.state.inputValue} /&gt;
        &lt;Button type=&quot;primary&quot; className=&quot;button&quot; onClick={this.addList}&gt;确定&lt;/Button&gt;
      &lt;/div&gt;
      button = &lt;Button type=&quot;danger&quot; onClick={this.changeEdit}&gt;关闭&lt;/Button&gt;
    } else {
      button = &lt;Button onClick={this.changeDisplay}&gt;新增&lt;/Button&gt;
    }
    return (
      &lt;div className=&quot;container&quot;&gt;
        &lt;div className=&quot;content&quot;&gt;
          &lt;div className=&quot;header&quot;&gt;
            &lt;h2&gt;Todolist&lt;/h2&gt;
            {content}
            {button}
          &lt;/div&gt;
          &lt;div className=&quot;body&quot;&gt;
            &lt;div className=&quot;working&quot;&gt;
              &lt;h2&gt;未完成事项&lt;/h2&gt;
              {
                this.state.finishList.map((item, index) =&gt; {
                  if (item.finished === false) {
                    return (
                      &lt;div key={index} className=&quot;list-item&quot;&gt;
                        &lt;div className=&quot;show-item&quot;&gt;
                          {item.title}
                        &lt;/div&gt;
                        &lt;div&gt;
                          &lt;Button type=&quot;primary&quot; onClick={this.editList.bind(this, index)}&gt;编辑&lt;/Button&gt;
                          &lt;Button type=&quot;danger&quot; onClick={this.deleteList.bind(this, index)}&gt;删除&lt;/Button&gt;
                          &lt;Button type=&quot;dashed&quot; onClick={this.doList.bind(this, index)}&gt;完成&lt;/Button&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    )
                  } else {
                    return null
                  }
                })
              }
            &lt;/div&gt;

            &lt;div className=&quot;worked&quot;&gt;
              &lt;h2&gt;已完成事项&lt;/h2&gt;
              {
                this.state.finishList.map((item, index) =&gt; {
                  if (item.finished === true) {
                    return (
                      &lt;div key={index} className=&quot;list-item&quot;&gt;
                        &lt;div className=&quot;show-item worked&quot;&gt;
                          {item.title}
                        &lt;/div&gt;
                        &lt;div&gt;
                          &lt;Button type=&quot;primary&quot; onClick={this.editList.bind(this, index)}&gt;编辑&lt;/Button&gt;
                          &lt;Button type=&quot;danger&quot; onClick={this.deleteList.bind(this, index)}&gt;删除&lt;/Button&gt;
                          &lt;Button type=&quot;dashed&quot; onClick={this.changeState.bind(this, index)}&gt;撤回&lt;/Button&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    )
                  } else {
                    return null
                  }
                })
              }
            &lt;/div&gt;
          &lt;/div&gt;

        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
export default Todolist;
</code></pre>
<p>以下是scss代码</p>
<pre><code>// todoList.scss
.container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background-color: rgba(42, 121, 158, 0.3);
  .content {
    padding: 2rem;
    box-shadow: 0px 2px 13px 0px rgba(228, 228, 228, 0.6);
    border-radius: 5px;
    background-color: #fff;
    width: 35rem;
    .menu {
      padding: 30px;
      .button {
        margin-top: 20px;
      }
    }
    .header {
      text-align: center;
      padding: 30px;
      margin: 20px 0;
    }
    .body {
      display: flex;
      justify-content: space-around;
      h2 {
        text-align: center;
      }
      .list-item {
        padding: 20px 0;
        .show-item {
          font-size: 18px;
          text-align: center;
        }
        .worked{
          text-decoration-line: line-through
        }
        input {
          margin-right: 10px;
        }
        Button {
          margin-right: 5px;
        }
      }
    }
  }
}

</code></pre>
<p>三、总结<br>
这次demo主要还是熟悉浏览器api的react框架的使用，网上看到的面试题也让我明白平时注重一些基础训练，对于开发或者面试都是很有好处的，要保持下去。我爱切图！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试小总结（1）]]></title>
        <id>https://skrupellose.github.io/post/mian-shi-xiao-zong-jie-1/</id>
        <link href="https://skrupellose.github.io/post/mian-shi-xiao-zong-jie-1/">
        </link>
        <updated>2020-06-19T04:54:14.000Z</updated>
        <content type="html"><![CDATA[<p>最近开始找工作了，陆陆续续开始做一些公司发的面试题，在做的过程中发现了之前被遗忘的部分知识，正好借此机会巩固一下。</p>
<h1 id="一-ie兼容性问题">一、ie兼容性问题</h1>
<h2 id="11-不支持识别的语法">1.1 不支持识别的语法</h2>
<h3 id="111-for-of-循环">1.1.1 for of 循环</h3>
<p><code>for in</code>以任意顺序迭代对象的可枚举属性<br>
<code>for...of</code> 语句遍历可迭代对象定义要迭代的数据<br>
<code>for in</code> 与<code>for of</code> 都可以对数组进行循环，一个循环出索引一个循环出值。</p>
<pre><code>let a = [1,2,3,5]
for (i in a){
  console.log(i)
}
// 0 1 2 3
</code></pre>
<pre><code>let a = [1,2,3,5]
for (i of a){
  console.log(i)
}
// 1 2 3 5
</code></pre>
<p>对象的话就变成了<code>for in</code>循环出<code>key</code>，但<code>for of</code>不能直接遍历对象，只有提供了<code>Iterator</code>接口的数据类型才能使用<code>for of</code>循环</p>
<pre><code>let a = { b:'1', c:'2', d:'3'}
for (i in a){
  console.log(i)
}
// b c d
</code></pre>
<p><code>ie9</code>以下数组进不了<code>for in</code>循环而<code>ie11</code>以下进入之后无法对循环元素的正确属性进行判断。这种情况最好使用海纳百川的<code>for()</code>循环解决问题。</p>
<h3 id="112-模板字符串">1.1.2 模板字符串</h3>
<p>es6的模板字符串确确实实带来了开发上的遍历，但是，ie不认。<br>
今天排错的时候发现组件没有插进dom节点，但是谷歌、火狐都是正常的就是ie有问题，然后想了想ie好像是不支持模板字符串的写法，然后进行修改，最后在ie上成功运行。<br>
普通字符串: <code>&quot; &quot;</code> 或者 <code>' '</code><br>
在进行拼接的时候使用<code>+</code> 连接变量或者其他字符串<br>
模板字符串:</p>
<pre><code>`123`
</code></pre>
<p>直接用反引号来包住字符串，如果要使用变量直接在其中使用</p>
<pre><code>`123123${变量}`，
</code></pre>
<p>非常方便！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack入门]]></title>
        <id>https://skrupellose.github.io/post/webpack-ru-men/</id>
        <link href="https://skrupellose.github.io/post/webpack-ru-men/">
        </link>
        <updated>2020-06-11T23:13:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-介绍">一、介绍</h1>
<p>webpack本质是一个针对js应用的打包工具，通过递归构建依赖关系找到应用程序需要的所有模块，并将其打包成一个或多个包</p>
<h1 id="二-入门">二、入门</h1>
<h2 id="21-下载安装">2.1 下载安装</h2>
<ol>
<li>首先是全局安装webpack和webpack-cli<br>
<code>npm install webpack webpack-cli -g</code></li>
<li>然后是在项目中安装webpack和webpack-cli<br>
<code>npm install webpack webpack-cli</code></li>
<li>我们在项目中允许npm初始化<br>
<code>npm init -y(全选yes)</code> 之后会在文件夹中生成<code>package.json</code>文件，我们可以在这个文件修改配置信息<br>
初始化之后可以看到这串信息<pre><code>{
&quot;name&quot;: &quot;demo1&quot;,
&quot;description&quot;: &quot;&quot;,
&quot;main&quot;: &quot;index.js&quot;,
&quot;scripts&quot;: {
&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
},
&quot;keywords&quot;: [],
&quot;author&quot;: &quot;&quot;,
&quot;license&quot;: &quot;ISC&quot;
}
</code></pre>
</li>
</ol>
<p>这里面默认的index.js就是我们的入口文件<br>
需要修改入口文件可以去<code>package.json</code><br>
4. 我们在index.js中写入测试数据，并在同级目录写一个user.json文件</p>
<pre><code>        // index.js
       import data from './user.json'                  
       function test() {
       console.log('test webpack')
       }
       test()
       console.log(data)
     
       //user.json
       {
           &quot;username&quot; : &quot;admin&quot;
       }
</code></pre>
<ol start="5">
<li>我们在文件根目录执行webpack打包命令进行开发环境下的打包测试<br>
<code>webpack 入口文件 -o 出口文件 --mode=模式选择</code><br>
<code>webpack ./src/index.js -o ./dist/bundle_dev.js --mode=development</code><br>
我们就可以看到根目录多了一个dist文件夹，其中有一个<code>bundle_dev.js</code>，同理只要我们将<code>mode</code>改为<code>production</code>就能进行生产环境下的打包</li>
<li>我们在根目录新建一个index.html，引入打包后的<code>bundle_dev.js</code></li>
<li>运行后打开控制台<br>
<img src="https://skrupellose.github.io/post-images/1591921158786.png" alt="" loading="lazy"><br>
打包成功<br>
然后我们将js文件更换为生成环境下的<code>bundle_pro.js</code>进行测试<br>
<img src="https://skrupellose.github.io/post-images/1591921318256.png" alt="" loading="lazy"><br>
也测试成功<br>
两种环境下的打包区别主要是生产环境下的打包文件被压缩了，体积更小，同时也加入了代码混淆<br>
<img src="https://skrupellose.github.io/post-images/1591921536720.png" alt="" loading="lazy"></li>
</ol>
<h2 id="22-使用webpack配置进行打包">2.2 使用webpack配置进行打包</h2>
<p>这次我们还用webpack配置文件进行打包，首先在根路径新建webpack.config.js文件，然后进行配置</p>
<pre><code>let path = require('path')
module.exports = {
  //入口文件
  entry: './src/index.js',
  //出口文件
  output: {
    //输出文件名称
    filename: 'bundle.js',
    //输出路径
    //绝对路径
    path: path.resolve(__dirname, 'dist')
  },
  //模式选择
  mode: 'development'
}
</code></pre>
<p>之后只需要使用<code>webpack</code>这个命令就可以完成打包了</p>
<h2 id="23-loader的使用">2.3 loader的使用</h2>
<p>因为之前也提到，<code>webpack</code>是一个针对js应用的打包工具，因此它本身只理解<code>JavaScript</code>一种语言，而<code>loader</code>就是将其他<code>webpack</code>不能处理的语言转换成能够处理的道具</p>
<p>这里以css文件为例，我们首先在<code>index.js</code>同级目录新建<code>style.css</code>文件，然后在<code>index.js</code>中引入，之后在<code>webpack.config.js</code>中进行<code>loader</code>的配置</p>
<pre><code>// style.css
.div {
  width: 200px;
  height: 200px;
  background: royalblue;
}
// index.js
import data from './user.json'
import './style.css'
function test() {
  console.log('test webpack')
}
test()
console.log(data)
</code></pre>
<p>我们首先下载我们需要的两个<code>loader</code><br>
<code>npm install css-loader style-loader --save-dev</code><br>
然后配置<code>webpack.config.js</code>,我们需要注意的是模块配置的的解析是自下而上的，不要写错了不然可能会报错。</p>
<pre><code>// webpack.config.js
let path = require('path')
module.exports = {
  //入口文件
  entry: './src/index.js',
  //出口文件
  output: {
    //输出文件名称
    filename: 'bundle.js',
    //输出路径
    //绝对路径
    path: path.resolve(__dirname, 'dist')
  },
  //模式选择
  mode: 'development',
  //loader配置
  module: {
    // 设置对应规则
    rules: [
      {
        // 通过正则进行匹配
        test: /\.css$/,
        // loader中use的解析顺序自下而上
        use: [
          // 将js的样式内容插入到style标签中
          &quot;style-loader&quot;,
          // 将css文件转换为js
          &quot;css-loader&quot;
        ]
      }
    ]
  }
}
</code></pre>
<p>输入webpack命令进行打包，然后我们就能看到之前写的样式了<br>
<img src="https://skrupellose.github.io/post-images/1591923652814.png" alt="" loading="lazy"></p>
<h2 id="24-plugins的使用">2.4 plugins的使用</h2>
<p><code>loader</code>是一个用于类型转换的模块工具，而<code>plugins</code>的功能更加多样。可以进行打包优化、压缩、重新定义环境变量等等<br>
还是先进行基本配置，我们完成一个html模板的打包，先下载<code>html-webpack-plugin</code></p>
<pre><code>const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports = {
  //入口文件
  entry: './src/index.js',
  //出口文件
  output: {
    //输出文件名称
    filename: 'bundle.js',
    //输出路径
    //绝对路径
    path: path.resolve(__dirname, 'dist')
  },
  //模式选择
  mode: 'development',
  //loader配置
  module: {
    // 设置对应规则
    rules: [
      {
        // 通过正则进行匹配
        test: /\.css$/,
        // loader中use的解析顺序自下而上
        use: [
          // 将js的样式内容插入到style标签中
          &quot;style-loader&quot;,
          // 将css文件转换为js
          &quot;css-loader&quot;
        ]
      }
    ]
  },
  // 插件配置
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ]
}
</code></pre>
<p>进行一个简单配置，由于插件可传递参数，使用在配置中应当传入new的实例，<code>new HtmlWebpackPlugin()</code>不传其他参数的话默认在出口文件夹生成一个<code>index.html</code>，为了自定义HTML模板我们可以接收写好的模板，然后输入<code>webpack</code>,我们就能看到<code>dist</code>文件夹下除了<code>bundle.js</code>外多了一个<code>index.js</code></p>
<h2 id="25-图片资源文件的配置">2.5 图片资源文件的配置</h2>
<p>之后我们进行图片资源文件的配置，首先下载我们需要的loader：<code>file-loader</code> <code>url-loader</code>和 <code>html-loader</code></p>
<pre><code>{
        //匹配图片文件
        test: /\.(jpg|png|gif)$/,
        loader:'url-loader',
        // 若图片小于12kb，base64处理，可以减少请求数量，但会使得体积更大
        // 其余图片以file-loader形式处理
        options: {
          limit: 12 * 1024,
          //url-loader的es6模块化解析会和我们的html-loader冲突，因此要关掉
          esModule: false,
          //[hash:n]取得图片hash的前n位，[ext]取得图片的拓展名
          name: '[hash:10].[ext]'
        }
      },
</code></pre>
<p>然后我们查看打包后的html文件<br>
<img src="https://skrupellose.github.io/post-images/1591962480243.png" alt="" loading="lazy"><br>
小于12k的文件被转成base64格式，而大文件没有，实现了图片文件的打包。</p>
<h2 id="26-模块热更新">2.6 模块热更新</h2>
<p>开启热更新后，我们每次保存文件都可以同步更新。<br>
先全局安装依赖模块<code>npm install webpack-dev-server -g</code>,然后添加配置文件</p>
<pre><code>  devServer: {
    // 项目构建路径
    contentBase: path.resolve(__dirname, 'dist'),
    // 启动gzip压缩
    compress: true,
    // 项目运行端口号
    port:3000,
    // 自动打开浏览器
    open:true
  }
</code></pre>
<p>之后执行<code>webpack-dev-server</code>就能开启热更新了，每次保存之后系统都会自动更新</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scss基础]]></title>
        <id>https://skrupellose.github.io/post/scss-chu-bu-shi-yong/</id>
        <link href="https://skrupellose.github.io/post/scss-chu-bu-shi-yong/">
        </link>
        <updated>2020-06-04T16:11:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-scss介绍">一、Scss介绍</h1>
<p>Sass 是一种 CSS 的预编译语言。它提供了 <code>变量（variables）</code>、<code>嵌套（nested rules）</code>、<code>混合（mixins）</code>、 <code>函数（functions）</code>等功能，并且完全兼容 CSS 语法。Scss 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。</p>
<p>我们在写传统css的时候，经常会写一些重复度较高的代码。这是因为传统css文件缺少变量、函数等概念，但是现在使用Scss之后就可以通过新增的这些概念来达到提高效率的目的</p>
<h1 id="二-基本使用">二、基本使用</h1>
<h2 id="21-嵌套语法">2.1 嵌套语法</h2>
<p>在scss中，我们首先可以使用嵌套语法来写css了，这样可以极大提高文件的可读性，更加直观明了<br>
eg：<br>
css</p>
<pre><code>.box {
   display: float;
}
.box ul {
    list-style: none;
}

</code></pre>
<p>Scss</p>
<pre><code>.box {
    display: float;
    ul {
        list-style: none;
    }
}
</code></pre>
<h2 id="22-父级选择器">2.2 父级选择器</h2>
<p>scss提供了一个父选择器<code>&amp;</code>，用于表示当前元素的父元素<br>
eg:<br>
css</p>
<pre><code>.btn {
    background-color: #fff;
}
.btn  .active {
    background-color: #f00;
}
</code></pre>
<p>Scss</p>
<pre><code>.bth {
    background-color: #fff;
    &amp;.active {
        background-color: #f00;
    }
}
</code></pre>
<p>需要注意的是要在嵌套内部使用父级选择器，不然找不到父级元素会报错</p>
<h2 id="23-嵌套属性规则">2.3 嵌套属性规则</h2>
<p>eg：<br>
css</p>
<pre><code>.box {
    font-family: fantasy;
    font-size: 1.2em;
    font-line-hight: 1.4;
    border-radius: 20px;
    border-color: blue;
}
</code></pre>
<p>Scss</p>
<pre><code>.box {
    font: {
        family: fantasy;
        size: 1.2em;
        line-hight: 1.4;
    }
    border: {
        radius: 20px;
        color: blue;
    }
}
</code></pre>
<h1 id="进阶使用">进阶使用</h1>
<h2 id="31-变量">3.1 变量</h2>
<p>scss中我们可以使用<code>$</code>声明变量</p>
<pre><code>$width ：50px
.box {
    width: $width;
}
</code></pre>
<h2 id="32-数学运算">3.2 数学运算</h2>
<pre><code>.box {
    width: (100+20)*3px;
}
</code></pre>
<h2 id="33-插值">3.3 插值</h2>
<p>我们可以使用插值<code>#{}</code>把变量包裹起来</p>
<pre><code>$sizeKey ： 1
  .font-#{$sizeKey} {
    font-size: 12px
  }

p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};
    // font: 12px/30px;
}
</code></pre>
<h2 id="34-导入文件">3.4 导入文件</h2>
<p>需要使用<code>@import</code></p>
<p><code>@import 'style.scss';</code></p>
<h2 id="35-媒体查询">3.5 媒体查询</h2>
<pre><code>// scss
$media: screen;
$feature: -webkit-min-device-pixel-ratio;
$value: 1.5;
.box{
    @media #{$media} and ($feature: $value) {
      height: 300px;
      width: 900px;
    }
}
</code></pre>
<h2 id="36-继承">3.6 继承</h2>
<p>通过关键字<code>@extend</code>即可完成继承。</p>
<pre><code>.box {
    height: 300px;
    width: 900px;
}
.smallBox {
    @extend .box;
    background: red;
}
// 效果为

.smallBox {
    background: red;
}
.box, .smallBox {
    height: 300px;
    width: 900px;
}
</code></pre>
<h2 id="37-mixin和函数">3.7 mixin和函数</h2>
<p>使用@mixin指令声明一个函数，函数作用域内的属性都是return的值，使用@include使用函数</p>
<pre><code>@mixin border-radius {
    -moz-border-radius: 5px;
    -webkit-border-radius: 5px;
    border-radius: 5px;
}
.box {
    @include border-radius；
}
// 无参数函数使用有点像继承
</code></pre>
<p>函数传参的时候我们还可以设置默认值</p>
<pre><code>@mixin get-border-radius($border-radius: 5px){
    -moz-border-radius: $border-radius;
    -webkit-border-radius: $border-radius;
    border-radius: $border-radius;
}
.box1 {
    @include get-border-radius; 
    //不传参则默认为5px
}
.box2 {
    @include get-border-radius($border-radius:10px); 
    //结果为10px
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于node实现一个crud通用模型]]></title>
        <id>https://skrupellose.github.io/post/ji-yu-node-shi-xian-yi-ge-crud-de-demo/</id>
        <link href="https://skrupellose.github.io/post/ji-yu-node-shi-xian-yi-ge-crud-de-demo/">
        </link>
        <updated>2020-06-04T15:23:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-起步">一、起步</h1>
<h2 id="11-准备工作">1.1 准备工作</h2>
<p>下载<code>express</code>、<code>inflection</code><br>
这里我选择的是MongoDB数据库，所以还要下载<code>mongoose</code></p>
<h2 id="12-开始">1.2 开始</h2>
<p>然后我们开始设计后端路由，一般前端向后端发起请求的url都是<code>http://xxxxx/api/xxx</code>的格式。<br>
其中我们可以获取数据（get）、发送数据（post）、更新数据（put）、删除数据（delete）等<br>
最后末尾的后缀一般都是具体接口名，大部分后端处理的时候，只是接口名称不同，逻辑是相通的。所以我们可以将其作为一个url动态参数来接收和处理。</p>
<h1 id="二-代码实现">二、代码实现</h1>
<h2 id="21">2.1</h2>
<p>首先先写上接口，但是具体路径不写，我们要在后面先做处理</p>
<pre><code>  // 发送信息
  router.post('/', async (req, res) =&gt; {

  })

  // 获取信息
  router.get('/',  async (req, res) =&gt; {

  })

  // 更新信息
  router.put('/:id', async (req, res) =&gt; {

  })

  // 获取指定id信息
  router.get('/:id',  async (req, res) =&gt; {

  })

  //删除指定id信息
  router.delete('/:id', async (req, res) =&gt; {

  })
</code></pre>
<h1 id="22">2.2</h1>
<p>然后在<code>app.use()</code>中为请求的地址添加动态参数，来匹配接口里的url参数</p>
<pre><code>  app.use('/admin/api/rest/:resource', router)
</code></pre>
<h1 id="23">2.3</h1>
<p>修改之后我们在接口操作的时候需要使用对应的模型<br>
我们模型名称是接口地址参数的复数形式，需要做个处理<br>
首先我们要添加一个参数</p>
<pre><code>module.exports = app =&gt; {
  const express = require('express')
  const router = express.Router({
    //父级url参数合并到router内，否则router访问不了该动态参数
    mergeParams: true
  })
}
</code></pre>
<p>然后写一个处理的中间件：resourcemiddleware()</p>
<pre><code>module.exports = Options =&gt; {
  return async (req, res, next) =&gt; {
    //使用inflection进行类名格式转换
  const modelName = require('inflection').classify(req.params.resource)
  req.Model = require(`../models/${modelName}`)
  next()
  }
}
</code></pre>
<p>然后添加这个中间件：<code>app.use('/admin/api/rest/:resource',resourcemiddleware(), router)</code><br>
这样我们就能通过参数获取对应的model，之后就能进行各种操作：<br>
eg：</p>
<pre><code>  router.post('/', async (req, res) =&gt; {
    const model = await req.Model.create(req.body)
    res.send(model)
  })

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http与https]]></title>
        <id>https://skrupellose.github.io/post/http/</id>
        <link href="https://skrupellose.github.io/post/http/">
        </link>
        <updated>2020-04-01T11:28:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-http和https发展历史">一、http和https发展历史</h1>
<p><strong>什么是http？</strong><br>
超文本传输协议，是一种基于请求与响应、无状态的、应用层的协议，长基于tcp/ip协议，互联网上应用最为广泛的一种协议，所有的www文件都必须遵守这个标准。设计http的初衷是为了提供一种发布和接受HTML页面的方法。<br>
<strong>发展历史</strong></p>
<table>
<thead>
<tr>
<th>版本</th>
<th>产生时间</th>
<th>内容</th>
<th>发展现状</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP/0.9</td>
<td>1991年</td>
<td>不涉及数据包的传输，规定客户端和服务器之间通信格式只能GET请求</td>
<td>没有能作为正式的标准</td>
</tr>
<tr>
<td>HTTP/1.0</td>
<td>1996年</td>
<td>传输内容格式不限定，增加了PUT、PATCH、HEAD、OPTIONS、DELETE命令</td>
<td>正式作为标准</td>
</tr>
<tr>
<td>HTTP/1.1</td>
<td>1997年</td>
<td>持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码</td>
<td>2015年前使用最为广泛</td>
</tr>
<tr>
<td>HTTP/2</td>
<td>2015年</td>
<td>多路复用、服务器推送、头信息压缩、二进制协议</td>
<td>逐渐的覆盖市场</td>
</tr>
</tbody>
</table>
<p><strong>多路复用</strong><br>
通过单一的HTTP/2连接请求发起多重请求-响应消息，多个请求流共享一个tcp连接，实现多流并行而不是依赖建立多个tcp连接，大大提高工作效率<br>
<strong>http报文格式</strong></p>
<ul>
<li>请求报文由请求行与首部行组成。请求行内容为<code>请求方法 - URL - 版本</code>组成、首部行是由一个个首部字段名与其对应的值组成的集合以及实体主体信息（GET通常不用）组成的</li>
<li>响应报文由状态行与首部行组成。状态行内容为<code>版本-状态码-短语</code>组成、首部行内容与请求报文相同</li>
</ul>
<p><strong>什么是https？</strong><br>
https是身披SSL外壳的http。https是一种通过计算机网络进行安全通信的传输协议，经由http协议进行通信，利用SSL/TLS建立全信道，加密数据包。https使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私和完整性。<br>
ps：TLS是传输层加密协议，前身是SSL协议，由网景公司于1995年发布。</p>
<h1 id="二-http-vs-https">二、http VS https</h1>
<h1 id="21-http特点">2.1 http特点</h1>
<ol>
<li>无状态：协议对客户端没有状态存储，对事物处理没有记忆能力，比如访问一个网站需要反复进行登录操作</li>
<li>无状态：HTTP/1.1 之前由于无状态的特点，每次请求都需要通过三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次都需要重新响应请求，需要耗费不必要的时间和流量</li>
<li>基于请求和响应：客户端发起请求，服务器响应请求</li>
<li>简单快速、灵活</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li>
</ol>
<h1 id="22-https特点">2.2 https特点</h1>
<p>基于http协议，通过SSL或者TLS提供加密处理数据、验证对方身份以及数据完整性保护</p>
<ol>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li>
<li>验证身份：通过证书验证客户端访问的是自己的服务器</li>
<li>保护数据完整性：防止传输的内容被中间人冒充和修改</li>
<li>接收方能够证实发送方的真实身份</li>
<li>发送方事后不能否认自己发送过的报文</li>
<li>接收方和第三者不能伪造、篡改报文</li>
</ol>
<p><strong>混合加密</strong>：结合对称加密和非对称加密技术，客户端使用对称加密生成密钥对传输的数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，使用网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘钥，即使被截取没有私钥也无法对内容进行解密，无法获取明文数据<br>
<strong>数字摘要</strong>：通过单向的hash函数对原文进行哈希处理，将需要加密的明文”摘要“成一串固定长度的密文，不同明文摘要其密文结果不同，同样的明文其摘要必定一致，并且通过密文不能反推出明文<br>
<strong>数字签名技术</strong>：数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用，它把公钥加密和数字摘要结合起来，形成实用的数字签名技术。</p>
<h1 id="三-http通信传输">三、http通信传输</h1>
<p>客户端通过输入URL回车，DNS解析域名得到服务器的IP地址，服务器在80端口监听客户端的请求，端口通过tcp/ip协议建立连接，http属于tcp/ip模型中的应用层协议，属于通信的过程其实是对应数据的入栈和出栈。<br>
<strong>传输步骤</strong>：</p>
<ol>
<li>三次握手建立tcp连接</li>
<li>浏览器向服务器发送请求命令</li>
<li>浏览器向服务器发送请求头信息，如：user-agent，host之类关于自身的信息，最后发送一个空请求头表示请求头信息发送完毕，如果是post提交，会继续提交请求体</li>
<li>服务器应答，应答的第一部分是版本号与状态码</li>
<li>服务器向客户端发送应答头信息，关于它自己的信息以及客户端之前请求的文档，最后也发送一个空白行表示头信息发送完毕</li>
<li>服务器向客户端发送数据，以Content-Type应答头信息所描述的格式发送用户所请求的数据</li>
<li>四次挥手关闭tcp连接</li>
</ol>
<h1 id="四-https工作流程">四、https工作流程</h1>
<ol>
<li>首先浏览器发送请求访问一个网址，发送的信息主要是随机值1和自己支持的加密算法</li>
<li>服务器收到消息后返回随机值2和一个为浏览器发送过来的所支持加密算法的一个算法子集，之后发送第二个响应报文：CA签字认证并进行加密后的证书，里面包括服务器的公钥和数字签名，数字签名通过CA公钥解密后可以得到证书的信息摘要</li>
<li>浏览器信任CA颁发的证书并且知晓CA的公钥 ，然后去解析验证服务器返回的那个证书，这部分由TLS完成，看公钥是否有效等。浏览器用CA公钥解密证书中的数字签名后得到一个证书的信息摘要，然后再通过CA证书签名的方法对这个摘要进行处理，与接收的签名进行比对，若不同则检验出不匹配。若有异常情况浏览器进行弹窗提醒，若正常就会生成一个随机值3</li>
<li>验证成功之后，浏览器会创建一个通过随机值1、2、3组装成的会话秘钥并且使用服务器返回的公钥进行非对称加密</li>
<li>服务器收到这个加密后的秘钥通过自己的私钥进行解密得到随机值1、2、3，然后组装成会话秘钥之后双方就使用这个会话秘钥对通信进行对称加密</li>
<li>客户端会通过这个会话秘钥加密一条消息发送给服务器，来验证服务器是否可以正常接收客户端的加密消息</li>
<li>服务器也会通过会话秘钥加密一条消息回传给客户端，若客户端也能正常接受就证明SSL层连接建立完成</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React学习笔记]]></title>
        <id>https://skrupellose.github.io/post/react-xue-xi-bi-ji/</id>
        <link href="https://skrupellose.github.io/post/react-xue-xi-bi-ji/">
        </link>
        <updated>2020-03-09T02:30:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="yi">yi</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB笔记]]></title>
        <id>https://skrupellose.github.io/post/mongodb-bi-ji/</id>
        <link href="https://skrupellose.github.io/post/mongodb-bi-ji/">
        </link>
        <updated>2020-03-04T09:54:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-关于mongodb">一、 关于MongoDB</h1>
<p>MongoDB是一个面向文档的数据库管理系统，用C++语言编写。</p>
<h1 id="二-简单上手使用">二、简单上手使用</h1>
<h2 id="21-下载安装">2.1 下载安装</h2>
<p><a href="https://www.mongodb.com/">官网</a><br>
然后正常安装</p>
<h2 id="22-软件使用">2.2 软件使用</h2>
<ol>
<li>
<p>选一个磁盘来存储数据<br>
比如想在D盘存储数据，那么我们就需要在D盘下新建一个<code>data</code>文件夹，再在其中新建<code>db</code>文件夹，这样我们后面数据库的数据就会被保存在<code>db</code>文件夹</p>
</li>
<li>
<p>启动MongoDB<br>
打开CMD，切换到D盘，执行<code>mongod</code>启动命令，然后最小化。</p>
</li>
<li>
<p>操作数据库<br>
输入<code>mongo</code>就可以进行数据库的相关操作</p>
<h2 id="23-一些基本命令">2.3 一些基本命令</h2>
<ol>
<li>切换/创建数据库<br>
<code>use DBname</code></li>
<li>删除当前数据库<br>
<code>db.dropDatabase()</code></li>
<li>查询数据库<br>
<code>show dbs</code></li>
<li>得到当前数据库所有集合<br>
<code>db.getCollectionNames();</code></li>
<li>集合查询所有记录<br>
<code>db.collectionname.find()</code></li>
</ol>
</li>
</ol>
<h2 id="24-node操作mongodb">2.4 Node操作MongoDB</h2>
<pre><code>var mongoose = require ('mongoose')
var Schema = mongoose.Schema

mongoose.connect('mongodb://localhost/dbName',{ useNewUrlParser: true })

var userSchema = new Schema({
  username: {
    type: String,
    required: true
  },
  password: {
    type: String,
    required: true
  }
})

var User = mongoose.model('User', userSchema)
//第三个参数写集合名，默认是模型名全小写加&quot;s&quot;,但有的特殊名词的复数就需要自己定义好，防止查找失败
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise与相关题型]]></title>
        <id>https://skrupellose.github.io/post/promise/</id>
        <link href="https://skrupellose.github.io/post/promise/">
        </link>
        <updated>2020-03-04T03:31:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-promise">一、Promise</h1>
<h2 id="11-promise概念">1.1 Promise概念</h2>
<h3 id="111-关于promise">1.1.1 关于Promise</h3>
<p>Promise是es6新增的一个API，它本身不是异步的，但是它内部进行封装的往往是异步任务。</p>
<p>Promise容器最开始的状态是<code>Pending</code>，它最后会根据内部任务的成功与否改为<code>Resolved</code>（成功）和<code>Rejected</code>（失败），且不会再次改变状态</p>
<p><strong>Promise容器一旦创建，就开始执行里面的代码</strong></p>
<pre><code>var fs = require('fs')
new Promise(function () {
  fs.readFile('./a.txt','utf8',function(err, data){
    if(err) {
      console.log(err)
    }
    console.log(data)
  })
})
// 就会立马打印出a.txt的内容出来
</code></pre>
<h3 id="112-promise基础语法">1.1.2 Promise基础语法</h3>
<pre><code>var p1 = new Promise(function(resolve, reject) {
  fs.readFile('./a.txt','utf8',function(err, data) {
    if(err) {
      reject(err)
    }
    resolve(data)
  })
})
p1.then(function(data){
  console.log(data)
},function(err){
  console.log(err)
})
</code></pre>
<p>还是刚才的例子我们通过<code>Promise</code>构造函数构造了一个名为p1的<code>Promise</code>实例：<br>
然后在<code>Promise</code>构造函数中传了两个函数作为参数，一个是<code>resolve</code>；一个是<code>reject</code>。<br>
之后在fs.readFile执行后，根据执行结果分别执行<code>reject</code>和<code>resolve</code>方法。<br>
我们想要拿到结果就需要通过构造出的<code>Promise</code>实例的<code>then</code>方法。<br>
<code>then</code>方法也是接受两个函数作为形参，第一个是对应成功时执行；第二个是对应失败后执行。两个方法分别对应上面的<code>resolve</code>和<code>reject</code>。</p>
<p>关于then方法的链式调用需要介绍：<br>
当then方法执行完之后return一个对象，我们就可以对这个对象进行处理，当我们面对回调嵌套的时候就可以使用Promise。</p>
<pre><code>p1.then(function(data){
  console.log(data)
  return p2
}).then(function(data) {
  console.log(data)
  return p3
}).then(function(data){
  console.log(data)
})
</code></pre>
<p>then方法的第一个形参就是调用then方法的实例的resolve方法。<br>
如果return的是一个简单数据类型，那么充当then方法的形参的那个方法就能获取的这个值。</p>
<h1 id="二-promise基础题型">二、promise基础题型</h1>
<h2 id="21-题目1">2.1 题目1</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  console.log(2);
});
promise.then(() =&gt; {
  console.log(3);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li>结果并不是<code>1 2 4 3</code></li>
<li>虽然promise.then属于微任务，但是前面新建的promise对象过程中并没有改变状态。因此promise.then并不会执行</li>
<li>所以执行结果为<code>1 2 4</code></li>
</ul>
<h2 id="22-题目2">2.2 题目2</h2>
<pre><code>const promise1 = newPromise((resolve, reject) =&gt; {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res =&gt; {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);
</code></pre>
<p>tips：</p>
<ul>
<li>第一轮宏任务首先执行<code>promise1</code></li>
<li>然后将<code>promise1</code>的状态修改为<code>resolved</code>，然后保存结果</li>
<li>把<code>promise2</code>放入微任务队列，等待执行</li>
<li>接着执行同步代码1，结果为<code>resolved</code></li>
<li>然后执行同步代码2，结果为<code>pending</code>，因为此时<code>promise2</code>被放入微任务队列还没执行，promise状态为<code>pending</code><br>
所以结果为:</li>
</ul>
<pre><code>'promise1'
'1' Promise{&lt;resolved&gt;: 'resolve1'}
'2' Promise{&lt;pending&gt;}
'resolve1'
</code></pre>
<h2 id="23-题目3">2.3 题目3</h2>
<pre><code>const fn = () =&gt;(new Promise((resolve, reject) =&gt; {
  console.log(1);
  resolve('success')
}))
fn().then(res =&gt; {
  console.log(res)
})
console.log('start')
</code></pre>
<p>tips：</p>
<ul>
<li>首先执行<code>fn</code>函数，它返回一个promise对象，并且将状态修改为<code>resolved</code>，因此首先打印1</li>
<li>然后将<code>.then()</code>放入微任务队列</li>
<li>接着执行同步任务打印<code>start</code></li>
<li>之后执行任务.then()，打印<code>success</code><br>
所以结果为：</li>
</ul>
<pre><code>1
start
success
</code></pre>
<h1 id="三-promise结合定时器">三、promise结合定时器</h1>
<h2 id="31-题目1">3.1 题目1</h2>
<pre><code>console.log('start')
setTimeout(() =&gt; {
  console.log('time')
})
Promise.resolve().then(() =&gt; {
  console.log('resolve')
})
console.log('end')
</code></pre>
<p>tips:</p>
<ul>
<li>首先按照执行顺序，打印<code>start</code></li>
<li>然后遇到定时器将其放入下一个宏任务队列</li>
<li>将<code>promise.then()</code>也放入微任务队列</li>
<li>打印<code>end</code></li>
<li>执行<code>promise.then</code>打印resolve</li>
<li>执行定时器打印<code>time</code></li>
<li>这里还需要注意的是<code>Promise.resolve()</code>相当于定义一个状态为<code>fullfilled</code>的<code>promise</code>，只有<code>fullfilled</code>状态的<code>promise</code>才能执行<code>.then()</code><br>
执行结果：</li>
</ul>
<pre><code>start
end
resolve
time
</code></pre>
<h2 id="32-题目2">3.2 题目2</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  setTimeout(() =&gt; {
    console.log(&quot;timerStart&quot;);
    resolve(&quot;success&quot;);
    console.log(&quot;timerEnd&quot;);
  }, 0);
  console.log(2);
});
promise.then((res) =&gt; {
  console.log(res);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li>首先打印<code>1</code></li>
<li>然后将定时器加入下次宏任务队列</li>
<li>打印<code>2</code></li>
<li>将<code>promise.then</code>加入微任务队列</li>
<li>打印<code>4</code></li>
<li>暂不执行<code>promise.then()</code>，虽然此时应该执行微任务中的<code>.then()</code>,但此时<code>promise</code>状态还为<code>pending</code>，所以不执行</li>
<li>最后开始执行宏任务里的定时器打印出timerstart，修改promise状态为<code>resolved</code>，打印<code>timerend</code></li>
<li>此时promise状态已为<code>resolved</code>，开始执行微任务中的<code>.then()</code>，打印出<code>success</code><br>
执行结果：</li>
</ul>
<pre><code>1
2
4
timerstart
timerend
success
</code></pre>
<h2 id="33-题目3">3.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  console.log('promise1');
  const timer2 = setTimeout(() =&gt; {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() =&gt; {
  console.log('timer1')
  Promise.resolve().then(() =&gt; {
    console.log('promise2')
  })
}, 0)
console.log('start');
</code></pre>
<p>tips:</p>
<ul>
<li>首先把<code>promise.then()</code>放入微任务队列</li>
<li>将<code>timer1</code>放入宏任务队列</li>
<li>打印<code>start</code></li>
<li>执行微任务中的<code>promise.then()</code></li>
<li>打印<code>promise1</code></li>
<li>将<code>timer2</code>放入宏任务队列</li>
<li>执行<code>timer1</code>，打印<code>timer1</code>，将第二个<code>promise.then()</code>放入微任务队列</li>
<li>执行第二个<code>promise.then()</code>，打印<code>promise2</code></li>
<li>执行<code>timer2</code>，打印<code>timer2</code></li>
</ul>
<p>执行结果</p>
<pre><code>start
promise1
timer1
promise2
timer2
</code></pre>
<h2 id="34-题目4">3.4 题目4</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() =&gt; {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() =&gt; {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)
</code></pre>
<p>tips:</p>
<ul>
<li>首先执行<code>promise1</code>，将定时器放入宏任务队列</li>
<li>把<code>promise2</code>放入微任务队列</li>
<li>执行同步代码，打印<code>promise1</code>，此时<code>promise1</code>还未改变状态，所以为<code>pending</code></li>
<li>执行同步代码，打印<code>promise2</code>，由于<code>promise1.then()</code>返回的还是一个<code>promise</code>对象，所以为<code>pending</code></li>
<li>将定时器放入宏任务队列</li>
<li><code>promise2</code>暂不执行，因为<code>p1</code>的状态还未修改</li>
<li>执行第一个定时器，将<code>promise1</code>状态修改为<code>resolved</code></li>
<li>执行<code>p2</code>，<code>throw</code>一个错误<code>error</code></li>
<li>执行第二个定时器，打印<code>resolved和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<h2 id="35-题目5">3.5 题目5</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;success&quot;);
    console.log(&quot;timer1&quot;);
  }, 1000);
  console.log(&quot;promise1里的内容&quot;);
});
const promise2 = promise1.then(() =&gt; {
  throw new Error(&quot;error!!!&quot;);
});
console.log(&quot;promise1&quot;, promise1);
console.log(&quot;promise2&quot;, promise2);
setTimeout(() =&gt; {
  console.log(&quot;timer2&quot;);
  console.log(&quot;promise1&quot;, promise1);
  console.log(&quot;promise2&quot;, promise2);
}, 2000);
</code></pre>
<p>tips：</p>
<ul>
<li>执行<code>p1</code>，将第一个定时器放入宏任务队列，并打印<code>p1</code>里的内容</li>
<li>把<code>p2</code>放入微任务队列</li>
<li>执行同步代码，打印两个<code>pending</code></li>
<li>把第二个定时器加入宏任务队列</li>
<li>p1状态未修改暂不执行p2</li>
<li>执行第一个定时器修改p1的状态并打印<code>timer1</code></li>
<li>执行微任务throw一个错误修改p2状态为<code>rejected</code></li>
<li>执行第二个定时器，打印<code>timer2</code>后分别打印<code>resolved:success和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1里的内容'
'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
'timer1'
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'timer2'
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<h1 id="四-promise进阶">四、promise进阶</h1>
<h2 id="41-题目1">4.1 题目1</h2>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
  reject(&quot;error&quot;);
  resolve(&quot;success2&quot;);
});
promise
.then(res =&gt; {
    console.log(&quot;then1: &quot;, res);
  }).then(res =&gt; {
    console.log(&quot;then2: &quot;, res);
  }).catch(err =&gt; {
    console.log(&quot;catch: &quot;, err);
  }).then(res =&gt; {
    console.log(&quot;then3: &quot;, res);
  })
</code></pre>
<p>tips：</p>
<ul>
<li>promise状态一经改变便不会再次改变，所以promise状态为<code>rejected</code></li>
<li>之后将<code>promise.then()</code>加入微任务队列</li>
<li>直到被<code>catch</code>捕获错误，<code>catch</code>不论连接在哪里都可以捕获到上级错误</li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;catch: &quot; &quot;error&quot;
&quot;then3: &quot; undefined
</code></pre>
<h2 id="42-题目2">4.2 题目2</h2>
<pre><code>Promise.resolve(1)
  .then(res =&gt; {
    console.log(res);
    return2;
  })
  .catch(err =&gt; {
    return3;
  })
  .then(res =&gt; {
    console.log(res);
  });
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve(1)</code>内部返回的结果是1，打印得到1</li>
<li><code>return2</code>被包装成为<code>resolve(2)</code>，所以该<code>promise</code>对象返回值为2</li>
<li><code>resolve</code>下不走<code>catch</code>，<code>.then</code>打印得到<code>2</code></li>
</ul>
<h2 id="43-题目3">4.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  return new Error('error!!!')
}).then(res =&gt; {
  console.log(&quot;then: &quot;, res)
}).catch(err =&gt; {
  console.log(&quot;catch: &quot;, err)
})
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve().then()</code>return一个错误,当promise对象返回的不是一个promise对象的话就会被包装成一个promise对象，<code>return new Error('error!!!')</code>会被包装成<code>return Promise.resolve(new Error('error!!!'))</code></li>
<li>因此走的是.then()而不是.catch()</li>
<li>若想抛出错误，可以<code>return Promise.reject(newError('error!!!'));</code>或者<code>throw newError('error!!!')</code></li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;then: &quot; &quot;Error: error!!!&quot;
</code></pre>
<h2 id="44-题目4">4.4 题目4</h2>
<pre><code>const promise = Promise.resolve().then(() =&gt; {
  return promise;
})
promise.catch(console.err)
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>或者<code>.catch()</code>不能返回promise自身</li>
<li>所以会报错</li>
</ul>
<p>执行结果：</p>
<pre><code>Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
</code></pre>
<h2 id="45-题目5">4.5 题目5</h2>
<pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre>
<p>tips：</p>
<ul>
<li><code>promise.then()</code>和<code>.catch()</code>的期望值是函数</li>
<li>传入非函数就会发生值传透</li>
<li>第一个<code>then</code>传的是数字</li>
<li>第二个<code>then</code>传的是对象</li>
<li>所以第三个<code>then</code>获取的值是<code>1</code></li>
</ul>
<p>执行结果：</p>
<pre><code>1
</code></pre>
<h2 id="46-题目6">4.6 题目6</h2>
<pre><code>Promise.reject('err!!!')
  .then((res) =&gt; {
    console.log('success', res)
  }, (err) =&gt; {
    console.log('error', err)
  }).catch(err =&gt; {
    console.log('catch', err)
  })
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>有两个参数，一个是用来处理<code>promise</code>成功的函数，另一个是处理失败的函数</li>
<li>当有处理失败函数的时候，错误会走失败的函数而不会走.catch()</li>
</ul>
<p>执行结果：</p>
<pre><code>'error' 'error!!!'
</code></pre>
<ul>
<li>若不写第二个函数，则会走<code>.catch()</code>函数</li>
<li>若在执行成功的函数中抛出一个错误，则该错误只能在<code>.catch()</code>中捕获到，不能在第二个处理错误的函数中被捕获</li>
</ul>
<h2 id="47-题目7">4.7 题目7</h2>
<pre><code>Promise.resolve('1')
  .then(res =&gt; {
    console.log(res)
  })
  .finally(() =&gt; {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() =&gt; {
    console.log('finally2')
  	return'我是finally2返回的值'
  })
  .then(res =&gt; {
    console.log('finally2后面的then函数', res)
  })
</code></pre>
<p>tips:</p>
<ul>
<li>第一个<code>promise</code>修改状态为<code>resolved</code>并得到返回值<code>1</code></li>
<li>将<code>.then()</code>移入微任务队列</li>
<li>因为<code>.then()</code>和<code>.finally()</code>是链式调用，<code>.then()</code>不执行，<code>.finally()</code>也不会执行，所以这里会跳出第一个promise函数</li>
<li>第二个promise修改状态为<code>resolved</code>并得到返回值<code>2</code></li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>将第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.then()</code>移入微任务队列</li>
<li>开始执行第一个<code>.then()</code>,得到1</li>
<li>执行第二个<code>.finally()</code>,打印<code>finally2</code>，且返回一个新的值</li>
<li>执行第一个<code>.finally()</code>,打印<code>finally</code></li>
<li>执行第二个<code>.then()</code>,打印结果2，因为<code>.finally()</code>默认返回的都是原来的<code>promise</code>对象的值，只有当抛出的是一个错误，才会返回这个错误*</li>
</ul>
<p>执行结果：</p>
<pre><code>1
finally2
finally
finally2后面的then函数 2
</code></pre>
<p>*:</p>
<pre><code>Promise.resolve('1')
  .finally(() =&gt; {
    console.log('finally1')
    throw new Error('我是finally中抛出的异常')
  })
  .then(res =&gt; {
    console.log('finally后面的then函数', res)
  })
  .catch(err =&gt; {
    console.log('捕获错误', err)
  })
</code></pre>
<pre><code>'finally1'
'捕获错误' Error: 我是finally中抛出的异常
</code></pre>
<h2 id="48-题目8">4.8 题目8</h2>
<pre><code>function promise1 () {
  let p = new Promise((resolve) =&gt; {
    console.log('promise1');
    resolve('1')
  })
  return p;
}
function promise2 () {
  return new Promise((resolve, reject) =&gt; {
    reject('error')
  })
}
promise1()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally1'))

promise2()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally2'))
</code></pre>
<p>tips:</p>
<ul>
<li><code>p1</code>执行，打印<code>promise1</code>，并且修改<code>promise1</code>状态值为<code>resolved</code>，返回<code>1</code></li>
<li>把第一个<code>.then()</code>移入微任务队列</li>
<li>执行<code>p2</code>，返回一个<code>rejected</code>状态的<code>promise</code>对象，返回值为<code>error</code></li>
<li>因为<code>p2</code>状态为<code>rejected</code>，所以第二个<code>.then()</code>不会执行将第二个<code>.catch</code>移入微任务队列</li>
<li>执行第一个<code>.then()</code>，打印<code>1</code></li>
<li>执行第二个<code>.catch()</code>, 打印<code>error</code></li>
<li>之后把第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>执行第一个<code>.finally()</code>，打印<code>finally1</code></li>
<li>执行第二个<code>.finally()</code>，打印<code>finally2</code></li>
</ul>
<p>执行结果：</p>
<pre><code>promise1
1
error
finally1
finally2
</code></pre>
<h2 id="49-题目9">4.9 题目9</h2>
<pre><code>function runAsync (x) {
	const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
	return p
}
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt;console.log(res))
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.all(</code>)并行执行多个异步操作，并在一个回调中处理所有的数据</li>
</ul>
<p>执行结果：</p>
<pre><code>1
2
3
[1, 2, 3]
</code></pre>
<h2 id="410-题目10">4.10 题目10</h2>
<pre><code>function runAsync (x) {
  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
  return p
}
function runReject (x) {
  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.all()</code>中参数的顺序就是加入任务队列的顺序，但是定时器执行先后由时间长短排序</li>
<li>所以执行顺序为<code>runAsync(1)</code>、 <code>runAsync(3)</code>、 <code>runReject(2)</code>、<code>runReject(4)</code></li>
<li>又因为<code>runReject</code>函数抛出错误，所以<code>promise.all().then()</code>不会执行，而<code>.catch()</code>会捕获<code>.all()</code>之中最先的异常</li>
</ul>
<p>执行结果：</p>
<pre><code>1
3
// 2s后输出
2
Error: 2
// 4s后输出
4
</code></pre>
<h2 id="411-题目11">4.11 题目11</h2>
<pre><code>function runAsync (x) {
const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
return p
}
Promise.race([runAsync(1), runAsync(2), runAsync(3)])
.then(res =&gt;console.log('result: ', res))
.catch(err =&gt;console.log(err))
</code></pre>
<p>tips：</p>
<ul>
<li><code>.race()</code>只会获取最先执行完的结果</li>
</ul>
<p>执行结果：</p>
<pre><code>1
'result: ' 1
2
3
</code></pre>
<h1 id="五-async和await">五、async和await</h1>
<h2 id="51-题目1">5.1 题目1</h2>
<pre><code>async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
}
async function async2() {
  console.log(&quot;async2&quot;);
}
async1();
console.log('start')
</code></pre>
<p>tips：</p>
<ul>
<li><code>async1</code>函数执行，打印<code>async1 start</code></li>
<li>执行<code>async2</code>函数，打印<code>async2</code></li>
<li>跳出<code>async1</code>，打印<code>start</code></li>
<li>再打印<code>async1 end</code></li>
<li><code>await</code>后面的内容将放到下一次执行，类似于<code>promise.then()</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'async start'
'promise'
'async1 end'
'start'
</code></pre>
<h2 id="52-题目2">5.2 题目2</h2>
<pre><code>async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
}
async function async2() {
  setTimeout(() =&gt; {
    console.log('timer')
  }, 0)
  console.log(&quot;async2&quot;);
}
async1();
console.log(&quot;start&quot;)
</code></pre>
<p>tips:</p>
<ul>
<li>与上一道题不同的是async2函数内多了一个定时器，定时器会被放到下一次宏任务中执行</li>
</ul>
<p>执行结果：</p>
<pre><code>async1 start
async2
start
async1 end
timer
</code></pre>
<h2 id="53-题目3">5.3 题目3</h2>
<pre><code>async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
  setTimeout(() =&gt; {
    console.log('timer1')
  }, 0)
}
async function async2() {
  setTimeout(() =&gt; {
    console.log('timer2')
  }, 0)
  console.log(&quot;async2&quot;);
}
async1();
setTimeout(() =&gt; {
  console.log('timer3')
}, 0)
console.log(&quot;start&quot;)
</code></pre>
<p>tips：</p>
<ul>
<li><code>async1</code>函数执行，打印<code>async1 start</code></li>
<li><code>async2</code>函数执行，将<code>timer2</code>移入宏任务队列，然后打印<code>async2</code></li>
<li>将<code>timer3</code>移入宏任务队列</li>
<li>打印<code>start</code></li>
<li>打印<code>async1 end</code>并且将<code>timer1</code>移入宏任务队列</li>
<li>执行第一个宏任务，打印<code>timer2</code>，微任务队列没有任务，将剩下的两个宏任务依次执行打印<code>timer3</code>和<code>timer1</code></li>
</ul>
<p>执行结果：</p>
<pre><code>async1 start
async2
start
async1 end
timer2
timer3
timer1
</code></pre>
<h2 id="54-题目4">5.4 题目4</h2>
<pre><code>async function async1 () {
  console.log('async1 start');
  await new Promise(resolve =&gt; {
    console.log('promise1')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('script start')
async1().then(res =&gt;console.log(res))
console.log('script end')
</code></pre>
<p>tips:</p>
<ul>
<li>打印<code>script start</code></li>
<li><code>async1</code>执行</li>
<li>打印<code>async1 start</code></li>
<li>新创建一个<code>promise</code>对象，打印<code>promise1</code></li>
<li>将<code>.then()</code>加入微任务队列</li>
<li>打印<code>script end</code></li>
<li>由于新创建的<code>promise</code>对象并没有改变状态，所以<code>.then()</code>不会执行，<code>await</code>后面的内容也不会执行</li>
</ul>
<p>执行结果：</p>
<pre><code>'script start'
'async1 start'
'promise1'
'script end'
</code></pre>
<h2 id="55-题目5">5.5 题目5</h2>
<pre><code>async function async1 () {
  console.log('async1 start');
  await new Promise(resolve =&gt; {
    console.log('promise1')
    resolve('promise1 resolve')
  }).then(res =&gt;console.log(res))
  console.log('async1 success');
  return 'async1 end'
}
console.log('script start')
async1().then(res =&gt;console.log(res))
console.log('script end')
</code></pre>
<p>tips:</p>
<ul>
<li>打印<code>script start</code></li>
<li><code>async1</code>执行，打印<code>async1 start</code></li>
<li>新建一个<code>promise</code>对象，打印<code>promise1</code>，修改状态为<code>resolved</code>，返回值为<code>promise1 resolve</code></li>
<li>打印<code>script end</code></li>
<li>执行<code>.then()</code></li>
<li>打印<code>async1 success</code></li>
<li>修改<code>promise</code>返回值为<code>async1 end</code></li>
<li>执行第二个<code>.then()</code>，打印<code>async1 end</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'script start'
'async1 start'
'promise1'
'script end'
'promise1 resolve'
'async1 success'
'async1 end'
</code></pre>
<h2 id="56-题目6">5.6 题目6</h2>
<pre><code>async function testSometing() {
  console.log(&quot;执行testSometing&quot;);
  return&quot;testSometing&quot;;
}

async function testAsync() {
  console.log(&quot;执行testAsync&quot;);
  return Promise.resolve(&quot;hello async&quot;);
}

async function test() {
  console.log(&quot;test start...&quot;);
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
}

test();

var promise = newPromise(resolve =&gt; {
  console.log(&quot;promise start...&quot;);
  resolve(&quot;promise&quot;);
});
promise.then(val =&gt;console.log(val));

console.log(&quot;test end...&quot;);
</code></pre>
<p>tips:</p>
<ul>
<li>执行<code>test</code>函数，打印<code>test start</code></li>
<li>执行<code>testSomething</code>函数，打印<code>执行testSomething</code></li>
<li>跳出<code>test</code>函数，打印<code>promise start</code>并且修改promise的值和状态</li>
<li>将<code>.then()</code>加入微任务队列</li>
<li>打印<code>test end</code></li>
<li>打印<code>v1</code>的值 <code>testSomething</code></li>
<li>执行<code>testAsync</code>函数，打印<code>执行testAsync</code></li>
<li>跳出<code>tes</code>t函数，执行微任务的<code>.then()</code>,打印<code>promise</code></li>
<li>打印<code>v2</code>的值<code>hello async</code></li>
<li>打印<code>v1</code>、<code>v2</code>的值</li>
</ul>
<pre><code>'test start...'
'执行testSometing'
'promise start...'
'test end...'
'testSometing'
'执行testAsync'
'promise'
'hello async'
'testSometing' 'hello async'
</code></pre>
<h2 id="57-题目7">5.7 题目7</h2>
<pre><code>async function async1 () {
  await async2();
  console.log('async1');
  return 'async1 success'
}
async function async2 () {
  return new Promise((resolve, reject) =&gt; {
    console.log('async2')
    reject('error')
  })
}
async1().then(res =&gt;console.log(res))
</code></pre>
<p>tips:</p>
<ul>
<li><code>async</code>函数中抛出了错误，则不会往下继续执行</li>
<li><code>throw new Error</code>是一样的效果</li>
</ul>
<p>执行结果：</p>
<pre><code>'async2'
Uncaught (in promise) error
</code></pre>
<h2 id="58-题目8">5.8 题目8</h2>
<pre><code>async function async1 () {
  try {
    await Promise.reject('error!!!')
  } catch(e) {
    console.log(e)
  }
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res =&gt;console.log(res))
console.log('script start')
</code></pre>
<p>tips:</p>
<ul>
<li>若不想错误影响函数后面的执行则可以使用<code>try catch</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'script start'
'error!!!'
'async1'
'async1 success'
</code></pre>
<p>或者在<code>Promise.reject</code>后面跟着一个<code>catch()</code>方法</p>
<pre><code>async function async1 () {
   await Promise.reject('error!!!')
        .catch(e =&gt;console.log(e))
   console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res =&gt;console.log(res))
console.log('script start')
</code></pre>
<h1 id="六-综合题">六、综合题</h1>
<h2 id="61-题目1">6.1 题目1</h2>
<pre><code>const first = () =&gt;(new Promise((resolve, reject) =&gt; {
    console.log(3);
    let p = new Promise((resolve, reject) =&gt; {
        console.log(7);
        setTimeout(() =&gt; {
            console.log(5);
            resolve(6);
          	console.log(p)
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) =&gt; {
        console.log(arg);
    });

}));

first().then((arg) =&gt; {
    console.log(arg);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li><code>first</code>函数执行，打印<code>3</code></li>
<li>新建第二个<code>promise</code>对象，打印<code>7</code>，将定时器移入宏任务队列，并且修改值和状态为<code>1</code>和<code>resolved</code></li>
<li>将第一个<code>promise</code>对象的值和状态修改为<code>2</code>和<code>resolved</code></li>
<li>将<code>p.then()</code>移入微任务队列</li>
<li>将<code>first.then()</code>移入微任务队列</li>
<li>打印<code>4</code></li>
<li>执行<code>p.then()</code>打印<code>1</code></li>
<li>执行<code>first.then()</code>打印<code>2</code></li>
<li>最后执行宏任务里的定时器</li>
<li>打印<code>5</code>，修改<code>p</code>的状态和返回值，但是<code>p</code>的状态已经改变过了，所以不会再改变，打印<code>Promise{&lt;resolved&gt;: 1}</code></li>
</ul>
<p>执行结果：</p>
<pre><code>3
7
4
1
2
5
Promise{&lt;resolved&gt;: 1}
</code></pre>
<h2 id="62-题目2">6.2 题目2</h2>
<pre><code>const async1 = async () =&gt; {
  console.log('async1');
  setTimeout(() =&gt; {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve =&gt; {
    console.log('promise1')
    resolve(2)
  })
  console.log('async1 end')
  return 'async1 success'
}
console.log('script start');
async1().then(res =&gt;console.log(res));
console.log('script end');
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res =&gt;console.log(res))
setTimeout(() =&gt; {
  console.log('timer2')
}, 1000)
</code></pre>
<p>tips:</p>
<ul>
<li>打印<code>script start</code></li>
<li>执行<code>async1</code>函数，打印<code>async1</code>，将<code>timer1</code>移入宏任务队列</li>
<li>新创建一个<code>promise</code>对象，打印<code>promise1</code></li>
<li>跳出<code>async1</code>，打印<code>script end</code></li>
<li>获得一个状态为<code>resolved</code>且值为<code>1</code>的<code>promise</code>对象，由于发生值穿透，直接将最后一个<code>.then()</code>加入微任务队列</li>
<li>将<code>timer2</code>移入宏任务队列</li>
<li>new 的promise对象没有修改状态，所以下面的程序不会执行</li>
<li>把<code>async1().then()</code>加入微任务队列，依次执行两个微任务,又因为<code>async1</code>函数中的<code>promise</code>对象状态还是<code>pending</code>，所以<code>async1().then()</code>不执行</li>
<li>两个定时器按照时间执行</li>
</ul>
<p>执行结果:</p>
<pre><code>'script start'
'async1'
'promise1'
'script end'
1
'timer2'
'timer1'
</code></pre>
<p>若new的promise对象修改了状态，则执行结果就是：</p>
<pre><code>'script start'
'async1'
'promise1'
'script end'
'async1 end'
'async1 success'
1
'timer2'
'timer1'
</code></pre>
<h2 id="63-题目3">6.3 题目3</h2>
<pre><code>const p1 = new Promise((resolve) =&gt; {
  setTimeout(() =&gt; {
    resolve('resolve3');
    console.log('timer1')
  }, 0)
  resolve('resovle1');
  resolve('resolve2');
}).then(res =&gt; {
  console.log(res)
  setTimeout(() =&gt; {
    console.log(p1)
  }, 1000)
}).finally(res =&gt; {
  console.log('finally', res)
})
</code></pre>
<p>tips:</p>
<ul>
<li>将timer1移入宏任务</li>
<li>修改promise状态为resolved，值修改为resolve1</li>
<li>将.then()移入微任务队列</li>
<li>将第二个定时器移入宏任务队列</li>
<li>将.finally()移入微任务队列</li>
<li>执行.then()，打印resolve1</li>
<li>执行.finally()，由于.finally()的回调函数不接受参数，所以为undefined</li>
<li>执行定时器1，打印timer1</li>
<li>执行定时器2，此时通过链式调用，返回值已经变成undefined</li>
</ul>
<p>执行结果：</p>
<pre><code>'resolve1'
'finally' undefined
'timer1'
Promise{&lt;resolved&gt;: undefined}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[flex布局的使用]]></title>
        <id>https://skrupellose.github.io/post/flex-bu-ju-de-shi-yong/</id>
        <link href="https://skrupellose.github.io/post/flex-bu-ju-de-shi-yong/">
        </link>
        <updated>2020-01-07T05:10:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-认识flex布局">一、认识flex布局</h1>
<p>flex布局已经成为了web开发中使用最多的布局方案</p>
<h2 id="11-两个概念">1.1 两个概念</h2>
<ul>
<li>开启了flex布局的元素叫<code>flex container</code></li>
<li><code>flex container</code>里面的直接子元素叫做<code>flex items</code></li>
</ul>
<h2 id="12-如何开启flex布局">1.2 如何开启flex布局</h2>
<p>设置display属性为flex或者inline-flex可以成为flex container</p>
<ul>
<li>flex：flex container以block-level形式存在</li>
<li>inline-flex：flex container以inline-level形式存在</li>
</ul>
<h1 id="二-flex布局模型">二、flex布局模型</h1>
<figure data-type="image" tabindex="1"><img src="https://skrupellose.github.io/post-images/1578374921989.png" alt="" loading="lazy"></figure>
<h2 id="2flex相关属性">2.flex相关属性</h2>
<h3 id="21-应用在flex-container上的css属性">2.1 应用在flex container上的css属性</h3>
<ul>
<li>flex-flow</li>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<p><code>flex items</code>默认都是沿着<code>main axis</code>(主轴)从<code>main start</code>开始往<code>main end</code>方向排布</p>
<h3 id="211-flex-direction决定了main-axis的方向有四个取值row默认-row-reverse-column-column-reverse">2.1.1 <code>flex-direction</code>决定了<code>main axis</code>的方向，有四个取值：<code>row</code>(默认)、<code>row-reverse</code>、<code>column</code>、<code>column-reverse</code></h3>
<h3 id="212-justify-content决定flex-items的主轴mian-axis对齐方式取值">2.1.2 <code>justify-content</code>决定<code>flex items</code>的主轴(mian axis)对齐方式，取值：</h3>
<ul>
<li>flex-start：与main start对齐</li>
<li>flex-end：与 main end对齐</li>
<li>center：居中对齐</li>
<li>space-between：flex items之间距离相等且与main start、main end两端对齐</li>
<li>space-evenly：flex items之间距离相等且与main start、main end等距</li>
<li>space-around：flex items与main start、main end之间的距离是flex items之间距离的一半</li>
</ul>
<p>若<code>flex items</code>不设置高度，那么默认情况下它的高度就是<code>cross size</code></p>
<h3 id="213-align-items决定了flex-items的交叉轴cross-axis上的对齐方式取值">2.1.3 <code>align-items</code>决定了<code>flex items</code>的交叉轴(cross axis)上的对齐方式,取值：</h3>
<ul>
<li>normal：弹性布局中，效果与stretch一样</li>
<li>stretch：当flex items在cross axis方向的size为auto时，会自动拉伸至填充flex container</li>
<li>flex-start：在交叉轴的起点对齐</li>
<li>flex-end：在交叉轴的终点对齐</li>
<li>center：在交叉轴的中点对齐</li>
<li>baseline：基准线对齐</li>
</ul>
<p>默认情况下所有的flex items会在同一行显示，放不下的会进行收缩然后在同行显示</p>
<h3 id="214-flex-wrap决定了flex-container是单行还是多行用于控制换行取值">2.1.4 <code>flex-wrap</code>决定了flex container是单行还是多行用于控制换行，取值：</h3>
<ul>
<li>normal：默认（单行）</li>
<li>wrap：多行</li>
<li>warp-reverse：多行（对比wrap，cross start和cross end相反）</li>
</ul>
<h3 id="215-flex-flow是flex-directionflex-wrap的简写">2.1.5 <code>flex-flow</code>是flex-direction||flex-wrap的简写</h3>
<ul>
<li>可以省略，顺序随意</li>
</ul>
<h3 id="216-align-content决定了多行flex-items在交叉轴上的对齐方式用法与just-content类似取值">2.1.6 <code>align-content</code>决定了多行flex items在交叉轴上的对齐方式，用法与<code>just-content</code>类似，取值：</h3>
<ul>
<li>flex-start：与cross start对齐</li>
<li>flex-end：与cross end对齐</li>
<li>center：居中对齐</li>
<li>space-between：flex items之间距离相等且与cross start、cross end两端对齐</li>
<li>space-evenly：flex items之间距离相等且与cross start、cross end等距</li>
<li>space-around：flex items与cross start、cross end之间的距离是flex items之间距离的一半</li>
</ul>
<h3 id="22-应用在flex-items上的css属性">2.2 应用在flex items上的css属性</h3>
<ul>
<li>flex</li>
<li>flex-grow</li>
<li>flex-basis</li>
<li>flex-shrink</li>
<li>order</li>
<li>align-self</li>
</ul>
<h3 id="221-order决定了flex-items的排布顺序">2.2.1 <code>order</code>决定了flex items的排布顺序</h3>
<ul>
<li>可以设置成任意整数，数值越小越靠前</li>
<li>默认值是0</li>
</ul>
<h3 id="222-align-self单独决定flex-item的排布顺序通过覆盖flex-container设置的align-items">2.2.2 <code>align-self</code>单独决定flex item的排布顺序（通过覆盖flex container设置的align-items）</h3>
<ul>
<li>auto（默认值）：遵从flex container的align-items设置</li>
<li>stretch、flex-start、flex-end、center、baseline，效果与align-items一致</li>
</ul>
<h3 id="223-flex-grow决定了flex-items如何扩展">2.2.3 <code>flex-grow</code>决定了flex items如何扩展</h3>
<ul>
<li>可以设置成任意非负数字（正小数、正整数、0），默认是0</li>
<li>当flex container在主轴方向有剩余的size的时候，flex-grow属性才会生效</li>
<li>如果所有flex items的flex-grow总和sum超过1，每个flex item扩展的size为：flex container剩余的size * flex-grow / sum</li>
<li>如果所有的flex items的flex-grow总和sum没有超过1，每个flex item扩展的size为：flex container的剩余size * flex-grow</li>
<li>flex items扩展后的最终size不能超过max-width/max-height</li>
</ul>
<h3 id="224-flex-shrink决定了flex-items如何收缩">2.2.4 <code>flex-shrink</code>决定了flex items如何收缩</h3>
<ul>
<li>可以设置成任意非负数字（正小数、正整数、0），默认是1</li>
<li>当flex items在主轴方向上的size超过了flex container的size，flex-shrink超会生效</li>
<li>如果所有的flex items的flex-shrink总和超过1，每个flex items的收缩的size为：flex items超出的flex items超出flex container的size * 收缩比例 / 所有flex items收缩比例之和</li>
<li>如果所有的flex items的flex-shrink总和不超过1，每个flex items收缩的size为：flex items超出的flex container的size * flex-shrink值</li>
<li>flex items收缩之和最终size不能小于min-width/min-height</li>
</ul>
<h3 id="225-flex-basis设置flex-items在主轴方向上的base-size">2.2.5 <code>flex-basis</code>设置flex items在主轴方向上的base size</h3>
<ul>
<li>auto 默认值、具体的宽度数值</li>
<li>决定flex items最终base size的因素，从优先级高到低：<br>
1.max-width/max-height/min-width/min-height<br>
2.flex-basis<br>
3.width/height<br>
4.内容本身的size</li>
</ul>
<h3 id="226-flex是flex-growflex-shrinkflex-basic的缩写属性可以指定1-3个值">2.2.6 <code>flex</code>是flex-grow||flex-shrink||flex-basic的缩写属性，可以指定1-3个值。</h3>
<ul>
<li>
<p>单值语法：值必须为以下值之一：</p>
<ul>
<li>一个无单位数 它会被当作flex-grow的值</li>
<li>一个有效宽度值 它会被当做flex-basis的值</li>
<li>关键字none、auto或者initial</li>
</ul>
</li>
<li>
<p>双值语法：第一个值必须为一个无单位数，它会被当做flex-grow的值</p>
<ul>
<li>第二个值必须为以下之一：
<ul>
<li>一个无单位数，被当做flex-shrink值</li>
<li>一个有效宽度值，被当做flex-basis值</li>
</ul>
</li>
</ul>
</li>
<li>
<p>三值语法：</p>
<ul>
<li>第一个值必须为一个无单位数，被当做flex-grow的值</li>
<li>第二个值必须为一个无单位数，被当做flex-shrink的值</li>
<li>第三个值必须为一个有效宽度值，被当做flex-basis的值</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>