<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skrupellose.github.io</id>
    <title>13&apos;s blog</title>
    <updated>2019-11-09T06:57:42.822Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skrupellose.github.io"/>
    <link rel="self" href="https://skrupellose.github.io/atom.xml"/>
    <subtitle>人类世界真是太有趣了</subtitle>
    <logo>https://skrupellose.github.io/images/avatar.png</logo>
    <icon>https://skrupellose.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 13&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[v-bind的两三事]]></title>
        <id>https://skrupellose.github.io/post/v-bind-de-liang-san-shi</id>
        <link href="https://skrupellose.github.io/post/v-bind-de-liang-san-shi">
        </link>
        <updated>2019-11-09T06:53:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于-v-bind-的两三事">关于 v-bind 的两三事</h1>
<h2 id="一-前言">一、前言</h2>
<p>在之前学习前端的过程中经常是碎片式的学习，没有形成一个知识系统，正好在实习中再次接触到<code>vue.js</code>，结合之前的学习和工作中的使用做一个总结，巩固一下知识点。</p>
<h2 id="二-关于-v-bind">二、关于 v-bind</h2>
<p>在 vue.js 官方教程中介绍<code>v-bind</code>指令可以绑定元素特性</p>
<p>我们上个例子：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;span v-bind:title=&quot;message&quot;&gt;
    鼠标放到这里哟~
  &lt;/span&gt;
&lt;/div&gt;

...

var vm = new Vue({
  el: &quot;#app&quot;,
  data: {
     message: &quot;鼠标移到我身上你就可以看到我&quot;
  }
});
</code></pre>
<p>打开浏览器我们发现：<br>
<img src="https://skrupellose.github.io/post-images/1-1.png" alt=""></p>
<p><code>&lt;span&gt;</code>标签的<code>title</code>属性有了<code>message值</code></p>
<p>这个 <code>title</code>属性规定关于元素的额外信息。</p>
<p>这些信息通常会在鼠标移到元素上时显示一段工具提示文本,如上面的例子。</p>
<p>打开控制台：<br>
<img src="https://skrupellose.github.io/post-images/1-2.png" alt=""><br>
我们发现的确如此。</p>
<h2 id="三-指令预期值">三、指令预期值</h2>
<p>初步了解了<code>v-bind</code>之后，我们继续来看关于指令，vue官方将</p>
<p><code>v-bind:title=&quot;message&quot;</code></p>
<p>分为三部分：</p>
<ol>
<li><code>v-bind</code> 这个称之为指令</li>
<li><code>：</code>后面的<code>title</code> 这个被称为属性</li>
<li><code>message</code> 则被成为‘预期值’</li>
</ol>
<p><code>title</code>除了跟上面例子一样是字符串类型变量外，也可以是一个<code>单一js表达式</code></p>
<p>故属性可以有以下操作：</p>
<p>(1)执行运算</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=&quot;m1 + ' ' + m2&quot;&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;
    ...
    var vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          m1: 'hello',
          m2: 'vue.js'
        }
      });

</code></pre>
<p>查看效果：<br>
<img src="https://skrupellose.github.io/post-images/1-3.png" alt=""></p>
<p>(2)执行函数</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=&quot;show()&quot;&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;
    ...
    var vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          show(){
            return 'hello fn'
          }
        }
      });
</code></pre>
<p><img src="https://skrupellose.github.io/post-images/1-4.png" alt=""><br>
同样的也成功了</p>
<h2 id="四-预期值支持的数据类型">四、预期值支持的数据类型</h2>
<p>我们发现刚才我们预期值传入的都是字符串类型的数据，那么如果传入其他数据类型的会怎么样呢？</p>
<p>那么我们来尝试一下：</p>
<p>(1) 对象</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=obj&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;
......
    var obj = {};
    var vm = new Vue({
      el: '#app',
      data: {
        obj: obj
      }
    });
</code></pre>
<p>打开控制台：<br>
<img src="https://skrupellose.github.io/post-images/1-5.png" alt=""><br>
我们发现了<code>title=&quot;[object Object]&quot;</code>,这个熟悉的字符串让人想起了对象的 <code>toString</code> 方法的返回值。那么我们继续测试：</p>
<p>因为我们创建的对象还没有<code>toString()</code>方法，所以我们给它添加一个，这样它就不用顺着原型链去找了</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=&quot;obj&quot;&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;

    ...
    
      var obj = {};
      obj.toString = function() {
        return &quot;调用了toString()!&quot;;
      };
      var vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          obj: obj
        }
      });
</code></pre>
<p><img src="https://skrupellose.github.io/post-images/1-6.png" alt=""><br>
果然如此，调用了<code>toString()</code>方法。</p>
<p>(2) 数组<br>
接着我们测试数组<br>
数组类型的 <code>toString</code>方法和对象类型的有所不同，它将执行并返回给我们 <code>arr.join(',')</code> 相同的结果。如 <code>[1, 2, 3].toString()</code> 将返回 <code>'1,2,3'</code>。下面进行测试：</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;span v-bind:title=&quot;arr&quot;&gt;
        鼠标放到这里哟~
      &lt;/span&gt;
    &lt;/div&gt;
   ...
      var arr= [1, 2, 3];
      var vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          arr: arr
        }
      });
</code></pre>
<p>结果如下：<br>
<img src="https://skrupellose.github.io/post-images/1-7.png" alt=""><br>
和我们的最初设想一致</p>
<p>(3)其余类型</p>
<ul>
<li>number 类型，正常执行 toString，包括数字0，结果都正常渲染成对应的字符串；</li>
<li>boolean 类型，true 正常渲染成字符串 &quot;true&quot;，但 false 虽然执行 toString 方法将返回 &quot;false&quot; 字符串，但是却没有渲染出来；</li>
<li>null / undefined 类型，二者没有 toString 方法，也没有渲染出来。<br>
显然，在执行 toString 方法之前，vue 内部应该先做了类型校验，满足条件才输出。而且这里不是简单的真 / 假值校验，因为 0 虽为假值，但最终却像真值一样渲染了出来。</li>
</ul>
<h2 id="五-其他操作">五、其他操作</h2>
<p>之前我们发现了预期值传入的是其他数据类型时会执行<code>toString</code>方法,那么当我们想给属性来添加多个值的时候就可以通过对象或者数组来传值了。<br>
比如我们给<code>P标签</code>来增添<code>多个css</code>样式，就可以这么来添加。</p>
<p>说到这里不得不提一下<code>vue</code>对<code>style</code>以及<code>class</code>属性的增强，比如如果我们给p标签的title属性绑定obj，那么最后会执行toString方法返回一个<code>&quot;[object Object]&quot;</code>，但是当绑定的是<code>style</code>以及<code>class</code>的时候，它会自动进行解析。</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p v-bind:title=&quot;obj&quot;&gt;content&lt;/p&gt;
&lt;/div&gt;
...
var obj = {
    color: 'red',
    fontSize: '20px',
};

渲染后的结果为：
&lt;div id=&quot;app&quot;&gt;
    &lt;p title=&quot;[object Object]&quot;&gt;content&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>但是如果是style属性：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p v-bind:style=&quot;obj&quot;&gt;content&lt;/p&gt;
&lt;/div&gt;
...
var obj = {
    color: 'red',
    fontSize: '20px',
};

渲染后的结果为：
&lt;div id=&quot;app&quot;&gt;
    &lt;p style=&quot;color: red; font-size: 20px;&quot;&gt;content&lt;/p&gt;
&lt;/div&gt;

</code></pre>
<p>这是因为vue内部对这两个属性进行了处理：<br>
只论最后结果的话，下面这种方法可以实现将对象转换成行内css样式所需要的格式<br>
具体实现后面还是要看源码。</p>
<pre><code>obj.toString = function () {
    var str = '';
    for(var i in this) {
        if(this[i]) {
            str += i + ':' + this[i] + ';';
        }
    }

    return str;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript之函数预编译]]></title>
        <id>https://skrupellose.github.io/post/javascript-zhi-han-shu-yu-bian-yi</id>
        <link href="https://skrupellose.github.io/post/javascript-zhi-han-shu-yu-bian-yi">
        </link>
        <updated>2019-11-09T04:25:45.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="js执行三部曲语法分析-预编译-解释执行">JS执行三部曲：<strong>语法分析</strong> <strong>预编译</strong> <strong>解释执行</strong></h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="js执行三部曲语法分析-预编译-解释执行">JS执行三部曲：<strong>语法分析</strong> <strong>预编译</strong> <strong>解释执行</strong></h1>
<!-- more -->
<p><strong>语法分析</strong>：简单来说就是浏览器先不运行代码，而是检查你代码是否有语法错误比如少加了符号啊，写入了中文字符等等操作。类似于老师检查你的作文，先不看你的内容怎么样，而是看有没有错别字。(啊哈哈，只是类比一下，好像有点不恰当，老师一般是直接一遍看过去)<br>
<strong>预编译</strong>：<br>
预编译有两个抽象出来的知识点：</p>
<ul>
<li>函数声明整体提升</li>
<li>变量 声明提升</li>
</ul>
<p><strong>函数声明整体提升</strong>指的是当你使用了函数声明，那么函数声明默认会提升至script顶部</p>
<pre><code>	function up(){
          console.log(&quot;hello,world&quot;);
        }
       up();
       //打印hello,world

       up();
       //也能打印出hello,world
	 	function up(){
          console.log(&quot;hello,world&quot;);
        }
    
</code></pre>
<p>这就是说<code>function up(){ console.log(&quot;hello,world&quot;); }</code>这个函数被默认提升到顶部，所以第二种方法执行函数的时候没有报错并且成功了。</p>
<p><strong>变量 声明提升</strong>指的是变量在声明的时候，也会被提升至逻辑的顶端。</p>
<pre><code>var a;
//这个叫做变量声明
var a = 1;
//这个叫做变量初始化 它相当于变量声明加变量赋值的双重操作
//即var a; a = 1;
</code></pre>
<p>我们需要注意的是提升的只有变量声明，也就是说：</p>
<pre><code>console.log(a);
var a = 123;
//这里打印的是undefined而不是123
</code></pre>
<p>上面的操作拆解一下应该是这样：</p>
<pre><code>var a；
console.log(a);
 a = 123;
//这里相当于只声明了变量a但是没有进行赋值，所以打印的是undefined
</code></pre>
<p>但是我们遇到声明的变量为a，声明的函数名也为a，那我们打印的a的时候打印的是哪一个呢？因为两者都有提升，哪一个更加优先呢？</p>
<pre><code>	console.log(a);
		//a(){}
        function a(){
        }
        var a;
</code></pre>
<p>我们发现打印的是函数体a，但是这有可能是因为函数声明写在变量声明之前，那么我们颠倒一下顺序试一试：</p>
<pre><code> 	console.log(a);
 		//a(){}
        var a = 123;
        function a(){
        }
</code></pre>
<p>我们发现结果没有变，还是打印的函数a，那么这个原理是什么呢？我们需要更深的去了解JS预编译的过程。</p>
<p>这里我们先了解两个知识点：</p>
<ol>
<li>imply global 暗示全局变量：即任何变量未经声明就赋值，那么这个变量就为全局对象所有。全局变量指的是window</li>
</ol>
<pre><code>	 a = 123;
        console.log(a);
        //123
        console.log(window.a);
        //123

</code></pre>
<pre><code>	var a = b = 123;
        console.log(window.a);
        //123
        console.log(window.b);
        //123
</code></pre>
<p>这里b变量未经声明就赋值所以变成了window的属性，但是a声明了为什么也变成了window的属性呢？这是因为下面一条规则<br>
2. 一切声明的全局变量全部变为window的属性<br>
上面代码的a是全局声明的，所以它也变成了window的属性。</p>
<pre><code>      
&lt;!-- more --&gt;
 function go(){
         var a = b =123;
       }
       go();
       console.log(window.a);
       //undefined
       console.log(window.b);
       //123


</code></pre>
<p>而当我们在<strong>函数内部</strong>声明变量的时候 它就<strong>不是</strong>全局变量了，它变成了<strong>局部变量</strong>，就不满足第二条规则了，所以打印window.a的时候，结果显示的是undefined，而b还是未声明就赋值，所以它还是一个全局变量，因此打印了出来。</p>
<p>我们继续讲回预编译：<br>
<strong>预编译，它发生在函数执行的前一刻</strong>，它有以下几个环节：</p>
<ol>
<li>创建AO对象 Activation Object（执行期上下文）</li>
<li>找形参和变量声明，将变量和形参名作为AO对象的属性名，值为undefined</li>
<li>将实参形参相统一</li>
<li>在函数体里找到函数声明，把函数声明当做值赋予函数体<br>
让我们根据一个例子操作一下：</li>
</ol>
<pre><code>     function test(a) {
        console.log(a);
        console.log(b); 
        var b = 234;
        console.log(b); 
        a = 123;
        console.log(a);
        function a() {};
        var a;
        b = 234;
        var b = function() {};
        console.log(a); 
        console.log(b); 
        function d() {};
      }
      test(1);
</code></pre>
<ol>
<li>创建AO对象</li>
</ol>
<pre><code>AO{
}
</code></pre>
<ol start="2">
<li>找形参和变量声明，将变量和形参名作为AO对象的属性名，值为undefined</li>
</ol>
<p>我们首先寻找形参，发现函数的形参有a同时变量名它也有a我们只需要保留一个就行了,然后赋值undefined。</p>
<pre><code>AO{
	a : undefined,
	b : undefined,
}
</code></pre>
<ol start="3">
<li>将实参形参相统一<br>
test(1)传的值是1</li>
</ol>
<pre><code>AO{
	a : 1,
	b : undefined,
}
</code></pre>
<p>4.在函数体里找到函数声明，把函数声明当做值赋予函数体。关于函数体，比如:</p>
<pre><code>  function test() {
        console.log(&quot;hello&quot;);
      }
      test();
      console.log(test);
      // function test() {
        console.log(&quot;hello&quot;);
      }
</code></pre>
<p>这里我们打印test，输出的是test这整个函数，test就指代着函数体。<br>
这里我们还需要注意的是 <code>function fn(){}</code>这种形式才叫做<strong>函数声明</strong>，而<code>var fn = function(){}</code>j叫做<strong>函数表达式</strong></p>
<pre><code>AO{
	a : function a (){},
	b : undefined,
	d : function d (){},
}
</code></pre>
<p>然后我们就得到了该函数完整的执行期上下文，然后以此为基础我们开始重新赋值</p>
<pre><code>    function test(a) {
        console.log(a); 1
        console.log(b); 2
        var b = 234;
        console.log(b);  3
        a = 123;
        console.log(a);  4
        function a() {};
        var a;
        b = 234;
        var b = function() {};
        console.log(a);  5
        console.log(b);  6
        function d() {};
      }
      test(1);
</code></pre>
<ol>
<li>第一个打印的a根据AO对象我们知道应该是<code>function a (){}</code></li>
<li>第一个打印的b我们根据AO对象知道应该是<code>undefined</code></li>
<li>第二个打印的b我们这里要注意一下，因为上面有一句赋值语句：<code>var b = 234;</code>，所以这个时候打印的b变成了<code>234</code></li>
<li>同理，第二个打印的a因为上面又进行了赋值，所以变成了<code>123</code></li>
<li>第三个打印的a并没有重新赋值，所以还是<code>123</code></li>
<li>第三个打印的b因为上面将函数体赋给了它，所以它变成了<code>function (){}</code></li>
</ol>
<p>好的，完成了！<br>
那么接下来我们解决刚才的那个问题</p>
<pre><code>	console.log(a);
		//a(){}
        function a(){
        }
        var a;
</code></pre>
<p>按照步骤首先创建AO对象</p>
<pre><code>AO{
}
</code></pre>
<p>然后寻找形参和变量声明并赋值undefined</p>
<pre><code>AO{
a : undefined
}
</code></pre>
<p>接着将实参形参相统一</p>
<p>最后在函数体里找到函数声明，把函数声明当做值赋予函数体</p>
<pre><code>AO{
a : function a (){}
}
</code></pre>
<p>然后打印a，所以最后的结果是 <code>function a (){}</code><br>
这个其实应该用全局的预编译，具体环节和函数预编译差不多，只是我们发现好像第三步形参实参相统一多余了，所以我们<strong>全局预编译</strong>只有三步：</p>
<ol>
<li>创建我们全局的执行上下文叫GO对象即（Global Object）</li>
<li>找变量声明，将变量名作为GO对象的属性名，值为undefined</li>
<li>最后在函数体里找到函数声明，把函数声明当做值赋予函数体<br>
<strong>我们的GO先于AO生成，并且首先元素查找AO，若AO没有则去GO查找</strong><br>
用上面一个例子</li>
</ol>
<pre><code>function go(){
         var a = b =123;
       }
       go();
       console.log(window.a);
       //undefined
       console.log(window.b);
       //123
</code></pre>
<p>首先 ，我们应该先创建GO对象，由于b是一个全局变量所以创建GO对象的时候我们对其进行了初始化的操作最后等于123，因此我们在AO找不到b的时候去GO中寻找，最终打印出了结果。而a在AO对象中，且被赋值为undefined，所以最终输出也为undefined。<br>
<strong>解释执行</strong>：预编译结束之后，就是我们浏览器的解释执行了。</p>
]]></content>
    </entry>
</feed>