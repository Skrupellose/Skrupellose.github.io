<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D.C </title>
<meta name="description" content="人类世界真是太有趣了" />
<link rel="shortcut icon" href="https://skrupellose.github.io/favicon.ico?v=1591633461023">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://skrupellose.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="D.C  - Atom Feed" href="https://skrupellose.github.io/atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://skrupellose.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://skrupellose.github.io/images/avatar.png?v=1591633461023" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">D.C </h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#js%E6%89%A7%E8%A1%8C%E4%B8%89%E9%83%A8%E6%9B%B2%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E9%A2%84%E7%BC%96%E8%AF%91-%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C">JS执行三部曲：<strong>语法分析</strong> <strong>预编译</strong> <strong>解释执行</strong></a></li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
      
        <a href="https://skrupellose.github.io/post/zai-xian-shi-li/" class="menu" style="animation-delay: 0.8s">
          在线实例
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">人间烟火气，最抚凡人心</div>
    <a class="rss" href="https://skrupellose.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">JavaScript之函数预编译</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-11-09 / 8 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://skrupellose.github.io/post-images/javascript-zhi-han-shu-yu-bian-yi.jpg" alt="">
        
        <div class="post-content yue">
          <h1 id="js执行三部曲语法分析-预编译-解释执行">JS执行三部曲：<strong>语法分析</strong> <strong>预编译</strong> <strong>解释执行</strong></h1>
<!-- more -->
<p><strong>语法分析</strong>：简单来说就是浏览器先不运行代码，而是检查你代码是否有语法错误比如少加了符号啊，写入了中文字符等等操作。类似于老师检查你的作文，先不看你的内容怎么样，而是看有没有错别字。(啊哈哈，只是类比一下，好像有点不恰当，老师一般是直接一遍看过去)<br>
<strong>预编译</strong>：<br>
预编译有两个抽象出来的知识点：</p>
<ul>
<li>函数声明整体提升</li>
<li>变量 声明提升</li>
</ul>
<p><strong>函数声明整体提升</strong>指的是当你使用了函数声明，那么函数声明默认会提升至script顶部</p>
<pre><code>	function up(){
          console.log(&quot;hello,world&quot;);
        }
       up();
       //打印hello,world

       up();
       //也能打印出hello,world
	 	function up(){
          console.log(&quot;hello,world&quot;);
        }
    
</code></pre>
<p>这就是说<code>function up(){ console.log(&quot;hello,world&quot;); }</code>这个函数被默认提升到顶部，所以第二种方法执行函数的时候没有报错并且成功了。</p>
<p><strong>变量 声明提升</strong>指的是变量在声明的时候，也会被提升至逻辑的顶端。</p>
<pre><code>var a;
//这个叫做变量声明
var a = 1;
//这个叫做变量初始化 它相当于变量声明加变量赋值的双重操作
//即var a; a = 1;
</code></pre>
<p>我们需要注意的是提升的只有变量声明，也就是说：</p>
<pre><code>console.log(a);
var a = 123;
//这里打印的是undefined而不是123
</code></pre>
<p>上面的操作拆解一下应该是这样：</p>
<pre><code>var a；
console.log(a);
 a = 123;
//这里相当于只声明了变量a但是没有进行赋值，所以打印的是undefined
</code></pre>
<p>但是我们遇到声明的变量为a，声明的函数名也为a，那我们打印的a的时候打印的是哪一个呢？因为两者都有提升，哪一个更加优先呢？</p>
<pre><code>	console.log(a);
		//a(){}
        function a(){
        }
        var a;
</code></pre>
<p>我们发现打印的是函数体a，但是这有可能是因为函数声明写在变量声明之前，那么我们颠倒一下顺序试一试：</p>
<pre><code> 	console.log(a);
 		//a(){}
        var a = 123;
        function a(){
        }
</code></pre>
<p>我们发现结果没有变，还是打印的函数a，那么这个原理是什么呢？我们需要更深的去了解JS预编译的过程。</p>
<p>这里我们先了解两个知识点：</p>
<ol>
<li>imply global 暗示全局变量：即任何变量未经声明就赋值，那么这个变量就为全局对象所有。全局变量指的是window</li>
</ol>
<pre><code>	 a = 123;
        console.log(a);
        //123
        console.log(window.a);
        //123

</code></pre>
<pre><code>	var a = b = 123;
        console.log(window.a);
        //123
        console.log(window.b);
        //123
</code></pre>
<p>这里b变量未经声明就赋值所以变成了window的属性，但是a声明了为什么也变成了window的属性呢？这是因为下面一条规则<br>
2. 一切声明的全局变量全部变为window的属性<br>
上面代码的a是全局声明的，所以它也变成了window的属性。</p>
<pre><code>      
&lt;!-- more --&gt;
 function go(){
         var a = b =123;
       }
       go();
       console.log(window.a);
       //undefined
       console.log(window.b);
       //123


</code></pre>
<p>而当我们在<strong>函数内部</strong>声明变量的时候 它就<strong>不是</strong>全局变量了，它变成了<strong>局部变量</strong>，就不满足第二条规则了，所以打印window.a的时候，结果显示的是undefined，而b还是未声明就赋值，所以它还是一个全局变量，因此打印了出来。</p>
<p>我们继续讲回预编译：<br>
<strong>预编译，它发生在函数执行的前一刻</strong>，它有以下几个环节：</p>
<ol>
<li>创建AO对象 Activation Object（执行期上下文）</li>
<li>找形参和变量声明，将变量和形参名作为AO对象的属性名，值为undefined</li>
<li>将实参形参相统一</li>
<li>在函数体里找到函数声明，把函数声明当做值赋予函数体<br>
让我们根据一个例子操作一下：</li>
</ol>
<pre><code>     function test(a) {
        console.log(a);
        console.log(b); 
        var b = 234;
        console.log(b); 
        a = 123;
        console.log(a);
        function a() {};
        var a;
        b = 234;
        var b = function() {};
        console.log(a); 
        console.log(b); 
        function d() {};
      }
      test(1);
</code></pre>
<ol>
<li>创建AO对象</li>
</ol>
<pre><code>AO{
}
</code></pre>
<ol start="2">
<li>找形参和变量声明，将变量和形参名作为AO对象的属性名，值为undefined</li>
</ol>
<p>我们首先寻找形参，发现函数的形参有a同时变量名它也有a我们只需要保留一个就行了,然后赋值undefined。</p>
<pre><code>AO{
	a : undefined,
	b : undefined,
}
</code></pre>
<ol start="3">
<li>将实参形参相统一<br>
test(1)传的值是1</li>
</ol>
<pre><code>AO{
	a : 1,
	b : undefined,
}
</code></pre>
<p>4.在函数体里找到函数声明，把函数声明当做值赋予函数体。关于函数体，比如:</p>
<pre><code>  function test() {
        console.log(&quot;hello&quot;);
      }
      test();
      console.log(test);
      // function test() {
        console.log(&quot;hello&quot;);
      }
</code></pre>
<p>这里我们打印test，输出的是test这整个函数，test就指代着函数体。<br>
这里我们还需要注意的是 <code>function fn(){}</code>这种形式才叫做<strong>函数声明</strong>，而<code>var fn = function(){}</code>j叫做<strong>函数表达式</strong></p>
<pre><code>AO{
	a : function a (){},
	b : undefined,
	d : function d (){},
}
</code></pre>
<p>然后我们就得到了该函数完整的执行期上下文，然后以此为基础我们开始重新赋值</p>
<pre><code>    function test(a) {
        console.log(a); 1
        console.log(b); 2
        var b = 234;
        console.log(b);  3
        a = 123;
        console.log(a);  4
        function a() {};
        var a;
        b = 234;
        var b = function() {};
        console.log(a);  5
        console.log(b);  6
        function d() {};
      }
      test(1);
</code></pre>
<ol>
<li>第一个打印的a根据AO对象我们知道应该是<code>function a (){}</code></li>
<li>第一个打印的b我们根据AO对象知道应该是<code>undefined</code></li>
<li>第二个打印的b我们这里要注意一下，因为上面有一句赋值语句：<code>var b = 234;</code>，所以这个时候打印的b变成了<code>234</code></li>
<li>同理，第二个打印的a因为上面又进行了赋值，所以变成了<code>123</code></li>
<li>第三个打印的a并没有重新赋值，所以还是<code>123</code></li>
<li>第三个打印的b因为上面将函数体赋给了它，所以它变成了<code>function (){}</code></li>
</ol>
<p>好的，完成了！<br>
那么接下来我们解决刚才的那个问题</p>
<pre><code>	console.log(a);
		//a(){}
        function a(){
        }
        var a;
</code></pre>
<p>按照步骤首先创建AO对象</p>
<pre><code>AO{
}
</code></pre>
<p>然后寻找形参和变量声明并赋值undefined</p>
<pre><code>AO{
a : undefined
}
</code></pre>
<p>接着将实参形参相统一</p>
<p>最后在函数体里找到函数声明，把函数声明当做值赋予函数体</p>
<pre><code>AO{
a : function a (){}
}
</code></pre>
<p>然后打印a，所以最后的结果是 <code>function a (){}</code><br>
这个其实应该用全局的预编译，具体环节和函数预编译差不多，只是我们发现好像第三步形参实参相统一多余了，所以我们<strong>全局预编译</strong>只有三步：</p>
<ol>
<li>创建我们全局的执行上下文叫GO对象即（Global Object）</li>
<li>找变量声明，将变量名作为GO对象的属性名，值为undefined</li>
<li>最后在函数体里找到函数声明，把函数声明当做值赋予函数体<br>
<strong>我们的GO先于AO生成，并且首先元素查找AO，若AO没有则去GO查找</strong><br>
用上面一个例子</li>
</ol>
<pre><code>function go(){
         var a = b =123;
       }
       go();
       console.log(window.a);
       //undefined
       console.log(window.b);
       //123
</code></pre>
<p>首先 ，我们应该先创建GO对象，由于b是一个全局变量所以创建GO对象的时候我们对其进行了初始化的操作最后等于123，因此我们在AO找不到b的时候去GO中寻找，最终打印出了结果。而a在AO对象中，且被赋值为undefined，所以最终输出也为undefined。<br>
<strong>解释执行</strong>：预编译结束之后，就是我们浏览器的解释执行了。</p>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://skrupellose.github.io/tag/qZAGnAXQq/">
            <span class="flex-auto">js</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://skrupellose.github.io/post/v-bind-de-liang-san-shi/">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  v-bind的两三事
                </h3>
              </a>
            </div>
          

          
        </div>

        

      </div>
    </div>

    <script src="https://skrupellose.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
