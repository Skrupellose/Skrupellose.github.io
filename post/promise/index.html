<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D.C </title>
<meta name="description" content="人类世界真是太有趣了" />
<link rel="shortcut icon" href="https://skrupellose.github.io/favicon.ico?v=1586528164791">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://skrupellose.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="D.C  - Atom Feed" href="https://skrupellose.github.io/atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://skrupellose.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://skrupellose.github.io/images/avatar.png?v=1586528164791" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">D.C </h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-promise">一、Promise</a>
<ul>
<li><a href="#11-promise%E6%A6%82%E5%BF%B5">1.1 Promise概念</a>
<ul>
<li><a href="#111-%E5%85%B3%E4%BA%8Epromise">1.1.1 关于Promise</a></li>
<li><a href="#112-promise%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">1.1.2 Promise基础语法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C-promise%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B">二、promise基础题型</a>
<ul>
<li><a href="#21-%E9%A2%98%E7%9B%AE1">2.1 题目1</a></li>
<li><a href="#22-%E9%A2%98%E7%9B%AE2">2.2 题目2</a></li>
<li><a href="#23-%E9%A2%98%E7%9B%AE3">2.3 题目3</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-promise%E7%BB%93%E5%90%88%E5%AE%9A%E6%97%B6%E5%99%A8">三、promise结合定时器</a>
<ul>
<li><a href="#31-%E9%A2%98%E7%9B%AE1">3.1 题目1</a></li>
<li><a href="#32-%E9%A2%98%E7%9B%AE2">3.2 题目2</a></li>
<li><a href="#33-%E9%A2%98%E7%9B%AE3">3.3 题目3</a></li>
<li><a href="#34-%E9%A2%98%E7%9B%AE4">3.4 题目4</a></li>
<li><a href="#35-%E9%A2%98%E7%9B%AE5">3.5 题目5</a></li>
<li><a href="#41-%E9%A2%98%E7%9B%AE1">4.1 题目1</a></li>
<li><a href="#42-%E9%A2%98%E7%9B%AE2">4.2 题目2</a></li>
<li><a href="#43-%E9%A2%98%E7%9B%AE3">4.3 题目3</a></li>
<li><a href="#44-%E9%A2%98%E7%9B%AE4">4.4 题目4</a></li>
<li><a href="#45-%E9%A2%98%E7%9B%AE5">4.5 题目5</a></li>
<li><a href="#46-%E9%A2%98%E7%9B%AE6">4.6 题目6</a></li>
<li><a href="#47-%E9%A2%98%E7%9B%AE7">4.7 题目7</a></li>
<li><a href="#48-%E9%A2%98%E7%9B%AE8">4.8 题目8</a></li>
<li><a href="#49-%E9%A2%98%E7%9B%AE9">4.9 题目9</a></li>
<li><a href="#410-%E9%A2%98%E7%9B%AE10">4.10 题目10</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
      
        <a href="https://skrupellose.github.io/post/zai-xian-shi-li/" class="menu" style="animation-delay: 0.8s">
          在线实例
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">人间烟火气，最抚凡人心</div>
    <a class="rss" href="https://skrupellose.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Promise与相关题型</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-03-04 / 23 min read
        </div>
        
        <div class="post-content yue">
          <h1 id="一-promise">一、Promise</h1>
<h2 id="11-promise概念">1.1 Promise概念</h2>
<h3 id="111-关于promise">1.1.1 关于Promise</h3>
<p>Promise是es6新增的一个API，它本身不是异步的，但是它内部进行封装的往往是异步任务。</p>
<p>Promise容器最开始的状态是<code>Pending</code>，它最后会根据内部任务的成功与否改为<code>Resolved</code>（成功）和<code>Rejected</code>（失败），且不会再次改变状态</p>
<p><strong>Promise容器一旦创建，就开始执行里面的代码</strong></p>
<pre><code>var fs = require('fs')
new Promise(function () {
  fs.readFile('./a.txt','utf8',function(err, data){
    if(err) {
      console.log(err)
    }
    console.log(data)
  })
})
// 就会立马打印出a.txt的内容出来
</code></pre>
<h3 id="112-promise基础语法">1.1.2 Promise基础语法</h3>
<pre><code>var p1 = new Promise(function(resolve, reject) {
  fs.readFile('./a.txt','utf8',function(err, data) {
    if(err) {
      reject(err)
    }
    resolve(data)
  })
})
p1.then(function(data){
  console.log(data)
},function(err){
  console.log(err)
})
</code></pre>
<p>还是刚才的例子我们通过<code>Promise</code>构造函数构造了一个名为p1的<code>Promise</code>实例：<br>
然后在<code>Promise</code>构造函数中传了两个函数作为参数，一个是<code>resolve</code>；一个是<code>reject</code>。<br>
之后在fs.readFile执行后，根据执行结果分别执行<code>reject</code>和<code>resolve</code>方法。<br>
我们想要拿到结果就需要通过构造出的<code>Promise</code>实例的<code>then</code>方法。<br>
<code>then</code>方法也是接受两个函数作为形参，第一个是对应成功时执行；第二个是对应失败后执行。两个方法分别对应上面的<code>resolve</code>和<code>reject</code>。</p>
<p>关于then方法的链式调用需要介绍：<br>
当then方法执行完之后return一个对象，我们就可以对这个对象进行处理，当我们面对回调嵌套的时候就可以使用Promise。</p>
<pre><code>p1.then(function(data){
  console.log(data)
  return p2
}).then(function(data) {
  console.log(data)
  return p3
}).then(function(data){
  console.log(data)
})
</code></pre>
<p>then方法的第一个形参就是调用then方法的实例的resolve方法。<br>
如果return的是一个简单数据类型，那么充当then方法的形参的那个方法就能获取的这个值。</p>
<h1 id="二-promise基础题型">二、promise基础题型</h1>
<h2 id="21-题目1">2.1 题目1</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  console.log(2);
});
promise.then(() =&gt; {
  console.log(3);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li>结果并不是<code>1 2 4 3</code></li>
<li>虽然promise.then属于微任务，但是前面新建的promise对象过程中并没有改变状态。因此promise.then并不会执行</li>
<li>所以执行结果为<code>1 2 4</code></li>
</ul>
<h2 id="22-题目2">2.2 题目2</h2>
<pre><code>const promise1 = newPromise((resolve, reject) =&gt; {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res =&gt; {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);
</code></pre>
<p>tips：</p>
<ul>
<li>第一轮宏任务首先执行<code>promise1</code></li>
<li>然后将<code>promise1</code>的状态修改为<code>resolved</code>，然后保存结果</li>
<li>把<code>promise2</code>放入微任务队列，等待执行</li>
<li>接着执行同步代码1，结果为<code>resolved</code></li>
<li>然后执行同步代码2，结果为<code>pending</code>，因为此时<code>promise2</code>被放入微任务队列还没执行，promise状态为<code>pending</code><br>
所以结果为:</li>
</ul>
<pre><code>'promise1'
'1' Promise{&lt;resolved&gt;: 'resolve1'}
'2' Promise{&lt;pending&gt;}
'resolve1'
</code></pre>
<h2 id="23-题目3">2.3 题目3</h2>
<pre><code>const fn = () =&gt;(new Promise((resolve, reject) =&gt; {
  console.log(1);
  resolve('success')
}))
fn().then(res =&gt; {
  console.log(res)
})
console.log('start')
</code></pre>
<p>tips：</p>
<ul>
<li>首先执行<code>fn</code>函数，它返回一个promise对象，并且将状态修改为<code>resolved</code>，因此首先打印1</li>
<li>然后将<code>.then()</code>放入微任务队列</li>
<li>接着执行同步任务打印<code>start</code></li>
<li>之后执行任务.then()，打印<code>success</code><br>
所以结果为：</li>
</ul>
<pre><code>1
start
success
</code></pre>
<h1 id="三-promise结合定时器">三、promise结合定时器</h1>
<h2 id="31-题目1">3.1 题目1</h2>
<pre><code>console.log('start')
setTimeout(() =&gt; {
  console.log('time')
})
Promise.resolve().then(() =&gt; {
  console.log('resolve')
})
console.log('end')
</code></pre>
<p>tip:</p>
<ul>
<li>首先按照执行顺序，打印<code>start</code></li>
<li>然后遇到定时器将其放入下一个宏任务队列</li>
<li>将<code>promise.then()</code>也放入微任务队列</li>
<li>打印<code>end</code></li>
<li>执行<code>promise.then</code>打印resolve</li>
<li>执行定时器打印<code>time</code></li>
<li>这里还需要注意的是<code>Promise.resolve()</code>相当于定义一个状态为<code>fullfilled</code>的<code>promise</code>，只有<code>fullfilled</code>状态的<code>promise</code>才能执行<code>.then()</code><br>
执行结果：</li>
</ul>
<pre><code>start
end
resolve
time
</code></pre>
<h2 id="32-题目2">3.2 题目2</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  setTimeout(() =&gt; {
    console.log(&quot;timerStart&quot;);
    resolve(&quot;success&quot;);
    console.log(&quot;timerEnd&quot;);
  }, 0);
  console.log(2);
});
promise.then((res) =&gt; {
  console.log(res);
});
console.log(4);
</code></pre>
<p>tip:</p>
<ul>
<li>首先打印<code>1</code></li>
<li>然后将定时器加入下次宏任务队列</li>
<li>打印<code>2</code></li>
<li>将<code>promise.then</code>加入微任务队列</li>
<li>打印<code>4</code></li>
<li>暂不执行<code>promise.then()</code>，虽然此时应该执行微任务中的<code>.then()</code>,但此时<code>promise</code>状态还为<code>pending</code>，所以不执行</li>
<li>最后开始执行宏任务里的定时器打印出timerstart，修改promise状态为<code>resolved</code>，打印<code>timerend</code></li>
<li>此时promise状态已为<code>resolved</code>，开始执行微任务中的<code>.then()</code>，打印出<code>success</code><br>
执行结果：</li>
</ul>
<pre><code>1
2
4
timerstart
timerend
success
</code></pre>
<h2 id="33-题目3">3.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  console.log('promise1');
  const timer2 = setTimeout(() =&gt; {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() =&gt; {
  console.log('timer1')
  Promise.resolve().then(() =&gt; {
    console.log('promise2')
  })
}, 0)
console.log('start');
</code></pre>
<p>tips:</p>
<ul>
<li>首先把<code>promise.then()</code>放入微任务队列</li>
<li>将<code>timer1</code>放入宏任务队列</li>
<li>打印<code>start</code></li>
<li>执行微任务中的<code>promise.then()</code></li>
<li>打印<code>promise1</code></li>
<li>将<code>timer2</code>放入宏任务队列</li>
<li>执行<code>timer1</code>，打印<code>timer1</code>，将第二个<code>promise.then()</code>放入微任务队列</li>
<li>执行第二个<code>promise.then()</code>，打印<code>promise2</code></li>
<li>执行<code>timer2</code>，打印<code>timer2</code></li>
</ul>
<p>执行结果</p>
<pre><code>start
promise1
timer1
promise2
timer2
</code></pre>
<h2 id="34-题目4">3.4 题目4</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() =&gt; {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() =&gt; {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)
</code></pre>
<p>tips:</p>
<ul>
<li>首先执行<code>promise1</code>，将定时器放入宏任务队列</li>
<li>把<code>promise2</code>放入微任务队列</li>
<li>执行同步代码，打印<code>promise1</code>，此时<code>promise1</code>还未改变状态，所以为<code>pending</code></li>
<li>执行同步代码，打印<code>promise2</code>，由于<code>promise1.then()</code>返回的还是一个<code>promise</code>对象，所以为<code>pending</code></li>
<li>将定时器放入宏任务队列</li>
<li><code>promise2</code>暂不执行，因为<code>p1</code>的状态还未修改</li>
<li>执行第一个定时器，将<code>promise1</code>状态修改为<code>resolved</code></li>
<li>执行<code>p2</code>，<code>throw</code>一个错误<code>error</code></li>
<li>执行第二个定时器，打印<code>resolved和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<h2 id="35-题目5">3.5 题目5</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;success&quot;);
    console.log(&quot;timer1&quot;);
  }, 1000);
  console.log(&quot;promise1里的内容&quot;);
});
const promise2 = promise1.then(() =&gt; {
  throw new Error(&quot;error!!!&quot;);
});
console.log(&quot;promise1&quot;, promise1);
console.log(&quot;promise2&quot;, promise2);
setTimeout(() =&gt; {
  console.log(&quot;timer2&quot;);
  console.log(&quot;promise1&quot;, promise1);
  console.log(&quot;promise2&quot;, promise2);
}, 2000);
</code></pre>
<p>tips：</p>
<ul>
<li>执行<code>p1</code>，将第一个定时器放入宏任务队列，并打印<code>p1</code>里的内容</li>
<li>把<code>p2</code>放入微任务队列</li>
<li>执行同步代码，打印两个<code>pending</code></li>
<li>把第二个定时器加入宏任务队列</li>
<li>p1状态未修改暂不执行p2</li>
<li>执行第一个定时器修改p1的状态并打印<code>timer1</code></li>
<li>执行微任务throw一个错误修改p2状态为<code>rejected</code></li>
<li>执行第二个定时器，打印<code>timer2</code>后分别打印<code>resolved:success和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1里的内容'
'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
'timer1'
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'timer2'
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<p>#四、promise进阶</p>
<h2 id="41-题目1">4.1 题目1</h2>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
  reject(&quot;error&quot;);
  resolve(&quot;success2&quot;);
});
promise
.then(res =&gt; {
    console.log(&quot;then1: &quot;, res);
  }).then(res =&gt; {
    console.log(&quot;then2: &quot;, res);
  }).catch(err =&gt; {
    console.log(&quot;catch: &quot;, err);
  }).then(res =&gt; {
    console.log(&quot;then3: &quot;, res);
  })
</code></pre>
<p>tips：</p>
<ul>
<li>promise状态一经改变便不会再次改变，所以promise状态为<code>rejected</code></li>
<li>之后将<code>promise.then()</code>加入微任务队列</li>
<li>直到被<code>catch</code>捕获错误，<code>catch</code>不论连接在哪里都可以捕获到上级错误</li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;catch: &quot; &quot;error&quot;
&quot;then3: &quot; undefined
</code></pre>
<h2 id="42-题目2">4.2 题目2</h2>
<pre><code>Promise.resolve(1)
  .then(res =&gt; {
    console.log(res);
    return2;
  })
  .catch(err =&gt; {
    return3;
  })
  .then(res =&gt; {
    console.log(res);
  });
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve(1)</code>内部返回的结果是1，打印得到1</li>
<li><code>return2</code>被包装成为<code>resolve(2)</code>，所以该<code>promise</code>对象返回值为2</li>
<li><code>resolve</code>下不走<code>catch</code>，<code>.then</code>打印得到<code>2</code></li>
</ul>
<h2 id="43-题目3">4.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  return new Error('error!!!')
}).then(res =&gt; {
  console.log(&quot;then: &quot;, res)
}).catch(err =&gt; {
  console.log(&quot;catch: &quot;, err)
})
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve().then()</code>return一个错误,当promise对象返回的不是一个promise对象的话就会被包装成一个promise对象，<code>return new Error('error!!!')</code>会被包装成<code>return Promise.resolve(new Error('error!!!'))</code></li>
<li>因此走的是.then()而不是.catch()</li>
<li>若想抛出错误，可以<code>return Promise.reject(newError('error!!!'));</code>或者<code>throw newError('error!!!')</code></li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;then: &quot; &quot;Error: error!!!&quot;
</code></pre>
<h2 id="44-题目4">4.4 题目4</h2>
<pre><code>const promise = Promise.resolve().then(() =&gt; {
  return promise;
})
promise.catch(console.err)
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>或者<code>.catch()</code>不能返回promise自身</li>
<li>所以会报错</li>
</ul>
<p>执行结果：</p>
<pre><code>Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
</code></pre>
<h2 id="45-题目5">4.5 题目5</h2>
<pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre>
<p>tips：</p>
<ul>
<li><code>promise.then()</code>和<code>.catch()</code>的期望值是函数</li>
<li>传入非函数就会发生值传透</li>
<li>第一个<code>then</code>传的是数字</li>
<li>第二个<code>then</code>传的是对象</li>
<li>所以第三个<code>then</code>获取的值是<code>1</code></li>
</ul>
<p>执行结果：</p>
<pre><code>1
</code></pre>
<h2 id="46-题目6">4.6 题目6</h2>
<pre><code>Promise.reject('err!!!')
  .then((res) =&gt; {
    console.log('success', res)
  }, (err) =&gt; {
    console.log('error', err)
  }).catch(err =&gt; {
    console.log('catch', err)
  })
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>有两个参数，一个是用来处理<code>promise</code>成功的函数，另一个是处理失败的函数</li>
<li>当有处理失败函数的时候，错误会走失败的函数而不会走.catch()</li>
</ul>
<p>执行结果：</p>
<pre><code>'error' 'error!!!'
</code></pre>
<ul>
<li>若不写第二个函数，则会走<code>.catch()</code>函数</li>
<li>若在执行成功的函数中抛出一个错误，则该错误只能在<code>.catch()</code>中捕获到，不能在第二个处理错误的函数中被捕获</li>
</ul>
<h2 id="47-题目7">4.7 题目7</h2>
<pre><code>Promise.resolve('1')
  .then(res =&gt; {
    console.log(res)
  })
  .finally(() =&gt; {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() =&gt; {
    console.log('finally2')
  	return'我是finally2返回的值'
  })
  .then(res =&gt; {
    console.log('finally2后面的then函数', res)
  })
</code></pre>
<p>tips:</p>
<ul>
<li>第一个<code>promise</code>修改状态为<code>resolved</code>并得到返回值<code>1</code></li>
<li>将<code>.then()</code>移入微任务队列</li>
<li>因为<code>.then()</code>和<code>.finally()</code>是链式调用，<code>.then()</code>不执行，<code>.finally()</code>也不会执行，所以这里会跳出第一个promise函数</li>
<li>第二个promise修改状态为<code>resolved</code>并得到返回值<code>2</code></li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>将第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.then()</code>移入微任务队列</li>
<li>开始执行第一个<code>.then()</code>,得到1</li>
<li>执行第二个<code>.finally()</code>,打印<code>finally2</code>，且返回一个新的值</li>
<li>执行第一个<code>.finally()</code>,打印<code>finally</code></li>
<li>执行第二个<code>.then()</code>,打印结果2，因为<code>.finally()</code>默认返回的都是原来的<code>promise</code>对象的值，只有当抛出的是一个错误，才会返回这个错误*</li>
</ul>
<p>执行结果：</p>
<pre><code>1
finally2
finally
finally2后面的then函数 2
</code></pre>
<p>*:</p>
<pre><code>Promise.resolve('1')
  .finally(() =&gt; {
    console.log('finally1')
    throw new Error('我是finally中抛出的异常')
  })
  .then(res =&gt; {
    console.log('finally后面的then函数', res)
  })
  .catch(err =&gt; {
    console.log('捕获错误', err)
  })
</code></pre>
<pre><code>'finally1'
'捕获错误' Error: 我是finally中抛出的异常
</code></pre>
<h2 id="48-题目8">4.8 题目8</h2>
<pre><code>function promise1 () {
  let p = new Promise((resolve) =&gt; {
    console.log('promise1');
    resolve('1')
  })
  return p;
}
function promise2 () {
  return new Promise((resolve, reject) =&gt; {
    reject('error')
  })
}
promise1()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally1'))

promise2()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally2'))
</code></pre>
<p>tips:</p>
<ul>
<li><code>p1</code>执行，打印<code>promise1</code>，并且修改<code>promise1</code>状态值为<code>resolved</code>，返回<code>1</code></li>
<li>把第一个<code>.then()</code>移入微任务队列</li>
<li>执行<code>p2</code>，返回一个<code>rejected</code>状态的<code>promise</code>对象，返回值为<code>error</code></li>
<li>因为<code>p2</code>状态为<code>rejected</code>，所以第二个<code>.then()</code>不会执行将第二个<code>.catch</code>移入微任务队列</li>
<li>执行第一个<code>.then()</code>，打印<code>1</code></li>
<li>执行第二个<code>.catch()</code>, 打印<code>error</code></li>
<li>之后把第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>执行第一个<code>.finally()</code>，打印<code>finally1</code></li>
<li>执行第二个<code>.finally()</code>，打印<code>finally2</code></li>
</ul>
<p>执行结果：</p>
<pre><code>promise1
1
error
finally1
finally2
</code></pre>
<h2 id="49-题目9">4.9 题目9</h2>
<pre><code>function runAsync (x) {
	const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
	return p
}
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt;console.log(res))
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.all(</code>)并行执行多个异步操作，并在一个回调中处理所有的数据</li>
</ul>
<p>执行结果：</p>
<pre><code>1
2
3
[1, 2, 3]
</code></pre>
<h2 id="410-题目10">4.10 题目10</h2>
<pre><code>function runAsync (x) {
  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
  return p
}
function runReject (x) {
  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
</code></pre>
<p>tips:</p>
<ul>
<li>
<p><code>promise.all()</code>中参数的顺序就是加入任务队列的顺序，但是定时器执行先后由时间长短排序</p>
</li>
<li>
<p>所以执行顺序为<code>runAsync(1)</code>、 <code>runAsync(3)</code>、 <code>runReject(2)</code>、<code>runReject(4)</code></p>
</li>
<li>
<p>又因为<code>runReject</code>函数抛出错误，所以<code>promise.all().then()</code>不会执行，而<code>.catch()</code>会捕获<code>.all()</code>之中最先的异常</p>
<p>执行结果：</p>
<pre><code></code></pre>
</li>
</ul>
<p>1<br>
3<br>
// 2s后输出<br>
2<br>
Error: 2<br>
// 4s后输出<br>
4</p>
<pre><code>
## 4.11 题目11
</code></pre>
<p>function runAsync (x) {<br>
const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))<br>
return p<br>
}<br>
Promise.race([runAsync(1), runAsync(2), runAsync(3)])<br>
.then(res =&gt;console.log('result: ', res))<br>
.catch(err =&gt;console.log(err))</p>
<pre><code>tips：
- `.race()`只会获取最先执行完的结果

执行结果：
</code></pre>
<p>1<br>
'result: ' 1<br>
2<br>
3</p>
<pre><code>
#五、async和await
## 5.1 题目1
</code></pre>
<p>async function async1() {<br>
console.log(&quot;async1 start&quot;);<br>
await async2();<br>
console.log(&quot;async1 end&quot;);<br>
}<br>
async function async2() {<br>
console.log(&quot;async2&quot;);<br>
}<br>
async1();<br>
console.log('start')</p>
<pre><code>tips：
- `async1`函数执行，打印`async1 start`
- 执行`async2`函数，打印`async2`
- 跳出`async1`，打印`start`
- 再打印`async1 end`
- `await`后面的内容将放到下一次执行，类似于`promise.then()`

执行结果：
</code></pre>
<p>'async start'<br>
'promise'<br>
'async1 end'<br>
'start'</p>
<pre><code>
## 5.2 题目2
</code></pre>
<p>async function async1() {<br>
console.log(&quot;async1 start&quot;);<br>
await async2();<br>
console.log(&quot;async1 end&quot;);<br>
}<br>
async function async2() {<br>
setTimeout(() =&gt; {<br>
console.log('timer')<br>
}, 0)<br>
console.log(&quot;async2&quot;);<br>
}<br>
async1();<br>
console.log(&quot;start&quot;)</p>
<pre><code>tips:
- 与上一道题不同的是async2函数内多了一个定时器，定时器会被放到下一次宏任务中执行

执行结果：
</code></pre>
<p>async1 start<br>
async2<br>
start<br>
async1 end<br>
timer</p>
<pre><code>
## 5.3 题目3
</code></pre>
<p>async function async1() {<br>
console.log(&quot;async1 start&quot;);<br>
await async2();<br>
console.log(&quot;async1 end&quot;);<br>
setTimeout(() =&gt; {<br>
console.log('timer1')<br>
}, 0)<br>
}<br>
async function async2() {<br>
setTimeout(() =&gt; {<br>
console.log('timer2')<br>
}, 0)<br>
console.log(&quot;async2&quot;);<br>
}<br>
async1();<br>
setTimeout(() =&gt; {<br>
console.log('timer3')<br>
}, 0)<br>
console.log(&quot;start&quot;)</p>
<pre><code>tips：
- `async1`函数执行，打印`async1 start`
- `async2`函数执行，将`timer2`移入宏任务队列，然后打印`async2`
- 将`timer3`移入宏任务队列
- 打印`start`
- 打印`async1 end`并且将`timer1`移入宏任务队列
- 执行第一个宏任务，打印`timer2`，微任务队列没有任务，将剩下的两个宏任务依次执行打印`timer3`和`timer1`

执行结果：
</code></pre>
<p>async1 start<br>
async2<br>
start<br>
async1 end<br>
timer2<br>
timer3<br>
timer1</p>
<pre><code>
## 5.4 题目4
</code></pre>
<p>async function async1 () {<br>
console.log('async1 start');<br>
await new Promise(resolve =&gt; {<br>
console.log('promise1')<br>
})<br>
console.log('async1 success');<br>
return 'async1 end'<br>
}<br>
console.log('script start')<br>
async1().then(res =&gt;console.log(res))<br>
console.log('script end')</p>
<pre><code>tips:
- 打印`script start`
- `async1`执行
- 打印`async1 start`
- 新创建一个`promise`对象，打印`promise1`
- 将`.then()`加入微任务队列
- 打印`script end`
- 由于新创建的`promise`对象并没有改变状态，所以`.then()`不会执行，`await`后面的内容也不会执行

执行结果：
</code></pre>
<p>'script start'<br>
'async1 start'<br>
'promise1'<br>
'script end'</p>
<pre><code>## 5.5 题目5
</code></pre>
<p>async function async1 () {<br>
console.log('async1 start');<br>
await new Promise(resolve =&gt; {<br>
console.log('promise1')<br>
resolve('promise1 resolve')<br>
}).then(res =&gt;console.log(res))<br>
console.log('async1 success');<br>
return 'async1 end'<br>
}<br>
console.log('script start')<br>
async1().then(res =&gt;console.log(res))<br>
console.log('script end')</p>
<pre><code>
tips:
- 打印`script start`
- `async1`执行，打印`async1 start`
- 新建一个`promise`对象，打印`promise1`，修改状态为`resolved`，返回值为`promise1 resolve`
- 打印`script end`
- 执行`.then()`
- 打印`async1 success`
- 修改`promise`返回值为`async1 end`
- 执行第二个`.then()`，打印`async1 end`

执行结果：
</code></pre>
<p>'script start'<br>
'async1 start'<br>
'promise1'<br>
'script end'<br>
'promise1 resolve'<br>
'async1 success'<br>
'async1 end'</p>
<pre><code>## 5.6 题目6
</code></pre>
<p>async function testSometing() {<br>
console.log(&quot;执行testSometing&quot;);<br>
return&quot;testSometing&quot;;<br>
}</p>
<p>async function testAsync() {<br>
console.log(&quot;执行testAsync&quot;);<br>
return Promise.resolve(&quot;hello async&quot;);<br>
}</p>
<p>async function test() {<br>
console.log(&quot;test start...&quot;);<br>
const v1 = await testSometing();<br>
console.log(v1);<br>
const v2 = await testAsync();<br>
console.log(v2);<br>
console.log(v1, v2);<br>
}</p>
<p>test();</p>
<p>var promise = newPromise(resolve =&gt; {<br>
console.log(&quot;promise start...&quot;);<br>
resolve(&quot;promise&quot;);<br>
});<br>
promise.then(val =&gt;console.log(val));</p>
<p>console.log(&quot;test end...&quot;);</p>
<pre><code>tips:
- 执行`test`函数，打印`test start`
- 执行`testSomething`函数，打印`执行testSomething`
- 跳出`test`函数，打印`promise start`并且修改promise的值和状态
- 将`.then()`加入微任务队列
- 打印`test end`
- 打印`v1`的值 `testSomething`
- 执行`testAsync`函数，打印`执行testAsync`
- 跳出`tes`t函数，执行微任务的`.then()`,打印`promise`
- 打印`v2`的值` hello async`
- 打印`v1`、`v2`的值

</code></pre>
<p>'test start...'<br>
'执行testSometing'<br>
'promise start...'<br>
'test end...'<br>
'testSometing'<br>
'执行testAsync'<br>
'promise'<br>
'hello async'<br>
'testSometing' 'hello async'</p>
<pre><code>
## 5.7 题目7
</code></pre>
<p>async function async1 () {<br>
await async2();<br>
console.log('async1');<br>
return 'async1 success'<br>
}<br>
async function async2 () {<br>
return new Promise((resolve, reject) =&gt; {<br>
console.log('async2')<br>
reject('error')<br>
})<br>
}<br>
async1().then(res =&gt;console.log(res))</p>
<pre><code>
tips:
- `async`函数中抛出了错误，则不会往下继续执行
- `throw new Error`是一样的效果

执行结果：
</code></pre>
<p>'async2'<br>
Uncaught (in promise) error</p>
<pre><code>## 5.8 题目8
</code></pre>
<p>async function async1 () {<br>
try {<br>
await Promise.reject('error!!!')<br>
} catch(e) {<br>
console.log(e)<br>
}<br>
console.log('async1');<br>
return Promise.resolve('async1 success')<br>
}<br>
async1().then(res =&gt;console.log(res))<br>
console.log('script start')</p>
<pre><code>
tips:
- 若不想错误影响函数后面的执行则可以使用`try catch `

执行结果：
</code></pre>
<p>'script start'<br>
'error!!!'<br>
'async1'<br>
'async1 success'</p>
<pre><code>或者在`Promise.reject`后面跟着一个`catch()`方法
</code></pre>
<p>async function async1 () {<br>
await Promise.reject('error!!!')<br>
.catch(e =&gt;console.log(e))<br>
console.log('async1');<br>
return Promise.resolve('async1 success')<br>
}<br>
async1().then(res =&gt;console.log(res))<br>
console.log('script start')</p>
<pre><code>#六、综合题
## 6.1 题目1
</code></pre>
<p>const first = () =&gt;(new Promise((resolve, reject) =&gt; {<br>
console.log(3);<br>
let p = new Promise((resolve, reject) =&gt; {<br>
console.log(7);<br>
setTimeout(() =&gt; {<br>
console.log(5);<br>
resolve(6);<br>
console.log(p)<br>
}, 0)<br>
resolve(1);<br>
});<br>
resolve(2);<br>
p.then((arg) =&gt; {<br>
console.log(arg);<br>
});</p>
<p>}));</p>
<p>first().then((arg) =&gt; {<br>
console.log(arg);<br>
});<br>
console.log(4);</p>
<pre><code>tips:
- `first`函数执行，打印`3`
- 新建第二个`promise`对象，打印`7`，将定时器移入宏任务队列，并且修改值和状态为`1`和`resolved`
- 将第一个`promise`对象的值和状态修改为`2`和`resolved`
- 将`p.then()`移入微任务队列
- 将`first.then()`移入微任务队列
- 打印`4`
- 执行`p.then()`打印`1`
- 执行`first.then()`打印`2`
- 最后执行宏任务里的定时器
- 打印`5`，修改`p`的状态和返回值，但是`p`的状态已经改变过了，所以不会再改变，打印`Promise{&lt;resolved&gt;: 1}`

执行结果：
</code></pre>
<p>3<br>
7<br>
4<br>
1<br>
2<br>
5<br>
Promise{<resolved>: 1}</p>
<pre><code>
## 6.2 题目2
</code></pre>
<p>const async1 = async () =&gt; {<br>
console.log('async1');<br>
setTimeout(() =&gt; {<br>
console.log('timer1')<br>
}, 2000)<br>
await new Promise(resolve =&gt; {<br>
console.log('promise1')<br>
resolve(2)<br>
})<br>
console.log('async1 end')<br>
return 'async1 success'<br>
}<br>
console.log('script start');<br>
async1().then(res =&gt;console.log(res));<br>
console.log('script end');<br>
Promise.resolve(1)<br>
.then(2)<br>
.then(Promise.resolve(3))<br>
.catch(4)<br>
.then(res =&gt;console.log(res))<br>
setTimeout(() =&gt; {<br>
console.log('timer2')<br>
}, 1000)</p>
<pre><code>tips:
- 打印`script start`
- 执行`async1`函数，打印`async1`，将`timer1`移入宏任务队列
- 新创建一个`promise`对象，打印`promise1`
- 跳出`async1`，打印`script end`
- 获得一个状态为`resolved`且值为`1`的`promise`对象，由于发生值穿透，直接将最后一个`.then()`加入微任务队列
- 将`timer2`移入宏任务队列
- new 的promise对象没有修改状态，所以下面的程序不会执行
- 把`async1().then()`加入微任务队列，依次执行两个微任务,又因为`async1`函数中的`promise`对象状态还是`pending`，所以`async1().then()`不执行
- 两个定时器按照时间执行

执行结果:
</code></pre>
<p>'script start'<br>
'async1'<br>
'promise1'<br>
'script end'<br>
1<br>
'timer2'<br>
'timer1'</p>
<pre><code>若new的promise对象修改了状态，则执行结果就是：
</code></pre>
<p>'script start'<br>
'async1'<br>
'promise1'<br>
'script end'<br>
'async1 end'<br>
'async1 success'<br>
1<br>
'timer2'<br>
'timer1'</p>
<pre><code>
## 6.3 题目3
</code></pre>
<p>const p1 = new Promise((resolve) =&gt; {<br>
setTimeout(() =&gt; {<br>
resolve('resolve3');<br>
console.log('timer1')<br>
}, 0)<br>
resolve('resovle1');<br>
resolve('resolve2');<br>
}).then(res =&gt; {<br>
console.log(res)<br>
setTimeout(() =&gt; {<br>
console.log(p1)<br>
}, 1000)<br>
}).finally(res =&gt; {<br>
console.log('finally', res)<br>
})</p>
<pre><code>tips:
- 将timer1移入宏任务
- 修改promise状态为resolved，值修改为resolve1
- 将.then()移入微任务队列
- 将第二个定时器移入宏任务队列
- 将.finally()移入微任务队列
- 执行.then()，打印resolve1
- 执行.finally()，由于.finally()的回调函数不接受参数，所以为undefined
- 执行定时器1，打印timer1
- 执行定时器2，此时通过链式调用，返回值已经变成undefined

执行结果：
</code></pre>
<p>'resolve1'<br>
'finally' undefined<br>
'timer1'<br>
Promise{<resolved>: undefined}</p>
<pre><code></code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://skrupellose.github.io/tag/yGKzI8K4m/">
            <span class="flex-auto">Promise</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://skrupellose.github.io/post/mongodb-bi-ji/">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  MongoDB笔记
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://skrupellose.github.io/post/flex-bu-ju-de-shi-yong/">
                <h3 class="post-title">
                  flex布局的使用
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://skrupellose.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
