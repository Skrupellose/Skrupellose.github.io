<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D.C </title>
<meta name="description" content="人类世界真是太有趣了" />
<link rel="shortcut icon" href="https://skrupellose.github.io/favicon.ico?v=1591633332465">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://skrupellose.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="D.C  - Atom Feed" href="https://skrupellose.github.io/atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://skrupellose.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://skrupellose.github.io/images/avatar.png?v=1591633332465" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">D.C </h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-promise">一、Promise</a>
<ul>
<li><a href="#11-promise%E6%A6%82%E5%BF%B5">1.1 Promise概念</a>
<ul>
<li><a href="#111-%E5%85%B3%E4%BA%8Epromise">1.1.1 关于Promise</a></li>
<li><a href="#112-promise%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">1.1.2 Promise基础语法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C-promise%E5%9F%BA%E7%A1%80%E9%A2%98%E5%9E%8B">二、promise基础题型</a>
<ul>
<li><a href="#21-%E9%A2%98%E7%9B%AE1">2.1 题目1</a></li>
<li><a href="#22-%E9%A2%98%E7%9B%AE2">2.2 题目2</a></li>
<li><a href="#23-%E9%A2%98%E7%9B%AE3">2.3 题目3</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-promise%E7%BB%93%E5%90%88%E5%AE%9A%E6%97%B6%E5%99%A8">三、promise结合定时器</a>
<ul>
<li><a href="#31-%E9%A2%98%E7%9B%AE1">3.1 题目1</a></li>
<li><a href="#32-%E9%A2%98%E7%9B%AE2">3.2 题目2</a></li>
<li><a href="#33-%E9%A2%98%E7%9B%AE3">3.3 题目3</a></li>
<li><a href="#34-%E9%A2%98%E7%9B%AE4">3.4 题目4</a></li>
<li><a href="#35-%E9%A2%98%E7%9B%AE5">3.5 题目5</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-promise%E8%BF%9B%E9%98%B6">四、promise进阶</a>
<ul>
<li><a href="#41-%E9%A2%98%E7%9B%AE1">4.1 题目1</a></li>
<li><a href="#42-%E9%A2%98%E7%9B%AE2">4.2 题目2</a></li>
<li><a href="#43-%E9%A2%98%E7%9B%AE3">4.3 题目3</a></li>
<li><a href="#44-%E9%A2%98%E7%9B%AE4">4.4 题目4</a></li>
<li><a href="#45-%E9%A2%98%E7%9B%AE5">4.5 题目5</a></li>
<li><a href="#46-%E9%A2%98%E7%9B%AE6">4.6 题目6</a></li>
<li><a href="#47-%E9%A2%98%E7%9B%AE7">4.7 题目7</a></li>
<li><a href="#48-%E9%A2%98%E7%9B%AE8">4.8 题目8</a></li>
<li><a href="#49-%E9%A2%98%E7%9B%AE9">4.9 题目9</a></li>
<li><a href="#410-%E9%A2%98%E7%9B%AE10">4.10 题目10</a></li>
<li><a href="#411-%E9%A2%98%E7%9B%AE11">4.11 题目11</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-async%E5%92%8Cawait">五、async和await</a>
<ul>
<li><a href="#51-%E9%A2%98%E7%9B%AE1">5.1 题目1</a></li>
<li><a href="#52-%E9%A2%98%E7%9B%AE2">5.2 题目2</a></li>
<li><a href="#53-%E9%A2%98%E7%9B%AE3">5.3 题目3</a></li>
<li><a href="#54-%E9%A2%98%E7%9B%AE4">5.4 题目4</a></li>
<li><a href="#55-%E9%A2%98%E7%9B%AE5">5.5 题目5</a></li>
<li><a href="#56-%E9%A2%98%E7%9B%AE6">5.6 题目6</a></li>
<li><a href="#57-%E9%A2%98%E7%9B%AE7">5.7 题目7</a></li>
<li><a href="#58-%E9%A2%98%E7%9B%AE8">5.8 题目8</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E7%BB%BC%E5%90%88%E9%A2%98">六、综合题</a>
<ul>
<li><a href="#61-%E9%A2%98%E7%9B%AE1">6.1 题目1</a></li>
<li><a href="#62-%E9%A2%98%E7%9B%AE2">6.2 题目2</a></li>
<li><a href="#63-%E9%A2%98%E7%9B%AE3">6.3 题目3</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
      
        <a href="https://skrupellose.github.io/post/zai-xian-shi-li/" class="menu" style="animation-delay: 0.8s">
          在线实例
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">人间烟火气，最抚凡人心</div>
    <a class="rss" href="https://skrupellose.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Promise与相关题型</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-03-04 / 23 min read
        </div>
        
        <div class="post-content yue">
          <h1 id="一-promise">一、Promise</h1>
<h2 id="11-promise概念">1.1 Promise概念</h2>
<h3 id="111-关于promise">1.1.1 关于Promise</h3>
<p>Promise是es6新增的一个API，它本身不是异步的，但是它内部进行封装的往往是异步任务。</p>
<p>Promise容器最开始的状态是<code>Pending</code>，它最后会根据内部任务的成功与否改为<code>Resolved</code>（成功）和<code>Rejected</code>（失败），且不会再次改变状态</p>
<p><strong>Promise容器一旦创建，就开始执行里面的代码</strong></p>
<pre><code>var fs = require('fs')
new Promise(function () {
  fs.readFile('./a.txt','utf8',function(err, data){
    if(err) {
      console.log(err)
    }
    console.log(data)
  })
})
// 就会立马打印出a.txt的内容出来
</code></pre>
<h3 id="112-promise基础语法">1.1.2 Promise基础语法</h3>
<pre><code>var p1 = new Promise(function(resolve, reject) {
  fs.readFile('./a.txt','utf8',function(err, data) {
    if(err) {
      reject(err)
    }
    resolve(data)
  })
})
p1.then(function(data){
  console.log(data)
},function(err){
  console.log(err)
})
</code></pre>
<p>还是刚才的例子我们通过<code>Promise</code>构造函数构造了一个名为p1的<code>Promise</code>实例：<br>
然后在<code>Promise</code>构造函数中传了两个函数作为参数，一个是<code>resolve</code>；一个是<code>reject</code>。<br>
之后在fs.readFile执行后，根据执行结果分别执行<code>reject</code>和<code>resolve</code>方法。<br>
我们想要拿到结果就需要通过构造出的<code>Promise</code>实例的<code>then</code>方法。<br>
<code>then</code>方法也是接受两个函数作为形参，第一个是对应成功时执行；第二个是对应失败后执行。两个方法分别对应上面的<code>resolve</code>和<code>reject</code>。</p>
<p>关于then方法的链式调用需要介绍：<br>
当then方法执行完之后return一个对象，我们就可以对这个对象进行处理，当我们面对回调嵌套的时候就可以使用Promise。</p>
<pre><code>p1.then(function(data){
  console.log(data)
  return p2
}).then(function(data) {
  console.log(data)
  return p3
}).then(function(data){
  console.log(data)
})
</code></pre>
<p>then方法的第一个形参就是调用then方法的实例的resolve方法。<br>
如果return的是一个简单数据类型，那么充当then方法的形参的那个方法就能获取的这个值。</p>
<h1 id="二-promise基础题型">二、promise基础题型</h1>
<h2 id="21-题目1">2.1 题目1</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  console.log(2);
});
promise.then(() =&gt; {
  console.log(3);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li>结果并不是<code>1 2 4 3</code></li>
<li>虽然promise.then属于微任务，但是前面新建的promise对象过程中并没有改变状态。因此promise.then并不会执行</li>
<li>所以执行结果为<code>1 2 4</code></li>
</ul>
<h2 id="22-题目2">2.2 题目2</h2>
<pre><code>const promise1 = newPromise((resolve, reject) =&gt; {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res =&gt; {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);
</code></pre>
<p>tips：</p>
<ul>
<li>第一轮宏任务首先执行<code>promise1</code></li>
<li>然后将<code>promise1</code>的状态修改为<code>resolved</code>，然后保存结果</li>
<li>把<code>promise2</code>放入微任务队列，等待执行</li>
<li>接着执行同步代码1，结果为<code>resolved</code></li>
<li>然后执行同步代码2，结果为<code>pending</code>，因为此时<code>promise2</code>被放入微任务队列还没执行，promise状态为<code>pending</code><br>
所以结果为:</li>
</ul>
<pre><code>'promise1'
'1' Promise{&lt;resolved&gt;: 'resolve1'}
'2' Promise{&lt;pending&gt;}
'resolve1'
</code></pre>
<h2 id="23-题目3">2.3 题目3</h2>
<pre><code>const fn = () =&gt;(new Promise((resolve, reject) =&gt; {
  console.log(1);
  resolve('success')
}))
fn().then(res =&gt; {
  console.log(res)
})
console.log('start')
</code></pre>
<p>tips：</p>
<ul>
<li>首先执行<code>fn</code>函数，它返回一个promise对象，并且将状态修改为<code>resolved</code>，因此首先打印1</li>
<li>然后将<code>.then()</code>放入微任务队列</li>
<li>接着执行同步任务打印<code>start</code></li>
<li>之后执行任务.then()，打印<code>success</code><br>
所以结果为：</li>
</ul>
<pre><code>1
start
success
</code></pre>
<h1 id="三-promise结合定时器">三、promise结合定时器</h1>
<h2 id="31-题目1">3.1 题目1</h2>
<pre><code>console.log('start')
setTimeout(() =&gt; {
  console.log('time')
})
Promise.resolve().then(() =&gt; {
  console.log('resolve')
})
console.log('end')
</code></pre>
<p>tips:</p>
<ul>
<li>首先按照执行顺序，打印<code>start</code></li>
<li>然后遇到定时器将其放入下一个宏任务队列</li>
<li>将<code>promise.then()</code>也放入微任务队列</li>
<li>打印<code>end</code></li>
<li>执行<code>promise.then</code>打印resolve</li>
<li>执行定时器打印<code>time</code></li>
<li>这里还需要注意的是<code>Promise.resolve()</code>相当于定义一个状态为<code>fullfilled</code>的<code>promise</code>，只有<code>fullfilled</code>状态的<code>promise</code>才能执行<code>.then()</code><br>
执行结果：</li>
</ul>
<pre><code>start
end
resolve
time
</code></pre>
<h2 id="32-题目2">3.2 题目2</h2>
<pre><code>const promise = newPromise((resolve, reject) =&gt; {
  console.log(1);
  setTimeout(() =&gt; {
    console.log(&quot;timerStart&quot;);
    resolve(&quot;success&quot;);
    console.log(&quot;timerEnd&quot;);
  }, 0);
  console.log(2);
});
promise.then((res) =&gt; {
  console.log(res);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li>首先打印<code>1</code></li>
<li>然后将定时器加入下次宏任务队列</li>
<li>打印<code>2</code></li>
<li>将<code>promise.then</code>加入微任务队列</li>
<li>打印<code>4</code></li>
<li>暂不执行<code>promise.then()</code>，虽然此时应该执行微任务中的<code>.then()</code>,但此时<code>promise</code>状态还为<code>pending</code>，所以不执行</li>
<li>最后开始执行宏任务里的定时器打印出timerstart，修改promise状态为<code>resolved</code>，打印<code>timerend</code></li>
<li>此时promise状态已为<code>resolved</code>，开始执行微任务中的<code>.then()</code>，打印出<code>success</code><br>
执行结果：</li>
</ul>
<pre><code>1
2
4
timerstart
timerend
success
</code></pre>
<h2 id="33-题目3">3.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  console.log('promise1');
  const timer2 = setTimeout(() =&gt; {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() =&gt; {
  console.log('timer1')
  Promise.resolve().then(() =&gt; {
    console.log('promise2')
  })
}, 0)
console.log('start');
</code></pre>
<p>tips:</p>
<ul>
<li>首先把<code>promise.then()</code>放入微任务队列</li>
<li>将<code>timer1</code>放入宏任务队列</li>
<li>打印<code>start</code></li>
<li>执行微任务中的<code>promise.then()</code></li>
<li>打印<code>promise1</code></li>
<li>将<code>timer2</code>放入宏任务队列</li>
<li>执行<code>timer1</code>，打印<code>timer1</code>，将第二个<code>promise.then()</code>放入微任务队列</li>
<li>执行第二个<code>promise.then()</code>，打印<code>promise2</code></li>
<li>执行<code>timer2</code>，打印<code>timer2</code></li>
</ul>
<p>执行结果</p>
<pre><code>start
promise1
timer1
promise2
timer2
</code></pre>
<h2 id="34-题目4">3.4 题目4</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() =&gt; {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() =&gt; {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)
</code></pre>
<p>tips:</p>
<ul>
<li>首先执行<code>promise1</code>，将定时器放入宏任务队列</li>
<li>把<code>promise2</code>放入微任务队列</li>
<li>执行同步代码，打印<code>promise1</code>，此时<code>promise1</code>还未改变状态，所以为<code>pending</code></li>
<li>执行同步代码，打印<code>promise2</code>，由于<code>promise1.then()</code>返回的还是一个<code>promise</code>对象，所以为<code>pending</code></li>
<li>将定时器放入宏任务队列</li>
<li><code>promise2</code>暂不执行，因为<code>p1</code>的状态还未修改</li>
<li>执行第一个定时器，将<code>promise1</code>状态修改为<code>resolved</code></li>
<li>执行<code>p2</code>，<code>throw</code>一个错误<code>error</code></li>
<li>执行第二个定时器，打印<code>resolved和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<h2 id="35-题目5">3.5 题目5</h2>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;success&quot;);
    console.log(&quot;timer1&quot;);
  }, 1000);
  console.log(&quot;promise1里的内容&quot;);
});
const promise2 = promise1.then(() =&gt; {
  throw new Error(&quot;error!!!&quot;);
});
console.log(&quot;promise1&quot;, promise1);
console.log(&quot;promise2&quot;, promise2);
setTimeout(() =&gt; {
  console.log(&quot;timer2&quot;);
  console.log(&quot;promise1&quot;, promise1);
  console.log(&quot;promise2&quot;, promise2);
}, 2000);
</code></pre>
<p>tips：</p>
<ul>
<li>执行<code>p1</code>，将第一个定时器放入宏任务队列，并打印<code>p1</code>里的内容</li>
<li>把<code>p2</code>放入微任务队列</li>
<li>执行同步代码，打印两个<code>pending</code></li>
<li>把第二个定时器加入宏任务队列</li>
<li>p1状态未修改暂不执行p2</li>
<li>执行第一个定时器修改p1的状态并打印<code>timer1</code></li>
<li>执行微任务throw一个错误修改p2状态为<code>rejected</code></li>
<li>执行第二个定时器，打印<code>timer2</code>后分别打印<code>resolved:success和rejected</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'promise1里的内容'
'promise1' Promise{&lt;pending&gt;}
'promise2' Promise{&lt;pending&gt;}
'timer1'
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'timer2'
'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;}
'promise2' Promise{&lt;rejected&gt;: Error: error!!!}
</code></pre>
<h1 id="四-promise进阶">四、promise进阶</h1>
<h2 id="41-题目1">4.1 题目1</h2>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
  reject(&quot;error&quot;);
  resolve(&quot;success2&quot;);
});
promise
.then(res =&gt; {
    console.log(&quot;then1: &quot;, res);
  }).then(res =&gt; {
    console.log(&quot;then2: &quot;, res);
  }).catch(err =&gt; {
    console.log(&quot;catch: &quot;, err);
  }).then(res =&gt; {
    console.log(&quot;then3: &quot;, res);
  })
</code></pre>
<p>tips：</p>
<ul>
<li>promise状态一经改变便不会再次改变，所以promise状态为<code>rejected</code></li>
<li>之后将<code>promise.then()</code>加入微任务队列</li>
<li>直到被<code>catch</code>捕获错误，<code>catch</code>不论连接在哪里都可以捕获到上级错误</li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;catch: &quot; &quot;error&quot;
&quot;then3: &quot; undefined
</code></pre>
<h2 id="42-题目2">4.2 题目2</h2>
<pre><code>Promise.resolve(1)
  .then(res =&gt; {
    console.log(res);
    return2;
  })
  .catch(err =&gt; {
    return3;
  })
  .then(res =&gt; {
    console.log(res);
  });
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve(1)</code>内部返回的结果是1，打印得到1</li>
<li><code>return2</code>被包装成为<code>resolve(2)</code>，所以该<code>promise</code>对象返回值为2</li>
<li><code>resolve</code>下不走<code>catch</code>，<code>.then</code>打印得到<code>2</code></li>
</ul>
<h2 id="43-题目3">4.3 题目3</h2>
<pre><code>Promise.resolve().then(() =&gt; {
  return new Error('error!!!')
}).then(res =&gt; {
  console.log(&quot;then: &quot;, res)
}).catch(err =&gt; {
  console.log(&quot;catch: &quot;, err)
})
</code></pre>
<p>tips:</p>
<ul>
<li><code>Promise.resolve().then()</code>return一个错误,当promise对象返回的不是一个promise对象的话就会被包装成一个promise对象，<code>return new Error('error!!!')</code>会被包装成<code>return Promise.resolve(new Error('error!!!'))</code></li>
<li>因此走的是.then()而不是.catch()</li>
<li>若想抛出错误，可以<code>return Promise.reject(newError('error!!!'));</code>或者<code>throw newError('error!!!')</code></li>
</ul>
<p>执行结果：</p>
<pre><code>&quot;then: &quot; &quot;Error: error!!!&quot;
</code></pre>
<h2 id="44-题目4">4.4 题目4</h2>
<pre><code>const promise = Promise.resolve().then(() =&gt; {
  return promise;
})
promise.catch(console.err)
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>或者<code>.catch()</code>不能返回promise自身</li>
<li>所以会报错</li>
</ul>
<p>执行结果：</p>
<pre><code>Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
</code></pre>
<h2 id="45-题目5">4.5 题目5</h2>
<pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre>
<p>tips：</p>
<ul>
<li><code>promise.then()</code>和<code>.catch()</code>的期望值是函数</li>
<li>传入非函数就会发生值传透</li>
<li>第一个<code>then</code>传的是数字</li>
<li>第二个<code>then</code>传的是对象</li>
<li>所以第三个<code>then</code>获取的值是<code>1</code></li>
</ul>
<p>执行结果：</p>
<pre><code>1
</code></pre>
<h2 id="46-题目6">4.6 题目6</h2>
<pre><code>Promise.reject('err!!!')
  .then((res) =&gt; {
    console.log('success', res)
  }, (err) =&gt; {
    console.log('error', err)
  }).catch(err =&gt; {
    console.log('catch', err)
  })
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.then()</code>有两个参数，一个是用来处理<code>promise</code>成功的函数，另一个是处理失败的函数</li>
<li>当有处理失败函数的时候，错误会走失败的函数而不会走.catch()</li>
</ul>
<p>执行结果：</p>
<pre><code>'error' 'error!!!'
</code></pre>
<ul>
<li>若不写第二个函数，则会走<code>.catch()</code>函数</li>
<li>若在执行成功的函数中抛出一个错误，则该错误只能在<code>.catch()</code>中捕获到，不能在第二个处理错误的函数中被捕获</li>
</ul>
<h2 id="47-题目7">4.7 题目7</h2>
<pre><code>Promise.resolve('1')
  .then(res =&gt; {
    console.log(res)
  })
  .finally(() =&gt; {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() =&gt; {
    console.log('finally2')
  	return'我是finally2返回的值'
  })
  .then(res =&gt; {
    console.log('finally2后面的then函数', res)
  })
</code></pre>
<p>tips:</p>
<ul>
<li>第一个<code>promise</code>修改状态为<code>resolved</code>并得到返回值<code>1</code></li>
<li>将<code>.then()</code>移入微任务队列</li>
<li>因为<code>.then()</code>和<code>.finally()</code>是链式调用，<code>.then()</code>不执行，<code>.finally()</code>也不会执行，所以这里会跳出第一个promise函数</li>
<li>第二个promise修改状态为<code>resolved</code>并得到返回值<code>2</code></li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>将第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.then()</code>移入微任务队列</li>
<li>开始执行第一个<code>.then()</code>,得到1</li>
<li>执行第二个<code>.finally()</code>,打印<code>finally2</code>，且返回一个新的值</li>
<li>执行第一个<code>.finally()</code>,打印<code>finally</code></li>
<li>执行第二个<code>.then()</code>,打印结果2，因为<code>.finally()</code>默认返回的都是原来的<code>promise</code>对象的值，只有当抛出的是一个错误，才会返回这个错误*</li>
</ul>
<p>执行结果：</p>
<pre><code>1
finally2
finally
finally2后面的then函数 2
</code></pre>
<p>*:</p>
<pre><code>Promise.resolve('1')
  .finally(() =&gt; {
    console.log('finally1')
    throw new Error('我是finally中抛出的异常')
  })
  .then(res =&gt; {
    console.log('finally后面的then函数', res)
  })
  .catch(err =&gt; {
    console.log('捕获错误', err)
  })
</code></pre>
<pre><code>'finally1'
'捕获错误' Error: 我是finally中抛出的异常
</code></pre>
<h2 id="48-题目8">4.8 题目8</h2>
<pre><code>function promise1 () {
  let p = new Promise((resolve) =&gt; {
    console.log('promise1');
    resolve('1')
  })
  return p;
}
function promise2 () {
  return new Promise((resolve, reject) =&gt; {
    reject('error')
  })
}
promise1()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally1'))

promise2()
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
  .finally(() =&gt;console.log('finally2'))
</code></pre>
<p>tips:</p>
<ul>
<li><code>p1</code>执行，打印<code>promise1</code>，并且修改<code>promise1</code>状态值为<code>resolved</code>，返回<code>1</code></li>
<li>把第一个<code>.then()</code>移入微任务队列</li>
<li>执行<code>p2</code>，返回一个<code>rejected</code>状态的<code>promise</code>对象，返回值为<code>error</code></li>
<li>因为<code>p2</code>状态为<code>rejected</code>，所以第二个<code>.then()</code>不会执行将第二个<code>.catch</code>移入微任务队列</li>
<li>执行第一个<code>.then()</code>，打印<code>1</code></li>
<li>执行第二个<code>.catch()</code>, 打印<code>error</code></li>
<li>之后把第一个<code>.finally()</code>移入微任务队列</li>
<li>将第二个<code>.finally()</code>移入微任务队列</li>
<li>执行第一个<code>.finally()</code>，打印<code>finally1</code></li>
<li>执行第二个<code>.finally()</code>，打印<code>finally2</code></li>
</ul>
<p>执行结果：</p>
<pre><code>promise1
1
error
finally1
finally2
</code></pre>
<h2 id="49-题目9">4.9 题目9</h2>
<pre><code>function runAsync (x) {
	const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
	return p
}
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt;console.log(res))
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.all(</code>)并行执行多个异步操作，并在一个回调中处理所有的数据</li>
</ul>
<p>执行结果：</p>
<pre><code>1
2
3
[1, 2, 3]
</code></pre>
<h2 id="410-题目10">4.10 题目10</h2>
<pre><code>function runAsync (x) {
  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
  return p
}
function runReject (x) {
  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res =&gt;console.log(res))
  .catch(err =&gt;console.log(err))
</code></pre>
<p>tips:</p>
<ul>
<li><code>promise.all()</code>中参数的顺序就是加入任务队列的顺序，但是定时器执行先后由时间长短排序</li>
<li>所以执行顺序为<code>runAsync(1)</code>、 <code>runAsync(3)</code>、 <code>runReject(2)</code>、<code>runReject(4)</code></li>
<li>又因为<code>runReject</code>函数抛出错误，所以<code>promise.all().then()</code>不会执行，而<code>.catch()</code>会捕获<code>.all()</code>之中最先的异常</li>
</ul>
<p>执行结果：</p>
<pre><code>1
3
// 2s后输出
2
Error: 2
// 4s后输出
4
</code></pre>
<h2 id="411-题目11">4.11 题目11</h2>
<pre><code>function runAsync (x) {
const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
return p
}
Promise.race([runAsync(1), runAsync(2), runAsync(3)])
.then(res =&gt;console.log('result: ', res))
.catch(err =&gt;console.log(err))
</code></pre>
<p>tips：</p>
<ul>
<li><code>.race()</code>只会获取最先执行完的结果</li>
</ul>
<p>执行结果：</p>
<pre><code>1
'result: ' 1
2
3
</code></pre>
<h1 id="五-async和await">五、async和await</h1>
<h2 id="51-题目1">5.1 题目1</h2>
<pre><code>async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
}
async function async2() {
  console.log(&quot;async2&quot;);
}
async1();
console.log('start')
</code></pre>
<p>tips：</p>
<ul>
<li><code>async1</code>函数执行，打印<code>async1 start</code></li>
<li>执行<code>async2</code>函数，打印<code>async2</code></li>
<li>跳出<code>async1</code>，打印<code>start</code></li>
<li>再打印<code>async1 end</code></li>
<li><code>await</code>后面的内容将放到下一次执行，类似于<code>promise.then()</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'async start'
'promise'
'async1 end'
'start'
</code></pre>
<h2 id="52-题目2">5.2 题目2</h2>
<pre><code>async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
}
async function async2() {
  setTimeout(() =&gt; {
    console.log('timer')
  }, 0)
  console.log(&quot;async2&quot;);
}
async1();
console.log(&quot;start&quot;)
</code></pre>
<p>tips:</p>
<ul>
<li>与上一道题不同的是async2函数内多了一个定时器，定时器会被放到下一次宏任务中执行</li>
</ul>
<p>执行结果：</p>
<pre><code>async1 start
async2
start
async1 end
timer
</code></pre>
<h2 id="53-题目3">5.3 题目3</h2>
<pre><code>async function async1() {
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
  setTimeout(() =&gt; {
    console.log('timer1')
  }, 0)
}
async function async2() {
  setTimeout(() =&gt; {
    console.log('timer2')
  }, 0)
  console.log(&quot;async2&quot;);
}
async1();
setTimeout(() =&gt; {
  console.log('timer3')
}, 0)
console.log(&quot;start&quot;)
</code></pre>
<p>tips：</p>
<ul>
<li><code>async1</code>函数执行，打印<code>async1 start</code></li>
<li><code>async2</code>函数执行，将<code>timer2</code>移入宏任务队列，然后打印<code>async2</code></li>
<li>将<code>timer3</code>移入宏任务队列</li>
<li>打印<code>start</code></li>
<li>打印<code>async1 end</code>并且将<code>timer1</code>移入宏任务队列</li>
<li>执行第一个宏任务，打印<code>timer2</code>，微任务队列没有任务，将剩下的两个宏任务依次执行打印<code>timer3</code>和<code>timer1</code></li>
</ul>
<p>执行结果：</p>
<pre><code>async1 start
async2
start
async1 end
timer2
timer3
timer1
</code></pre>
<h2 id="54-题目4">5.4 题目4</h2>
<pre><code>async function async1 () {
  console.log('async1 start');
  await new Promise(resolve =&gt; {
    console.log('promise1')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('script start')
async1().then(res =&gt;console.log(res))
console.log('script end')
</code></pre>
<p>tips:</p>
<ul>
<li>打印<code>script start</code></li>
<li><code>async1</code>执行</li>
<li>打印<code>async1 start</code></li>
<li>新创建一个<code>promise</code>对象，打印<code>promise1</code></li>
<li>将<code>.then()</code>加入微任务队列</li>
<li>打印<code>script end</code></li>
<li>由于新创建的<code>promise</code>对象并没有改变状态，所以<code>.then()</code>不会执行，<code>await</code>后面的内容也不会执行</li>
</ul>
<p>执行结果：</p>
<pre><code>'script start'
'async1 start'
'promise1'
'script end'
</code></pre>
<h2 id="55-题目5">5.5 题目5</h2>
<pre><code>async function async1 () {
  console.log('async1 start');
  await new Promise(resolve =&gt; {
    console.log('promise1')
    resolve('promise1 resolve')
  }).then(res =&gt;console.log(res))
  console.log('async1 success');
  return 'async1 end'
}
console.log('script start')
async1().then(res =&gt;console.log(res))
console.log('script end')
</code></pre>
<p>tips:</p>
<ul>
<li>打印<code>script start</code></li>
<li><code>async1</code>执行，打印<code>async1 start</code></li>
<li>新建一个<code>promise</code>对象，打印<code>promise1</code>，修改状态为<code>resolved</code>，返回值为<code>promise1 resolve</code></li>
<li>打印<code>script end</code></li>
<li>执行<code>.then()</code></li>
<li>打印<code>async1 success</code></li>
<li>修改<code>promise</code>返回值为<code>async1 end</code></li>
<li>执行第二个<code>.then()</code>，打印<code>async1 end</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'script start'
'async1 start'
'promise1'
'script end'
'promise1 resolve'
'async1 success'
'async1 end'
</code></pre>
<h2 id="56-题目6">5.6 题目6</h2>
<pre><code>async function testSometing() {
  console.log(&quot;执行testSometing&quot;);
  return&quot;testSometing&quot;;
}

async function testAsync() {
  console.log(&quot;执行testAsync&quot;);
  return Promise.resolve(&quot;hello async&quot;);
}

async function test() {
  console.log(&quot;test start...&quot;);
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
}

test();

var promise = newPromise(resolve =&gt; {
  console.log(&quot;promise start...&quot;);
  resolve(&quot;promise&quot;);
});
promise.then(val =&gt;console.log(val));

console.log(&quot;test end...&quot;);
</code></pre>
<p>tips:</p>
<ul>
<li>执行<code>test</code>函数，打印<code>test start</code></li>
<li>执行<code>testSomething</code>函数，打印<code>执行testSomething</code></li>
<li>跳出<code>test</code>函数，打印<code>promise start</code>并且修改promise的值和状态</li>
<li>将<code>.then()</code>加入微任务队列</li>
<li>打印<code>test end</code></li>
<li>打印<code>v1</code>的值 <code>testSomething</code></li>
<li>执行<code>testAsync</code>函数，打印<code>执行testAsync</code></li>
<li>跳出<code>tes</code>t函数，执行微任务的<code>.then()</code>,打印<code>promise</code></li>
<li>打印<code>v2</code>的值<code>hello async</code></li>
<li>打印<code>v1</code>、<code>v2</code>的值</li>
</ul>
<pre><code>'test start...'
'执行testSometing'
'promise start...'
'test end...'
'testSometing'
'执行testAsync'
'promise'
'hello async'
'testSometing' 'hello async'
</code></pre>
<h2 id="57-题目7">5.7 题目7</h2>
<pre><code>async function async1 () {
  await async2();
  console.log('async1');
  return 'async1 success'
}
async function async2 () {
  return new Promise((resolve, reject) =&gt; {
    console.log('async2')
    reject('error')
  })
}
async1().then(res =&gt;console.log(res))
</code></pre>
<p>tips:</p>
<ul>
<li><code>async</code>函数中抛出了错误，则不会往下继续执行</li>
<li><code>throw new Error</code>是一样的效果</li>
</ul>
<p>执行结果：</p>
<pre><code>'async2'
Uncaught (in promise) error
</code></pre>
<h2 id="58-题目8">5.8 题目8</h2>
<pre><code>async function async1 () {
  try {
    await Promise.reject('error!!!')
  } catch(e) {
    console.log(e)
  }
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res =&gt;console.log(res))
console.log('script start')
</code></pre>
<p>tips:</p>
<ul>
<li>若不想错误影响函数后面的执行则可以使用<code>try catch</code></li>
</ul>
<p>执行结果：</p>
<pre><code>'script start'
'error!!!'
'async1'
'async1 success'
</code></pre>
<p>或者在<code>Promise.reject</code>后面跟着一个<code>catch()</code>方法</p>
<pre><code>async function async1 () {
   await Promise.reject('error!!!')
        .catch(e =&gt;console.log(e))
   console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res =&gt;console.log(res))
console.log('script start')
</code></pre>
<h1 id="六-综合题">六、综合题</h1>
<h2 id="61-题目1">6.1 题目1</h2>
<pre><code>const first = () =&gt;(new Promise((resolve, reject) =&gt; {
    console.log(3);
    let p = new Promise((resolve, reject) =&gt; {
        console.log(7);
        setTimeout(() =&gt; {
            console.log(5);
            resolve(6);
          	console.log(p)
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) =&gt; {
        console.log(arg);
    });

}));

first().then((arg) =&gt; {
    console.log(arg);
});
console.log(4);
</code></pre>
<p>tips:</p>
<ul>
<li><code>first</code>函数执行，打印<code>3</code></li>
<li>新建第二个<code>promise</code>对象，打印<code>7</code>，将定时器移入宏任务队列，并且修改值和状态为<code>1</code>和<code>resolved</code></li>
<li>将第一个<code>promise</code>对象的值和状态修改为<code>2</code>和<code>resolved</code></li>
<li>将<code>p.then()</code>移入微任务队列</li>
<li>将<code>first.then()</code>移入微任务队列</li>
<li>打印<code>4</code></li>
<li>执行<code>p.then()</code>打印<code>1</code></li>
<li>执行<code>first.then()</code>打印<code>2</code></li>
<li>最后执行宏任务里的定时器</li>
<li>打印<code>5</code>，修改<code>p</code>的状态和返回值，但是<code>p</code>的状态已经改变过了，所以不会再改变，打印<code>Promise{&lt;resolved&gt;: 1}</code></li>
</ul>
<p>执行结果：</p>
<pre><code>3
7
4
1
2
5
Promise{&lt;resolved&gt;: 1}
</code></pre>
<h2 id="62-题目2">6.2 题目2</h2>
<pre><code>const async1 = async () =&gt; {
  console.log('async1');
  setTimeout(() =&gt; {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve =&gt; {
    console.log('promise1')
    resolve(2)
  })
  console.log('async1 end')
  return 'async1 success'
}
console.log('script start');
async1().then(res =&gt;console.log(res));
console.log('script end');
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res =&gt;console.log(res))
setTimeout(() =&gt; {
  console.log('timer2')
}, 1000)
</code></pre>
<p>tips:</p>
<ul>
<li>打印<code>script start</code></li>
<li>执行<code>async1</code>函数，打印<code>async1</code>，将<code>timer1</code>移入宏任务队列</li>
<li>新创建一个<code>promise</code>对象，打印<code>promise1</code></li>
<li>跳出<code>async1</code>，打印<code>script end</code></li>
<li>获得一个状态为<code>resolved</code>且值为<code>1</code>的<code>promise</code>对象，由于发生值穿透，直接将最后一个<code>.then()</code>加入微任务队列</li>
<li>将<code>timer2</code>移入宏任务队列</li>
<li>new 的promise对象没有修改状态，所以下面的程序不会执行</li>
<li>把<code>async1().then()</code>加入微任务队列，依次执行两个微任务,又因为<code>async1</code>函数中的<code>promise</code>对象状态还是<code>pending</code>，所以<code>async1().then()</code>不执行</li>
<li>两个定时器按照时间执行</li>
</ul>
<p>执行结果:</p>
<pre><code>'script start'
'async1'
'promise1'
'script end'
1
'timer2'
'timer1'
</code></pre>
<p>若new的promise对象修改了状态，则执行结果就是：</p>
<pre><code>'script start'
'async1'
'promise1'
'script end'
'async1 end'
'async1 success'
1
'timer2'
'timer1'
</code></pre>
<h2 id="63-题目3">6.3 题目3</h2>
<pre><code>const p1 = new Promise((resolve) =&gt; {
  setTimeout(() =&gt; {
    resolve('resolve3');
    console.log('timer1')
  }, 0)
  resolve('resovle1');
  resolve('resolve2');
}).then(res =&gt; {
  console.log(res)
  setTimeout(() =&gt; {
    console.log(p1)
  }, 1000)
}).finally(res =&gt; {
  console.log('finally', res)
})
</code></pre>
<p>tips:</p>
<ul>
<li>将timer1移入宏任务</li>
<li>修改promise状态为resolved，值修改为resolve1</li>
<li>将.then()移入微任务队列</li>
<li>将第二个定时器移入宏任务队列</li>
<li>将.finally()移入微任务队列</li>
<li>执行.then()，打印resolve1</li>
<li>执行.finally()，由于.finally()的回调函数不接受参数，所以为undefined</li>
<li>执行定时器1，打印timer1</li>
<li>执行定时器2，此时通过链式调用，返回值已经变成undefined</li>
</ul>
<p>执行结果：</p>
<pre><code>'resolve1'
'finally' undefined
'timer1'
Promise{&lt;resolved&gt;: undefined}
</code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://skrupellose.github.io/tag/yGKzI8K4m/">
            <span class="flex-auto">Promise</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://skrupellose.github.io/post/mongodb-bi-ji/">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  MongoDB笔记
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://skrupellose.github.io/post/flex-bu-ju-de-shi-yong/">
                <h3 class="post-title">
                  flex布局的使用
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://skrupellose.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
